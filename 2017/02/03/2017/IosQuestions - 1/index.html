<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><title>IosQuestions - 1 - 追马</title><meta name="description" content="Ios的有关问题"><link type="text/css" rel="stylesheet" href="/css/pure.css?v=0.0.1"><link type="text/css" rel="stylesheet" href="/css/style.css?v=0.0.1"><script type="text/javascript" src="//cdn.bootcss.com/jquery/1.11.0/jquery.min.js"></script></head></html><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">IosQuestions - 1</h1><a id="logo" href="/.">追马</a></div><div id="nav-menu"><div class="bitcron_nav"><div class="site_nav_wrap"><div class="site_nav"><span class="a_container"><a href="/." class="selected active current">首页</a></span><span class="a_container"><a href="/archives/">归档</a></span><span class="a_container"><a href="/about/">关于</a></span><span class="a_container"><a href="/atom.xml">订阅</a></span></div></div></div></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">IosQuestions - 1</h1><div class="post-meta">2017-02-03<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" type="text/javascript"></script><span class="meta-space">  |  </span><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span><span> 浏览</span></span></div><!--文章内容--><div class="post-content"><h3 id="面试题积累"><a href="#面试题积累" class="headerlink" title="面试题积累"></a>面试题积累</h3><p>(<a href="http://www.cocoachina.com/ios/20160323/15770.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20160323/15770.html</a>)<br>(<a href="http://blog.csdn.net/chenyufeng1991/article/details/53472284" target="_blank" rel="external">http://blog.csdn.net/chenyufeng1991/article/details/53472284</a>)<br>(<a href="http://blog.csdn.net/q469587851/article/details/50591904?locationNum=13" target="_blank" rel="external">http://blog.csdn.net/q469587851/article/details/50591904?locationNum=13</a>)<br>(<a href="http://www.cocoachina.com/ios/20150825/13195.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20150825/13195.html</a>)<br>(<a href="http://www.cocoachina.com/programmer/20151019/13746.html" target="_blank" rel="external">http://www.cocoachina.com/programmer/20151019/13746.html</a>)<br>(<a href="http://www.mamicode.com/info-detail-988919.html" target="_blank" rel="external">http://www.mamicode.com/info-detail-988919.html</a>)<br>(<a href="https://sanwen8.cn/p/1d4ih4t.html" target="_blank" rel="external">https://sanwen8.cn/p/1d4ih4t.html</a>)<br>(<a href="https://github.com/ChenYilong/iOSInterviewQuestions/" target="_blank" rel="external">https://github.com/ChenYilong/iOSInterviewQuestions/</a>)<br>(<a href="http://www.jianshu.com/p/b61cd0bc2abe" target="_blank" rel="external">http://www.jianshu.com/p/b61cd0bc2abe</a>)<br>(<a href="https://chenhu1001.github.io/page/2/" target="_blank" rel="external">https://chenhu1001.github.io/page/2/</a>)</p>
<h4 id="1-倒计时如何实现-（NSTimer，还有其他的实现方式吗"><a href="#1-倒计时如何实现-（NSTimer，还有其他的实现方式吗" class="headerlink" title="1.倒计时如何实现?（NSTimer，还有其他的实现方式吗)?"></a>1.倒计时如何实现?（NSTimer，还有其他的实现方式吗)?</h4><ul>
<li><p>创建方式1</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInteral:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(action:) userInfo:ni] repeat:<span class="literal">NO</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>参数<br>TimerIntval:执行之前等待的时间.比如设置成1.0 就代表1秒后执行;<br>target:需要执行方法的对象;<br>selector:需要执行的方法;<br>repeats:是否需要循环;</p>
</li>
<li><p>释放</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[timer invalidate];</div></pre></td></tr></table></figure>
</li>
<li><p>注意<br>调用创建方法后,target对象的引用计数会+1,直到执行完毕,自动-1.如果循环执行的话必须手动关闭.否则可以不执行释放方法;</p>
</li>
<li>特性<br>1.存在延迟:不管是一次性还是周期性的timer的实际触发事件的时间,都会与所加入的RunLoop和RunLoopMode有关.如果RunLoop正在执行一个连续的运算,timer就会被延迟触发.重复性的timer遇到这种情况,如果延迟超过一个周期,则会和后面的触发进行合并，即在一个周期内只会触发一次。但是不管该timer的触发时间延迟的有多离谱，他后面的timer的触发时间总是倍数于第一次添加timer的间隙。<br>2.必须加入RunLoop::使用上面的创建方式,会自动把timer加入MainRunloop的NSDefaultRunLoopMode中.如果使用以下方式创建定时器,就必须手动加入Runloop:</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">5</span> target:<span class="keyword">self</span> seletor:<span class="keyword">@selector</span>(timerAction) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line">[[<span class="built_in">NSRunloop</span> mainRunloop] addTimer:timer forMode:<span class="built_in">NSDefaultRunloopMode</span>];</div></pre></td></tr></table></figure>
<ul>
<li><p>创建方式2(CADisplayLink)</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> sel:ector:<span class="keyword">@selector</span>(handleDisplaylink:)];</div><div class="line">[<span class="keyword">self</span>.displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> curentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>释放</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.displayLink invailidate];</div><div class="line"><span class="keyword">self</span>.displayLink = <span class="literal">nil</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>注意<br>当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时,CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。</p>
</li>
<li><p>特性<br>1.屏幕刷新时调用:CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。所以通常情况下，按照iOS设备屏幕的刷新率60次/秒。<br>2.延迟:OS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。</p>
</li>
<li><p>使用场景<br>从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。</p>
</li>
<li><p>重要的属性<br>1.NSInteger类型的值，用来设置间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。<br>2.readOnly的CFTimeInterval值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：调用间隔时间 = duration × frameInterval。</p>
</li>
<li><p>创建方式3(GCD)</p>
</li>
<li>GCD定时器不受RunLoop约束，比NSTimer更加准时.</li>
<li><p>执行一次的操作</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">2.0</span>;</div><div class="line">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</div><div class="line">    <span class="comment">//执行事件</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>重复执行的操作</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//证明，实现GCD定时器</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="comment">/** 定时器(这里不用带*，因为dispatch_source_t就是个类，内部已经包含了*) */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="comment">// 获得队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div><div class="line"><span class="comment">// 创建一个定时器(dispatch_source_t本质还是个OC对象)</span></div><div class="line"><span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</div><div class="line"><span class="comment">// 设置定时器的各种属性（几时开始任务，每隔多长时间执行一次）</span></div><div class="line"><span class="comment">// GCD的时间参数，一般是纳秒（1秒 == 10的9次方纳秒）</span></div><div class="line"><span class="comment">// 何时开始执行第一个任务</span></div><div class="line"><span class="comment">// dispatch_time(DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC) 比当前时间晚3秒</span></div><div class="line">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">uint64_t interval = (uint64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">dispatch_source_set_timer(<span class="keyword">self</span>.timer, start, interval, <span class="number">0</span>);</div><div class="line"><span class="comment">// 设置回调</span></div><div class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"------------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    count++;</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</div><div class="line">        <span class="comment">// 取消定时器</span></div><div class="line">        dispatch_cancel(<span class="keyword">self</span>.timer);</div><div class="line">        <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 启动定时器</span></div><div class="line">dispatch_resume(<span class="keyword">self</span>.timer);</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://my.oschina.net/u/2340880/blog/398598" target="_blank" rel="external">其他创建定时器需要需要注意的地方</a></p>
<h4 id="2-UIButton的继承关系？"><a href="#2-UIButton的继承关系？" class="headerlink" title="2.UIButton的继承关系？"></a>2.UIButton的继承关系？</h4><p>UIButton继承与UIControl继承与UIView继承与UIResponder继承与NSObject。</p>
<h4 id="3-Ios中可以进行输入的控件-UITextView-UITextField）？"><a href="#3-Ios中可以进行输入的控件-UITextView-UITextField）？" class="headerlink" title="3.Ios中可以进行输入的控件(UITextView,UITextField）？"></a>3.Ios中可以进行输入的控件(UITextView,UITextField）？</h4><ul>
<li>继承关系<br>UITextField继承自UIView，UITextView继承自UIScrollView。</li>
<li>文本行数<br>UITextView支持多行输入，可以滑屏垂直滚动，UITextField仅支持单行输入。</li>
<li>Placeholder<br>UITextField支持设置Placeholder属性，即在用户输入文本前显示提示性的内容，而UITextView则没有这个功能。</li>
</ul>
</div><!--文章标签--><div class="tags"></div><!--评论--></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" id="search" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"> 分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Ios/">Ios</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">21</span></li></ul></div><div class="widget"><div class="widget-title"> 标签</div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"> 最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/08/2018/2017知识点/">IosQuestions - 4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/2017/音乐锁屏键的处理/">音乐锁屏键的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/11/2017/Runtime/">Ios运行时Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/10/2017/IOS开发的知名大牛博客/">IOS开发的知名大牛博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/05/2017/IosQuestions - 3/">IosQuestions - 3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/04/2017/IosQuestions - 2/">IosQuestions - 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/03/2017/IosQuestions - 1/">IosQuestions - 1</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/17/2016/网络库的详解/">Ios网络库AFNetworking详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/30/2016/图片缓存的优化/">Ios图片缓存的优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/13/2016/Ios的储存方案/">Ios常见的储存方案</a></li></ul></div><div class="widget"><div class="widget-title"> 友情链接</div><ul class="links-list"><li class="links-list-item"><a href="http://www.example.com" title="标题" target="_blank">标题</a></li></ul></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">追马.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> Theme<a target="_blank" href="https://github.com/7ye/maupassant-hexo"> Maupassant.</a></div><a id="back_to_top" href="javascript:void(0)" class="back_to_top"><span>△</span></a><script type="text/javascript" src="/js/totop.js?v=0.0.1"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1"></script><script>function auto_code_fit(){
  if($(".highlight").length != 0){
    var pc_width = $(".post-content").width();
    $(".highlight .code").find("pre").width((pc_width-70)+"px");
  }
}
window.onresize = function(){
  auto_code_fit();
}
auto_code_fit();</script></div></body>