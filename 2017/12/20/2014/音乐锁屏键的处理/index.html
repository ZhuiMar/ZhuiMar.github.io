<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><title>音乐锁屏键的处理 - zhuimar</title><meta name="description" content="音乐锁屏键的处理"><link type="text/css" rel="stylesheet" href="/css/pure.css?v=0.0.1"><link type="text/css" rel="stylesheet" href="/css/style.css?v=0.0.1"><script type="text/javascript" src="//cdn.bootcss.com/jquery/1.11.0/jquery.min.js"></script></head></html><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">音乐锁屏键的处理</h1><a id="logo" href="/.">zhuimar</a></div><div id="nav-menu"><div class="bitcron_nav"><div class="site_nav_wrap"><div class="site_nav"><span class="a_container"><a href="/." class="selected active current">首页</a></span><span class="a_container"><a href="/archives/">归档</a></span><span class="a_container"><a href="/about/">关于</a></span><span class="a_container"><a href="/atom.xml">订阅</a></span></div></div></div></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">音乐锁屏键的处理</h1><div class="post-meta">2017-12-20<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" type="text/javascript"></script><span class="meta-space">  |  </span><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span><span> 浏览</span></span></div><!--文章内容--><div class="post-content"><h4 id="完整的思路"><a href="#完整的思路" class="headerlink" title="完整的思路"></a>完整的思路</h4><ul>
<li>1.App如果需要在锁屏界面上显示相关的信息和按钮, 必须先开启远程控制事件(Remote Control Event), 否则锁屏界面只显示滑动解锁.</li>
<li>2.实现锁屏界面信息, 将歌曲的相关信息更新到锁屏界面上</li>
<li>3.实现锁屏界面的事件处理, 在锁屏界面和上拉的快速功能菜单中实现播放控制</li>
</ul>
<h4 id="远程控制事件的实现"><a href="#远程控制事件的实现" class="headerlink" title="远程控制事件的实现"></a>远程控制事件的实现</h4><p>在iOS7.1之前, 远程控制事件主要涉及以下三个方法:<br>开始接收远程控制事件<br>结束接收远程控制事件<br>触发远程控制事件后的捕获处理<br>官方文档对这三个方法的描述如下, 这里做了简单的翻译.</p>
<h4 id="开始接收远程控制事件"><a href="#开始接收远程控制事件" class="headerlink" title="开始接收远程控制事件"></a>开始接收远程控制事件</h4><p>让App开始接收远程控制事件, 该方法属于UIApplication类<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)beginReceivingRemoteControlEvents;</div></pre></td></tr></table></figure></p>
<p>在iOS7.1之后, 使用MPRemoteCommandCenter的共享对象来注册远程控制事件. 当使用shared command center时, 不需要再调用该方法.<br>该方法会开始使用事件响应链来传递远程控制事件. 远程控制事件是当耳机和外部附件意图控制App的多媒体表现时发出的命令. 要停止远程控制事件的接收, 必须调用endReceivingRemoteControlEvents方法</p>
<p>让App停止接收远程控制事件, 该方法属于UIApplication类<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)endReceivingRemoteControlEvents;</div></pre></td></tr></table></figure></p>
<p>在iOS7.1之前, 使用shared MPRemoteCommandCenter对象来注册远程控制事件. 当使用shared command center时, 不需要再调用该方法.<br>该方法会停止通过事件响应链来传递远程控制事件. 远程控制事件是当耳机和外部附件意图控制App的多媒体表现时发出的命令.</p>
<h4 id="远程控制事件的捕获处理"><a href="#远程控制事件的捕获处理" class="headerlink" title="远程控制事件的捕获处理"></a>远程控制事件的捕获处理</h4><p>当远程控制事件发生时触发该方法, 该方法属于UIResponder类<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</div></pre></td></tr></table></figure></p>
<p>远程控制事件是由外部附件(包括耳机)所发出的命令. 应用需要响应这些命令来控制音频或视频媒体的对用户的表示. 事件响应者通过检查事件的subtype, 来判断命令的意图. 比如UIEventSubtypeRemoteControlPlay为播放操作, 然后做相关处理要允许远程控制事件的传递, 需要调用UIApplication的beginReceivingRemoteControlEvents方法; 要关闭远程控制事件的传递则调用endReceivingRemoteControlEvents</p>
<h4 id="项目中的代码实现"><a href="#项目中的代码实现" class="headerlink" title="项目中的代码实现"></a>项目中的代码实现</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    <span class="comment">// 在App启动后开启远程控制事件, 接收来自锁屏界面和上拉菜单的控制</span></div><div class="line">    [application beginReceivingRemoteControlEvents];</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 在App要终止前结束接收远程控制事件, 也可以在需要终止时调用该方法终止</span></div><div class="line">    [application endReceivingRemoteControlEvents];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 在具体的控制器或其它类中捕获处理远程控制事件</span></div><div class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 根据事件的子类型(subtype) 来判断具体的事件类型, 并做出处理</span></div><div class="line">    <span class="keyword">switch</span> (event.subtype) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>: &#123;</div><div class="line">            <span class="comment">// 执行播放或暂停的相关操作 (锁屏界面和上拉快捷功能菜单处的播放按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>: &#123;</div><div class="line">            <span class="comment">// 执行上一曲的相关操作 (锁屏界面和上拉快捷功能菜单处的上一曲按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>: &#123;</div><div class="line">            <span class="comment">// 执行下一曲的相关操作 (锁屏界面和上拉快捷功能菜单处的下一曲按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlTogglePlayPause</span>: &#123;</div><div class="line">            <span class="comment">// 进行播放/暂停的相关操作 (耳机的播放/暂停按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="iOS7-1后-更新了远程控制事件的实现方式"><a href="#iOS7-1后-更新了远程控制事件的实现方式" class="headerlink" title="iOS7.1后, 更新了远程控制事件的实现方式"></a>iOS7.1后, 更新了远程控制事件的实现方式</h4><p>相关方法的描述中, 已经说明, iOS7.1之后使用MPRemoteCommandCenter类来进行远程控制事件的相关处理, 因此可以不再使用上面所描述的三个方法. 官方文档MPRemoteCommandCenter的描述如下:</p>
<ul>
<li>MPRemoteCommandCenter<br>MPRemoteCommandCenter类提供了处理远程控制事件的对象, 包括由外部附件和系统传输控制发送的远程控制事件. 不需要自己创建该类的实例. 而是使用shareCommandCenter方法获取默认的命令中心(share command center)对象. share command center对象的属性包含了MPRemoteCommand对象(表示iOS支持的每种远程控件事件). 如果要对响应的事件特殊处理, 使用适当的MPRemoteCommand对象注册一个handler即可.远程命令中心(remote command center)对象为许多不同类型的事件提供了命令(command)对象. 如果你的App不需要支持某些特定类型的事件, 可以通过设置其enabled属性为NO来禁用关联的MPRemoteCommand对象. 使用command对象注册一个handler, 以便让系统知道你的App已经做好了接收事件的准备. 只有当你的App是当前正在播放(Now Playing App)时才能接收到事件的传递.</li>
<li>项目中的代码实现<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在需要处理远程控制事件的具体控制器或其它类中实现</span></div><div class="line">- (<span class="keyword">void</span>)remoteControlEventHandler</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 直接使用sharedCommandCenter来获取MPRemoteCommandCenter的shared实例</span></div><div class="line">    <span class="built_in">MPRemoteCommandCenter</span> *commandCenter = [<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter];</div><div class="line"></div><div class="line">    <span class="comment">// 启用播放命令 (锁屏界面和上拉快捷功能菜单处的播放按钮触发的命令)</span></div><div class="line">    commandCenter.playCommand.enabled = <span class="literal">YES</span>;</div><div class="line">    <span class="comment">// 为播放命令添加响应事件, 在点击后触发</span></div><div class="line">    [commandCenter.playCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(playAction:)];</div><div class="line"></div><div class="line">    <span class="comment">// 播放, 暂停, 上下曲的命令默认都是启用状态, 即enabled默认为YES</span></div><div class="line">    <span class="comment">// 为暂停, 上一曲, 下一曲分别添加对应的响应事件</span></div><div class="line">    [commandCenter.pauseCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pauseAction:)];</div><div class="line">    [commandCenter.previousTrackCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(previousTrackAction:)];</div><div class="line">    [commandCenter.nextTrackCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(nextTrackAction:)];</div><div class="line"></div><div class="line">    <span class="comment">// 启用耳机的播放/暂停命令 (耳机上的播放按钮触发的命令)</span></div><div class="line">    commandCenter.togglePlayPauseCommand.enabled = <span class="literal">YES</span>;</div><div class="line">    <span class="comment">// 为耳机的按钮操作添加相关的响应事件</span></div><div class="line">    [commandCenter.togglePlayPauseCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(playOrPauseAction:)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="锁屏界面相关信息更新"><a href="#锁屏界面相关信息更新" class="headerlink" title="锁屏界面相关信息更新"></a>锁屏界面相关信息更新</h4><p>实现了远程控制事件后, App在进行音乐播放时, 上拉快捷功能菜单都会提供远程控件按钮, 锁屏界面会有改动, 出现远程控制按钮, 以及歌曲进度等信息, 接下来需要将歌曲的相关信息更新到锁屏界面上. 主要通过MPNowPlayingInfoCenter类来实现, 下面是官方文档的描述:</p>
<ul>
<li>MPNowPlayingInfoCenter<br>使用now playing info center来设置App当前正在播放的媒体文件的信息(now-playing information).系统会在设备的锁屏界面和上划的快捷控制面板的多媒体控制部分显示当前播放文件的信息. 如果用户直接通过AirPlay在Apple TV上播放媒体文件时, now-playing信息会显示在电视屏幕上. 如果用户将设备连接到iPad附件, 比如汽车(通过CarPlay连接)上, 附件上可能会显示now-playing的信息.你不能直接控制哪些信息要被显示出来, 以及这些信息显示的样式. 只需要设置now playing info center dictionary的相关value, 将这些相关信息提交给系统即可. 系统或已经连接的附件, 会用一致的方式为所有的App处理这些信息的展示.<h4 id="可以配置的锁屏界面信息"><a href="#可以配置的锁屏界面信息" class="headerlink" title="可以配置的锁屏界面信息"></a>可以配置的锁屏界面信息</h4>可以使用的information属性, 是定义在MPMediaItem类的General Media Item Property Keys属性中的子集(即其中的某些属性). 在iOS5.0后, now playing info center支持下列media item属性的Key: (仅列举了常用的Key!)</li>
<li>MPMediaItemPropertyAlbumTitle<br>专辑的标题, value是NSString对象</li>
<li>MPMediaItemPropertyArtist<br>media item的创作者, value是NSString对象</li>
<li>MPMediaItemPropertyArtwork<br>media item的插图. value是MPMediaItemArtwork类的对象</li>
<li>MPMediaItemPropertyPlaybackDuration<br>media item的播放总时长. value是表示包装了时长秒数(NSTimeInterval)的NSNumber类型</li>
<li>MPMediaItemPropertyTitle<br>media item的名字或标题. 该属性与MPMediaItemPropertyAlbumTitle属性无关, value是NSString对象<br>额外添加的一些可以使用的属性在MPNowPlayingInfoCenter类的描述文档中的Additional Metadata Properties中作了声明. (仅列举了常用的Key!)</li>
<li>MPNowPlayingInfoPropertyElapsedPlaybackTime<br>当前播放的item所消逝的时间(歌曲当前时间), 单位为秒. value是包装了double值的NSNumber对象. elapsed time是由系统根据之前提供elapsed tiime和playback rate进行自动进行计算的. 请不要频繁的更新该属性, 这是没有必要的.</li>
<li>MPNowPlayingInfoPropertyPlaybackRate<br>当前播放的item的播放速率, value为1.0表示正常的播放速率. value是包装了double值的NSNumber对象. 默认值是1.0. playback rate的值为2.0表示普通播放速率的2倍; 此时media从播放到结束只需要一半时间.<h4 id="项目中的代码实现-1"><a href="#项目中的代码实现-1" class="headerlink" title="项目中的代码实现"></a>项目中的代码实现</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updatelockScreenInfo </div><div class="line">&#123;</div><div class="line">    <span class="comment">// 直接使用defaultCenter来获取MPNowPlayingInfoCenter的默认唯一实例</span></div><div class="line">    <span class="built_in">MPNowPlayingInfoCenter</span> *infoCenter = [<span class="built_in">MPNowPlayingInfoCenter</span> defaultCenter];</div><div class="line">    <span class="comment">// MPMediaItemArtwork 用来表示锁屏界面图片的类型</span></div><div class="line">    <span class="built_in">MPMediaItemArtwork</span> *artwork = [[<span class="built_in">MPMediaItemArtwork</span> alloc]     initWithImage:image];</div><div class="line">    <span class="comment">// 通过配置nowPlayingInfo的值来更新锁屏界面的信息</span></div><div class="line">    infoCenter.nowPlayingInfo = @&#123;</div><div class="line">        <span class="comment">// 歌曲名</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyTitle</span> : music.name,</div><div class="line">        <span class="comment">// 艺术家名</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyArtist</span> : music.singer,</div><div class="line">        <span class="comment">// 专辑名字</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyAlbumTitle</span> : music.album,</div><div class="line">        <span class="comment">// 歌曲总时长 </span></div><div class="line">        <span class="built_in">MPMediaItemPropertyPlaybackDuration</span> : @(duration),</div><div class="line">        <span class="comment">// 歌曲的当前时间</span></div><div class="line">        <span class="built_in">MPNowPlayingInfoPropertyElapsedPlaybackTime</span> : @(currentTime),</div><div class="line">        <span class="comment">// 歌曲的插图, 类型是MPMeidaItemArtwork对象</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyArtwork</span> : artwork,</div><div class="line"></div><div class="line">        <span class="comment">// 无效的, 歌词的展示是通过图片绘制完成的, 即将歌词绘制到歌曲插图, 通过更新插图来实现歌词的更新的</span></div><div class="line">        <span class="comment">// MPMediaItemPropertyLyrics : lyric.content,</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="类似网易新闻的锁屏控制按钮实现"><a href="#类似网易新闻的锁屏控制按钮实现" class="headerlink" title="类似网易新闻的锁屏控制按钮实现"></a>类似网易新闻的锁屏控制按钮实现</h4><p>通过上述代码实现后, 锁屏界面已经可以展示出歌曲信息与控制按钮, 通过按钮或耳机的按键也可以实现相关的控制效果. 但网易的控制按钮中最左边并是上一曲, 而是列表按钮, 点击后还能在锁屏界面弹出一个ActionSheet界面. 该功能其实是通过修改MPRemoteCommandCenter的反馈功能(提供喜欢, 不喜欢, 标记(bookmark)操作)来实现的.涉及到的反馈功能, 先了解MPFeedbackCommond这个类, 以下是文档的描述</p>
<ul>
<li>MPFeedbackCommond<br>MPFeedbackCommand对象反映了当前App所播放的反馈状态. MPRemoteCommandCenter对象提供feedback对象用于对媒体文件进行喜欢, 不喜欢, 标记的操作. 使用这些对象为App支持的回馈(feedback)方式进行注册handler, 并在反馈状态修改时执行适当的任务(task). 在当前播放的item改变时, 也可以使用该对象为新的item设置反馈状态.当item的反馈状态改变时, 系统传递适当的事件到该对象注册的handler上. handler的代码必须决定哪一个media item来接收反馈, 然后再为该item执行更新反馈状态的操作. 你也可以执行与接收到反馈相关的其它任务. 比如, 当用户喜欢当前播放的歌曲时你可能要在UI上做出适当调整, 并使用该信息来进行相关歌曲的推荐.</li>
<li>MPRemoteCommandCenterr提供了相关属性(反馈按钮)<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">MPFeedbackCommand</span> *likeCommand;  <span class="comment">// 喜欢命令</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">MPFeedbackCommand</span> *dislikeCommand;  <span class="comment">// 不喜欢命令</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">MPFeedbackCommand</span> *bookmarkCommand; <span class="comment">// 标记(书签)命令</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>事实上, 系统的锁屏界面并不支持自定义. 这里边只需要添加反馈按钮, 则系统默认的锁屏界面就是网易云音乐所展示的样式. 包括点击后弹出的ActionSheet都是系统针对反馈按钮所提供了, 网易云音乐只是巧妙的将”不喜欢”按钮的标题修改成”上一曲”, 并在该按钮的响应事件里实现上一曲的代码, 即完成相关功能.</p>
<ul>
<li>项目中的代码实现<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加"喜欢"按钮, 需要启用, 并且设置了相关Action后才会生效</span></div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].likeCommand.enabled = <span class="literal">YES</span>;</div><div class="line">[[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].likeCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(likeItemAction)];</div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].likeCommand.localizedTitle = <span class="string">@"喜欢"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 添加"不喜欢"按钮</span></div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].dislikeCommand.enabled = <span class="literal">YES</span>;</div><div class="line"><span class="comment">// 自定义该按钮的响应事件, 实现在点击"不喜欢"时去执行上一首的功能</span></div><div class="line">[[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].dislikeCommand </div><div class="line">addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(previousCommandAction)];</div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span></div><div class="line"><span class="comment">// 自定义"不喜欢"的标题, 伪装成"上一首"</span></div><div class="line">sharedCommandCenter].dislikeCommand.localizedTitle = <span class="string">@"上一首"</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意: 反馈按钮默认不启用, 因此需要将enabled设置为YES, 同时必须添加对应的响应事件, 按钮才会在锁屏界面显示.</p>
</div><!--文章标签--><div class="tags"></div><!--评论--><div id="disqus_thread"><script>var disqus_shortname = 'zhuimar';
var disqus_identifier = '2017/12/20/2014/音乐锁屏键的处理/';
var disqus_title = '音乐锁屏键的处理';
var disqus_url = 'http://yoursite.com/2017/12/20/2014/音乐锁屏键的处理/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><!--script(id='dsq-count-scr', src='//#{theme.disqus}.disqus.com/count.js', async)--></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" id="search" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"> 分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">19</span></li></ul></div><div class="widget"><div class="widget-title"> 标签</div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"> 最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/2014/音乐锁屏键的处理/">音乐锁屏键的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/2014/MemoryManagement/">MemoryManagement</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/17/2014/网络库的详解/">网络库AFNetworking详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/30/2014/图片缓存的优化/">图片缓存的优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/13/2014/储存方案/">常见的储存方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/25/2014/精度/">高精度NSDecimalNumber</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/03/2014/NSString为什么用copy修饰/">copy修饰NSString的原因</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/06/01/2014/UIViewController的方法和属性/">UIViewController的生命周期和属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/05/21/2014/Enum/">常用的三种种枚举</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/05/20/2014/const-static-extern简介/">关键字const、static、extern</a></li></ul></div><div class="widget"><div class="widget-title"> 友情链接</div><ul class="links-list"><li class="links-list-item"><a href="http://blog.csdn.net/leixiaohua1020" title="雷霄骅" target="_blank">雷霄骅</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="http://blog.devtang.com/" title="唐巧" target="_blank">唐巧</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="http://casatwy.com" title="田伟宇" target="_blank">田伟宇</a></li></ul></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">zhuimar.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> Theme<a target="_blank" href="https://github.com/7ye/maupassant-hexo"> Maupassant.</a></div><a id="back_to_top" href="javascript:void(0)" class="back_to_top"><span>△</span></a><script type="text/javascript" src="/js/totop.js?v=0.0.1"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>function auto_code_fit(){
  if($(".highlight").length != 0){
    var pc_width = $(".post-content").width();
    $(".highlight .code").find("pre").width((pc_width-70)+"px");
  }
}
window.onresize = function(){
  auto_code_fit();
}
auto_code_fit();</script></div></body>