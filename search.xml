<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Ios编程所用到的词汇大全]]></title>
      <url>http://yoursite.com/2017/02/24/words/</url>
      <content type="html"><![CDATA[<p>A2A integration [,inti’ɡreiʃən]        A2A整合<br>abstract [‘æbstrækt, æb’strækt]  抽象的<br>abstract base [beis] class (ABC)抽象基类<br>abstract class 抽象类<br>abstraction [æb’strækʃən] 抽象、抽象物、抽象性<br>access [‘ækses, ‘æksəs, æk’ses]存取、访问<br>access level[‘levəl]访问级别<br>access function [‘fʌŋkʃən]访问函数<br>account [ə’kaunt]账户<br>action [‘ækʃən]动作<br>activate [‘æktiveit] 激活<br>active [‘æktiv]活动的<br>actual parameter [‘æktʃuəl] [pə’ræmitə] 实参<br>adapter [ə’dæptə]适配器<br>add-in 插件<br>address [ə’dres]地址<br>address space     地址空间<br>address-of operator [‘ɔpəreitə]取地址操作符<br>ADL (argument-dependent lookup) [‘ɑ:ɡjumənt] [di’pendənt]<br>ADO(ActiveX Data Object)ActiveX数据对象<br>advanced [əd’vænst]高级的<br>aggregation [,æɡri’ɡeiʃən] 聚合、聚集                         1<br>algorithm [‘ælgə’rɪðəm] 算法<br>alias [ˈeɪli:əs] 别名<br>align [ə’lain]排列、对齐<br>allocate [ˈæləkeit] 分配、配置<br>allocator[‘æləukeitə]分配器、配置器<br>angle bracket [‘æŋɡl] [‘brækit]尖括号<br>annotation [,ænəu’teiʃən]注解、评注<br>API (Application Programming Interface) 应用(程序)编程接口<br>app domain (application domain) [æp] [do’men]应用域<br>application [,æpli’keiʃən]应用、应用程序<br>application framework [‘freimwə:k] 应用程序框架<br>appearance [ə’piərəns]外观<br>append [ə’pend]附加<br>architecture [‘ɑ:kitektʃə]架构、体系结构<br>archive file [‘ɑ:kaiv] [‘fail] 归档文件、存档文件<br>argument[‘ɑ:ɡjumənt]引数(传给函式的值)。参见parameter [pə’ræmitə]<br>array [ə’rei]数组<br>arrow operator [‘ærəu] [‘ɔpəreitə]箭头操作符<br>ASP(Active Server [‘sɝvɚ] Page)活动服务器页面<br>ASP.NET worker process [‘prəuses, ‘prɔ-] ASP.NET工作者进程<br>assembly [ə’sembli] 装配件、配件<br>assembly language   汇编语言                                   2<br>assembly manifest [‘mænifest]装配件清单<br>assert(ion) [ə’sə:t] assertion [ə’sɝʃən] 断言<br>assign [ə’sain] 赋值<br>assignment [ə’sainmənt]赋值、分配<br>assignment operator 赋值操作符=<br>associated [ə’səuʃi,eitid] 相关的、相关联的<br>associative container [ə’səuʃjətiv] [kən’teinə]关联式容器(对应sequential container [si’kwenʃəl])<br>asynchronous [eɪˈsɪŋkrənəs] 异步的<br>atomic [ə’tɔmik]原子的<br>atomic operation   原子操作<br>attribute[ ‘ætribju:t]  特性、属性<br>authentication [ɔːˌθentɪˈkeɪʃn]service 验证服务<br>authorization [,ɔ:θərai’zeiʃən, -ri’z-]授权<br>audio [‘ɔ:diəu]  音频<br>A.I.    人工智能artificial intelligence [,ɑ:ti’fiʃəl] [in’telidʒəns]<br>B2B integration [,inti’ɡreiʃən] B2B整合、B2B集成(business-to-business integration)<br>background   背景、后台(进程)<br>backward compatible [kəm’pætəbl] 向后兼容、向下兼容<br>backup   备份<br>backup device[di’vais]备份设备                                       3<br>backup file 备份文件<br>bandwidth [‘bændwidθ] 带宽<br>base class 基类<br>base type 基类型<br>batch [bætʃ]批处理<br>BCL (base class library)基类库<br>binary [‘bainəri]二进制<br>binary search 二分查找<br>binary tree 二叉树<br>binary function 双参函数<br>binary large object二进制大对象<br>binary operator 二元操作符<br>binding [‘baindiŋ] 绑定<br>bit 位<br>bitmap [‘bit,mæp]位图<br>bitwise 按位…<br>bitwise copy       为单元进行复制；位元逐一复制,按位拷<br>bitwise operation 按位运算<br>block 块、区块、语句块<br>bookkeeping [‘buk,ki:piŋ]簿记<br>boolean [‘bu:liən]布林值(真假值，true或false)<br>border [‘bɔ:də]边框                                               4<br>bounds checking [baʊndz] [‘tʃekiŋ]边界检查<br>boxing 装箱、装箱转换<br>brace [breis]大括号 curly [‘kə:li] brace花括号<br>bracket [‘brækit] (square [skwεə] brakcet) 中括号、方括号<br>breakpoint [‘breikpɔint]断点<br>browser applications [‘brauzə] [æpli’keiʃəns]浏览器应用(程序)<br>browser-accessible [ək’sesəbl] application 可经由浏览器访问的应用程序<br>build 编连(专指编译和连接<br>built-in [,bɪlt ‘ɪn]内建、内置<br>bus 总线<br>business 业务、商务(看场合)<br>business Logic [‘lɔdʒik]业务逻辑<br>business rules 业务规则<br>buttons 按钮<br>bug 臭虫<br>by/through 通过<br>byte 位元组(由8 bits组成)<br>cache [kæʃ] 高速缓存<br>calendar [‘kælində]日历<br>call 调用<br>callback [‘kɔ:lbæk] 回调<br>call-level interface (CLI)调用级接口(CLI)                            5<br>call operator 调用操作符<br>candidate key [‘kændideit] 候选键 (for database)<br>cascading delete [kæ’skeidiŋ] 级联删除 (for database)<br>cascading update 级联更新 (for database)<br>casting [‘kɑ:stiŋ]  转型、造型转换<br>catalog [‘kætəlɔɡ]  目录<br>chain [tʃein] 链(function calls)<br>character [‘kærəktə] 字符<br>character format [ˈfɔ:mæt]  字符格式<br>character set     字符集<br>CHECK constraints [kən’streint]    CHECK约束 (for database)<br>checkpoint [‘tʃekpɔint] 检查点 (for database)<br>check box 复选框<br>check button 复选按钮<br>child class 子类<br>CIL (common intermediate [,intə’mi:djət, -dieit] language)通用中间语言、通用中介语言<br>class    类<br>class declaration [,deklə’reiʃən] 类声明<br>class definition [,defi’niʃən]  类定义<br>class derivation [,deri’veiʃən] list 类继承列表<br>class factory    类厂                                        6<br>class hierarchy [‘haiə,rɑ:ki]类层次结构<br>class library    类库<br>class loader     类装载器<br>class template [‘templit]类模板<br>class template partial [‘pɑ:ʃəl] specializations [,spɛʃəlɪ’zeʃən] 类模板部分特化<br>class template specializations         类模板特化<br>classification [ˌklæsifiˈkeiʃən] 分类<br>clause [klɔ:z]子句<br>client [‘klaiənt] application 客户端应用程序<br>client cursor [‘kə:sə] 客户端游标 (for database)<br>code page 代码页<br>cleanup   清理、清除<br>CLI (Common Language Infrastructure [‘infrə,strʌktʃə])   通用语言基础设施<br>client [‘klaiənt]客户、客户端<br>client area 客户区<br>client-server 客户机/服务器、客户端/服务器<br>clipboard [‘klipbɔ:d]剪贴板<br>clone [kləun]克隆<br>CLS (common language specification [,spesifi’keiʃən]) 通用语言规范<br>code access security 代码访问安全<br>COFF (Common Object File Format)    通用对象文件格式             7<br>collection [kə’lekʃən]集合<br>COM (Component [kəm’pəunənt] Object Model) 组件对象模型<br>combo [‘kɔmbəu] box 组合框<br>command [kə’mɑ:nd] line 命令行<br>comment[ˈkɔment] 注释<br>commit [kə’mit]提交 (for database)<br>communication [kə,mju:ni’keiʃən]通讯<br>compatible [kəm’pætəbl]兼容<br>compiler [kəm’pail]编译器<br>compile time 编译期、编译时<br>component[kəm’pəunənt]组件<br>composite [‘kɔmpəzit] index 复合索引、组合索引 (for database)<br>composite key 复合键、组合键 (for database)<br>composition [,kɔmpə’ziʃən]复合、组合<br>concept [‘kɔnsept]概念<br>concrete[kən’kri:t, ‘kɔnkri:t]具体的<br>concrete class 具体类<br>concurrency [kən’kʌrənsi]并发、并发机制<br>constraint [kən’streint]约束 (for database)<br>configuration [kən,fiɡju’reiʃən]配置、组态<br>connection [kə’nekʃən] 连接 (for database)<br>connection pooling 连接池                                        8<br>console [kən’səul] 控制台<br>constant [‘kɔnstənt]常量<br>construct [kən’strʌkt]构件、成分、概念、构造（for language）<br>constructor (ctor) [kɔn’strʌktə]构造函数、构造器<br>container [kən’teinə] 容器<br>containment[kən’teinmənt]包容<br>context [‘kɔntekst]环境、上下文<br>control [kən’trəul]控件<br>cookie [‘kuki] (不译)<br>copy    拷贝<br>CORBA   通用对象请求中介架构<br>(Common Object Request[ri’kwest] Broker Architecture)<br>cover   覆盖、涵盖<br>create/creation [kri:’eiʃən]创建、生成<br>crosstab query [‘kwiəri]交叉表查询 (for database)<br>CRTP<br>(curiously recurring [rɪ’kɝɪŋ] template [‘templit] pattern [‘pætən])<br>CTS (common type system)通用类型系统<br>cube [kju:b]多维数据集 (for database)<br>cursor [‘kə:sə] 光标<br>cursor 游标 (for database)<br>custom [‘kʌstəm] 定制、自定义                            9<br>data   数据<br>data connection   数据连接 (for database)<br>Data Control Language (DCL) 数据控制语言(DCL) (for database)<br>Data Definition [,defi’niʃən] Language (DDL) 数据定义语言(DDL) (for database)<br>data dictionary [‘dikʃənəri]数据字典 (for database)<br>data dictionary view 数据字典视图 (for database)<br>data file 数据文件 (for database)<br>data integrity [inˈteɡriti] 数据完整性 (for database)<br>data manipulation [mə,nipju’leiʃən] language (DML)数据操作语言(DML) (for database)<br>data mart 数据集市 (for database)<br>data pump [pʌmp]数据抽取 (for database)<br>data scrubbing [skrʌbliŋ]数据清理 (for database)<br>data source [sɔ:s]数据源 (for database)<br>Data source name (DSN) 数据源名称(DSN) (for database)<br>data warehouse [‘wεəhaus, ‘wεəhauz, -haus]数据仓库 (for database)<br>dataset   数据集 (for database)<br>database 数据库 (for database)<br>database catalog 数据库目录 (for database)<br>database diagram [‘daiəɡræm] 数据关系图 (for database)<br>database file     数据库文件 (for database)                        10<br>database object   数据库对象 (for database)<br>database owner    数据库所有者 (for database)<br>database project [‘prɔdʒekt]数据库工程 (for database)<br>database role     数据库角色 (for database)<br>database schema [‘ski:mə]数据库模式、数据库架构 (for database)<br>database script [skript]数据库脚本 (for database)<br>data-bound       数据绑定 (for database)<br>data-aware control数据感知控件 (for database)<br>data member   数据成员、成员变量<br>dataset       数据集 (for database)<br>data source   数据源 (for database)<br>data structure[‘strʌktʃə]数据结构<br>data table    数据表 (for database)<br>datagram [‘deitəɡræm]数据报文<br>DBMS (database management system)数据库管理系统 (for database)<br>DCOM (distributed [di’stribjutid] COM)分布式COM<br>dead lock 死锁 (for database)<br>Deallocate [de’elkeit]归还<br>debug      调试<br>debugger    调试器<br>decay [di’kei]退化<br>decision [di’siʒən] support [sə’pɔ:t] 决策支持                11<br>declaration [,deklə’reiʃən]声明<br>Declarative[dɪˈklærətɪv]referential [,refə’renʃəl] integrity [in’teɡrəti] (DRI)声明引用完整性(DRI) (for database)<br>deduction [di’dʌkʃən]推导<br>Deafault [di’fɔ:lt] constraint默认约束 (for database)<br>default database 默认数据库 (for database)<br>default instance [‘instəns]默认实例 (for database)<br>default result set 默认结果集 (for database)<br>default     缺省、默认值<br>defer       推迟<br>definition [,defi’niʃən]定义<br>delegate [‘deliɡeit]委托<br>delegation 委托<br>dependent name<br>deploy [di:’plɔi]部署<br>dereference [di’refərəns]解引用<br>dereference operator (提领)运算子<br>derived class 派生类<br>design by contract 契约式设计<br>design pattern [‘pætən]设计模式<br>destroy [di’strɔi]销毁<br>destructor(dtor) [di’strʌktə]析构函数、析构器                12<br>device [di’vais]设备<br>DHTML<br>(dynamic [dai’næmik]HyperText [‘haipətekst] Markup Language)动态超文本标记语言<br>dialog [‘daiəlɔɡ]对话框<br>digest[daiˈdʒest]摘要<br>digital 数字的<br>DIME<br>(Direct Internet Message Encapsulation [in,-kæpsə’leiʃən])<br>直接Internet消息封装<br>directive [di’rektiv, dai-] (编译)指示符<br>directory [di’rektəri, dai-]目录<br>dirty pages脏页 (for database)<br>dirty read 脏读 (for database)<br>disassembler [,disə’semblə]反汇编器<br>DISCO (Discovery of Web Services)Web Services的查找<br>disk 盘<br>dispatch [dis’pætʃ]调度、分派、派发（我喜欢“调度”）<br>DISPID (Dispatch[dis’pætʃ] Identifier [ai’dentifaiə])分派标识符<br>distributed [di’stribjutid] computing [kəm’pju:tiŋ]分布式计算<br>distributed query分布式查询 (for database)<br>DNA (Distributed interNet Application)                            13<br>分布式网间应用程序<br>document [‘dɔkjumənt, ‘dɔkjument]文档<br>DOM (Document Object Model)文档对象模型<br>dot operator [‘ɔpəreitə] (圆)点操作符<br>driver 驱动(程序)<br>DTD (document type definition [,defi’niʃən]) 文档类型定义<br>double-byte character set (DBCS)双字节字符集(DBCS)<br>dump [dʌmp] 转储<br>dump file 转储文件<br>dynamic [dai’næmik] cursor [‘kə:sə]动态游标 (for database)<br>dynamic filter [filtə]动态筛选 (for database)<br>dynamic locking   动态锁定 (for database)<br>dynamic recovery [ri’kʌvəri] 动态恢复 (for database)<br>dynamic snapshot [‘snæpʃɔt] 动态快照 (for database)<br>dynamic SQL statements [‘steitmənt]动态SQL语句 (for database)<br>dynamic assembly 动态装配件、动态配件<br>dynamic binding 动态绑定<br>EAI (enterprise[ˈentəpraɪz] application integration [,inti’ɡreiʃən])企业应用程序集成(整合)<br>EBCO (empty base class optimization [,ɔptimai’zeiʃən, -mi’z-])空基类优化（机制）<br>e-business   电子商务                                  14<br>EDI (Electronic [,ilek’trɔnik] Data Interchange [,intə’tʃeindʒ, ‘intətʃeindʒ])电子数据交换<br>efficiency [i’fiʃənsi]效率<br>efficient [i’fiʃənt]高效<br>end-to-end authentication [ɔː,θentɪ’keɪʃən] 端对端身份验证<br>end user 最终用户<br>engine   引擎<br>entity [‘entəti] 实体<br>encapsulation [in,-kæpsə’leiʃən]封装<br>enclosing [ɪn’kləʊziŋ] class 外围类别(与巢状类别 nested class有关)<br>enum (enumeration [i,nju:mə’reiʃən]) 枚举<br>enumerators [i’nju:mə,reitəz] 枚举成员、枚举器<br>equal [‘i:kwəl]相等<br>equality[i:’kwɔləti]相等性<br>equality operator 等号操作符<br>error[‘erə] log错误日志 (for database)<br>escape code 转义码<br>escape character 转义符、转义字符<br>exclusive [ik’sklu:siv] lock   排它锁 (for database)<br>explicit [ik’splisit] transaction [træn’zækʃən] 显式事务 (for database)<br>evaluate [i’væljueit]评估<br>event    事件                                          15<br>event driven 事件驱动的<br>event handler [‘hændlə]事件处理器<br>evidence [‘evidəns]证据<br>exception [ik’sepʃən] 异常<br>exception declaration [,deklə’reiʃən]异常声明<br>exception handling [‘hændliŋ]异常处理、异常处理机制<br>exception-safe 异常安全的<br>exception specification [,spesifi’keiʃən]异常规范<br>exit     退出<br>explicit [ik’splisit] 显式<br>explicit specialization [,speʃəlai’zeiʃən] 显式特化<br>export [ik’spɔ:t]导出<br>expression [ik’spreʃən]表达式<br>facility [fə’siliti] 设施、设备<br>fat client 胖客户端<br>feature [‘fi:tʃə]特性、特征<br>fetch [fetʃ]提取<br>field 字段(java)<br>field 字段 (for database)<br>field length 字段长度 (for database)<br>file   文件<br>filter [filtə]筛选 (for database)                                16<br>finalization [ˌfaɪnl’aɪzeʃən] 终结<br>firewall [‘faiəwɔ:l] 防火墙<br>finalizer [‘faɪnəlaɪzə] 终结器<br>firmware [‘fə:mwεə]固件<br>flag     标记<br>flash memory 闪存<br>flush [flʌʃ] 刷新<br>font 字体<br>foreign key (FK) 外键(FK) (for database)<br>form   窗体<br>formal parameter [pə’ræmitə] 形参<br>forward declaration 前置声明<br>forward-only 只向前的<br>forward-only cursor 只向前游标 (for database)<br>fragmentation [,fræɡmen’teiʃən] 碎片 (for database)<br>framework [‘freimwə:k] 框架<br>full specialization 完全特化<br>function 函数<br>function call operator (即operator ()) 函数调用操作符<br>function object 函数对象<br>function overloaded [‘əuvə’ləudid] resolution[,rezə’lu:ʃən]函数重载决议<br>functionality [,fʌŋkʃə’næliti]功能                                 17<br>function template函数模板<br>functor [‘fʌŋktə]仿函数<br>GAC (global assembly cache [kæʃ])<br>全局装配件缓存、全局配件缓存<br>GC (Garbage collection)<br>垃圾回收(机制)、垃圾收集(机制)<br>game游戏<br>generate [‘dʒenəreit]生成<br>generic [dʒi’nerik]泛化的、一般化的、通用的<br>generic algorithm[‘ælɡəriðəm]通用算法<br>genericity [‘dʒenerisity] 泛型<br>getter (相对于 setter)取值函数<br>global [‘ɡləubəl]全局的<br>global object 全局对象<br>global scope [skəup] resolution operator 全局范围解析操作符<br>grant [ɡrɑ:nt, ɡrænt]授权 (for database)<br>granularity[ˌɡrænjuˈlæriti] 粒度<br>group       组、群<br>group box   分组框<br>GUI   图形界面<br>GUID (Globally Unique [ju:’ni:k] Identifier [ai’dentifaiə]) 全球唯一标识符<br>hand shaking   握手                                       18<br>handle     句柄<br>handler    处理器<br>hard-coded 硬编码的<br>hard-copy 截屏图<br>hard disk 硬盘<br>hardware   硬件<br>hash table 散列表、哈希表<br>header file头文件<br>heap [hi:p]堆<br>help file 帮助文件<br>hierarchy [‘haiə,rɑ:ki]层次结构、继承体系<br>hierarchical [,haiə’rɑ:kikəl] data 阶层式数据、层次式数据<br>hook[huk]钩子<br>Host (application)宿主(应用程序)<br>hot key   热键<br>hyperlink [‘haipəliŋk]超链接<br>HTML (HyperText [‘haipətekst] Markup Language) 超文本标记语言<br>HTTP pipeline [‘paip,lain]    HTTP管道<br>HTTP (HyperText Transfer Protocol) 超文本传输协议<br>icon   图标<br>IDE (Integrated Development Environment)集成开发环境<br>IDL (Interface Definition Language)    接口定义语言               19<br>identifier [ai’dentifaiə]标识符<br>idle [‘aidl] time 空闲时间<br>if and only if当且仅当<br>IL (Intermediate Language) 中间语言、中介语言<br>image 图象<br>IME   输入法<br>immediate [i’mi:diət] base      直接基类<br>immediate derived [di’raivd]   直接派生类<br>immediate updating 即时更新 (for database)<br>implicit [im’plisit] transaction [træn’zækʃən]隐式事务 (for database)<br>incremental[ˌɪŋkrəˈmentl] update 增量更新 (for database)<br>index          索引 (for database)<br>implement [‘implimənt, ‘impliment]实现<br>implementation [,implimen’teiʃən] 实现、实现品<br>implicit [im’plisit]隐式<br>import         导入<br>increment [‘inkrimənt] operator 增加操作符<br>infinite [‘infinət] loop       无限循环<br>infinite recursive [ri’kə:siv] 无限递归<br>information      信息<br>infrastructure [‘infrə,strʌktʃə]基础设施<br>inheritance [in’heritəns]继承、继承机制                        20<br>inline [‘in,lain]内联<br>inline expansion 内联展开<br>initialization [i,niʃəlai’zeiʃən]初始化<br>initialization list 初始化列表、初始值列表<br>initialize [ɪ’nɪʃəlaɪz]初始化<br>inner [‘inə] join      内联接 (for database)<br>in-place active 现场激活<br>instance [‘instəns]实例<br>instantiated [ɪns’tænʃɪetid]    具现化、实体化(常应用于template)<br>instantiation[inˌstænʃiˈeiʃən]具现体、具现化实体(常应用于template)<br>integrate [ˈɪntɪgreɪt]       集成、整合<br>integrity [ɪnˈtegrəti]      完整性、一致性<br>integrity constraint完整性约束 (for database)<br>interprocess communication (IPC)进程间通讯(IPC)<br>interacts [,intə’rækts]交互<br>interface 接口<br>for GUI 界面<br>interoperability[ˈintərˌɔpərəˈbiləti]<br>互操作性、互操作能力<br>interpreter [in’tə:pritə]解释器<br>introspection [,intrəu’spekʃən]自省<br>invariants [in’vεəriənts]不变性                                  21<br>invoke [in’vəuk]调用<br>isolation [ˌaɪsəˈleɪʃn] level 隔离级别 (for database)<br>iterate [‘itəreit]迭代<br>iterative [‘itərətiv]反复的、迭代的<br>iterator [ɪtə’retɚ]迭代器<br>iteration [,itə’reiʃən] 迭代(回圈每次轮回称为一个iteration)<br>item      项、条款、项目<br>JIT compilation [ˌkɔmpəˈleɪʃən] JIT编译 即时编译<br>key          键 (for database)<br>key column   键列 (for database)<br>laser        激光<br>late binding 迟绑定<br>left outer join 左向外联接 (for database)<br>level      阶、层例<br>high level 高阶、高层<br>library    库<br>lifetime   生命期、寿命<br>link       连接、链接<br>linkage [‘liŋkidʒ]连接、链接<br>linker     连接器、链接器<br>literal [‘litərəl] constant 字面常数<br>list   列表、表、链表                                       22<br>list box 列表框<br>livelock 活锁 (for database)<br>load   装载、加载<br>load balancing [‘bælənsiŋ] 负载平衡<br>loader 装载器、载入器<br>local 局部的<br>local object    局部对象<br>lock 锁<br>log   日志<br>login 登录<br>login security mode登录安全模式 (for database)<br>lookup table   查找表 (for database)<br>loop [lu:p]循环<br>loose coupling [‘kʌpliŋ] 松散耦合<br>lvalue         左值<br>machine code   机器码、机器代码<br>macro [‘mækrəu]宏<br>maintain [mein’tein]维护<br>managed code 受控代码、托管代码<br>Managed Extensions [ik’stenʃəns] 受控扩充件、托管扩展<br>managed object 受控对象、托管对象<br>mangled [‘mæŋg(ə)l] name                                       23<br>manifest [‘mænifest]清单<br>manipulator [mə’nipjuleitə]操纵器(iostream预先定义的一种东西)<br>many-to-many relationship 多对多关系 (for database)<br>many-to-one relationship 多对一关系 (for database)<br>marshal [‘mɑ:ʃəl]列集<br>member   成员<br>member access operator    成员取用运算子(有dot和arrow两种)<br>member function           成员函数<br>member initialization list成员初始值列表<br>memberwise 以member为单元…、members 逐一…<br>memberwise copy<br>memory      内存<br>memory leak 内存泄漏<br>menu     菜单<br>message 消息<br>message based 基于消息的<br>message loop   消息环<br>message queuing[kjuiŋ]消息队列<br>metadata [‘metədeɪtə] 元数据<br>metaprogramming[mɛtə’prəuɡræmiŋ]元编程<br>method [‘meθəd]方法<br>micro 微                                                 24<br>middleware 中间件<br>middle tier中间层<br>modeling [‘mɔdəliŋ]建模<br>modeling language 建模语言<br>modifier [‘mɔdifaiə]修饰字、修饰符<br>modem[ˈməudem]调制解调器<br>module [‘mɔdju:l]模块<br>most derived [di’raivd] class最底层的派生类<br>mouse   鼠标<br>mutable [‘mju:təbl]可变的<br>mutex[‘mjutex]   互斥元、互斥体<br>multidimensional [ˌmʌltidiˈmenʃənl] OLAP (MOLAP)    多维OLAP(MOLAP) (for database)<br>multithreaded[ˌmʌltidiθ’redid] server application 多线程服务器应用程序<br>multiuser [,mʌlti’ju:zə]多用户<br>multi-tasking   多任务<br>multi-thread    多线程<br>multicast [‘mʌltikɑ:st] delegate [‘deliɡət] 组播委托、多点委托<br>named parameter    命名参数<br>named pipe 命名管道<br>namespace   名字空间、命名空间<br>native      原生的、本地的                           25<br>native code 本地码、本机码<br>Native Image Generator [‘dʒenəreitə] (NGEN)本地映像生成器<br>nested [‘nestid] class 嵌套类<br>nested query 嵌套查询 (for database)<br>nested table 嵌套表 (for database)<br>network       网络<br>network card 网卡<br>nondependent name<br>object        对象<br>object based 基于对象的<br>object file   目标文件<br>object model 对象模型<br>object oriented 面向对象的<br>object pooling 对象池化<br>ODBC data source         ODBC数据源 (for database)<br>ODBC driver      ODBC驱动程序 (for database)<br>ODR (one-definition rule)<br>OLE Automation [,ɔ:tə’meiʃən] objects<br>OLE自动化对象 (for database)<br>OLE Automation [ˌɔ:təˈmeiʃən] server<br>OLE(Object Linking and Embedding [im’bediŋ])<br>自动化服务器 (for database)                                 26<br>OLE DB consumer [kən’sju:mə]<br>OLE DB使用者 (for database)<br>OLE DB for OLAP 用于OLAP的OLE DB (for database)<br>OLE DB provider OLE         DB提供者 (for database)<br>one-to-many relationship 一对多关系 (for database)<br>one-to-one relationship 一对一关系 (for database)<br>online analytical [ˌænəˈlɪtɪkl] processing (OLAP)    联机分析处理(OLAP) (for database)<br>online redo[ri:ˈdu:] log     联机重做日志 (for database)<br>online transaction processing (OLTP)   联机事务处理(OLTP) (for database)<br>Open Data Services (ODS)   开放式数据服务(ODS) (for database)<br>Open Database Connectivity [,kɔnek’tivəti] (ODBC) 开放式数据库连接(ODBC) (for database)<br>operand [‘ɔpərænd] 操作数<br>operating system (OS) 操作系统<br>operation 操作<br>operator   操作符、运算符<br>option [‘ɔpʃən]选项<br>optimizer [‘ɔptimaizə]优化器<br>outer join 外联接 (for database)<br>overflow [,əuvə’fləu]上限溢位(相对于underflow)<br>overhead   额外开销                                         27<br>overload   重载<br>overload resolution   重载决议<br>overloaded function   重载的函数<br>overloaded operator 被重载的操作符<br>override [,əuvə’raid]覆写、重载、重新定义<br>package [‘pækidʒ]包<br>packaging 打包<br>palette [‘pælit]调色板<br>parallel [‘pærəlel]并行<br>parameter [pə’ræmitə]参数、形式参数、形参<br>parameter list 参数列表<br>parameterize [pə’ræmitəraiz]参数化<br>parent class   父类<br>parentheses[pəˈrenθɪsɪsiz]    圆括弧、圆括号<br>parse [pɑ:z]解析<br>parser [‘pɑ:sə]解析器<br>part     零件、部件<br>partial specialization 局部特化<br>pass by address   传址(函式引数的传递方式)(非正式用语)<br>pass by reference 传地址、按引用传递<br>pass by value 按值传递<br>pattern [‘pætən] 模式                                          28<br>PDA (personal digital [‘didʒitəl] assistant)个人数字助理<br>PE (Portable Executable[ˈeksikju:təbl]) file   可移植可执行文件<br>performance [pə’fɔ:məns]性能<br>persistence [pə’sistəns]持久性<br>PInvoke (platform invoke service) 平台调用服务<br>pixel [‘piksəl]像素<br>placement [‘pleismənt] delete<br>placement new<br>placeholder [‘pleis,həuldə]占位符<br>platform [‘plætfɔ:m]平台<br>POD (plain old data (type)) 简单旧数据类型<br>POI (point of instantiation [in,stænʃieiʃən])<br>pointer 指针<br>poll [pəul]轮询<br>pooling 池化<br>polymorphism [,pɒlɪ’mɔːfɪz(ə)m]多态<br>pop up     弹出式<br>port [pɔ:t, pəut]端口<br>postfix [‘pəustfiks]后缀<br>precedence [‘presidəns, pri’si:-]优先序(通常用于运算子的优先执行次序)<br>prefix [,pri:’fiks, ‘pri:fiks]前缀<br>preprocessor [,priː’prəʊsesə]预处理器                           29<br>primary key (PK)主键(PK) (for database)<br>primary table   主表 (for database)<br>primary template原始模板<br>primitive [‘primitiv] type 原始类型<br>print      打印<br>printer    打印机<br>procedure [prə’si:dʒə]过程<br>procedural [prə’si:dʒərəl] 过程式的、过程化的<br>process    进程<br>profile [‘prəufail]评测<br>profiler [‘prəufailə]效能(性能)评测器<br>program    程序<br>programmer 程序员<br>programming编程、程序设计<br>progress bar 进度指示器<br>project    项目、工程<br>property   属性<br>protocol [‘prəutəkɔl]协议<br>pseudo [‘psju:dəu] code伪码<br>qualified [‘kwɔlifaid] 经过资格修饰(例如加上scope运算子)<br>qualified name<br>qualifier [‘kwɔlifaiə]修饰符                                      30<br>quality   质量<br>queue [kju:]队列<br>race condition 竞争条件（多线程环境常用语）<br>radian [‘reidiən]弧度<br>radio button   单选按钮<br>raise [reiz]引发(常用来表示发出一个exception)<br>random number 随机数<br>range   范围、区间<br>rank    等级<br>raw [rɔ:]未经处理的<br>readOnly只读<br>record 记录 (for database)<br>recordset [‘rekɔdset] 记录集 (for database)<br>recursive [ri’kə:siv]递归<br>re-direction 重定向<br>refactoring [ri’fæktəriŋ]   重构<br>refer     引用、参考<br>reference 引用、参考<br>reference counting引用计数<br>referential [,refə’renʃəl] integrity [in’teɡrəti] (RI)引用完整性(RI) (for database)<br>register [‘redʒistə]寄存器<br>reflection   反射                                       31<br>refresh data 刷新数据 (for database)<br>regular expression 正则表达式<br>relational database 关系数据库<br>remote         远程<br>remote request 远程请求<br>represent      表述，表现<br>resolve        解析、决议<br>resolution [,rezə’lu:ʃən]解析过程<br>result set     结果集 (for database)<br>retrieve [ri’tri:v] data 检索数据<br>return         返回<br>return type    返回类型<br>return value   返回值<br>right outer join 右向外联接 (for database)<br>revoke [ri’vəuk]撤销<br>robust [rəu’bʌst]健壮<br>robustness [rəʊ’bʌstnɪs]健壮性<br>roll back    回滚 (for database)<br>roll forward 前滚 (for database)<br>routine [ru:’ti:n]例程<br>row          行 (for database)<br>row lock     行锁 (for database)                                32<br>rowset       行集 (for database)<br>RPC (remote [ri’məut] procedure call)RPC(远程过程调用)<br>runtime 执行期、运行期、执行时、运行时<br>rvalue 右值<br>save    保存<br>savepoint 保存点 (for database)<br>SAX (Simple API for XML)<br>scalable [‘skeiləbl]可伸缩的、可扩展的<br>schedule [‘ʃədju:əl] 调度<br>scheduler [‘ʃedju:ələ] 调度程序<br>schema [‘ski:mə]模式、纲目结构<br>scroll bar滚动条<br>scope [skəup]作用域、生存空间<br>scope operator 生存空间操作符<br>scope resolution [,rezə’lu:ʃən] operator 生存空间解析操作符<br>screen   屏幕<br>SDK (Software Development Kit)软件开发包<br>sealed [si:ld] class 密封类<br>search [sə:tʃ]查找<br>semantics [si’mæntiks]语义<br>semaphore [ˈseməˌfɔ:,信号量<br>sequential [si’kwenʃəl]  container序列式容器                  33<br>server    服务器、服务端<br>serial [‘siəriəl]串行<br>serialization [,siəriəlai’zeiʃən ]/serialize 序列化<br>server cursor服务端游标、服务器游标 (for database)<br>session      会话 (for database)<br>setter [‘setə]设值函数<br>shared lock 共享锁 (for database)<br>sibling [‘sibliŋ]同级<br>side effect 副作用<br>signature [‘signətʃə]签名<br>single-threaded 单线程<br>slider[‘slaidə]滑块<br>slot [slɔt] 槽<br>smart pointer [‘pɔintə] 智能指针<br>SMTP (Simple Mail Transfer Protocol)   简单邮件传输协议<br>snapshot [‘snæpʃɔt]截屏图<br>snapshot       快照 (for database)<br>specialization [,speʃəlai’zeiʃən] 特化<br>specification [,spesifi’keiʃən]规范、规格<br>splitter       切分窗口<br>SOAP (simple object access protocol [‘prəutəkɔl])   简单对象访问协议<br>software      软件                                         34<br>source code   源码、源代码<br>SQL (Structured [‘strʌktʃəd] Query Language) 结构化查询语言 (for database)<br>stack [stæk]栈、堆栈<br>stack unwinding [ʌn’waindiʃ]叠辗转开解(此词用于exception主题)<br>standard library 标准库<br>standard template library 标准模板库<br>stateless [‘steɪtlɪs]无状态的<br>statement [‘steitmənt]语句、声明<br>static cursor 静态游标 (for database)<br>static SQL statements 静态SQL语句 (for database)<br>stored [stɔ:d]  procedure 存储过程 (for database)<br>status [‘steitəs]  bar 状态条<br>stream [stri:m]流<br>string   字符串<br>stub     存根<br>subobject[‘sʌb’ɔbdʒikt]子对象<br>subquery 子查询 (for database)<br>subroutine [‘sʌbruːtiːn]子例程<br>subscript operator 下标操作符<br>subset   子集<br>subtype 子类型<br>support 支持                                               35<br>suspend [sə’spend]挂起<br>symbol   记号<br>syntax [‘sintæks]语法<br>system databases   系统数据库 (for database)<br>system tables      系统表 (for database)<br>table       表 (for database)<br>table lock 表锁 (for database)<br>table-level constraint 表级约束 (for database)<br>tape backup 磁带备份 (for database)<br>target 标的,目标<br>task switch 工作切换<br>TCP (Transport Control Protocol [‘prəutəkɔl])传输控制协议<br>template [‘templit]模板<br>template-id<br>template argument deduction [di’dʌkʃən]模板参数推导<br>template explicit [ik’splisit] specialization 模板显式特化<br>template parameter   模板参数<br>template template parameter<br>temporary [‘tempərəri] object 临时对象<br>temporary table 临时表 (for database)<br>text 文本<br>text file   文本文件                                        36<br>thin client 瘦客户端<br>third-party 第三方<br>thread      线程<br>thread-safe 线程安全的<br>throw 抛出、引发(常指发出一个exception)<br>token 符号、标记、令牌（看场合）<br>trace 跟踪<br>transaction [træn’zækʃən] 事务 (for database)<br>transaction log 事务日志 (for database)<br>transaction rollback [‘rəulbæk]事务回滚 (for database)<br>transactional replication [,repli’keiʃən]事务复制 (for database)<br>translation unit 翻译单元<br>traverse [‘trævəs, -və:s, trə’və:s, træ-]遍历<br>trigger [‘triɡə]触发器 (for database)<br>two-phase [feiz] commit 两阶段提交 (for database)<br>tuple [‘tʌpl] n. 元组，重数<br>two-phase [feiz] lookup 两阶段查找<br>type 类型<br>UDDI(Universary [feiz] Description, Discovery and Integration [,inti’ɡreiʃən])统一描述、查询与集成<br>UML (unified [‘ju:nifaid] modeling language)统一建模语言<br>unary [‘ju:nəri] function 单参函数                                  37<br>unary operator 一元操作符<br>unboxing [,ʌn’bɔks ɪŋ]箱、拆箱转换<br>underflow      下限溢位(相对于overflow)<br>Union [‘ju:niən] query    联合查询 (for database)<br>UNIQUE [ju:’ni:k] constraints UNIQUE约束 (for database)<br>unique index   唯一索引 (for database)<br>unmanaged code 非受控代码、非托管代码<br>unmarshal[[ʌn ‘mɑrʃəl]]      散集<br>unqualified [,ʌn’kwɔlifaid]未经限定的、未经修饰的<br>URI (Uniform Resource identifier [ai’dentifaiə]) 统一资源标识符<br>URL (Uniform Resource Locator)    统一资源定位器<br>user            用户<br>user interface 用户界面<br>value types 值类型<br>variable [‘vεəriəbl]变量<br>vector [‘vektə]向量(一种容器，有点类似array)<br>viable [‘vaiəbl]可行的<br>video    视频<br>view     视图<br>VEE (Virtual Execution Engine)虚拟执行引擎<br>vendor [‘vendɔ:]厂商<br>view    视图 (for database)                                    38<br>virtual function 虚函数<br>virtual machine   虚拟机<br>virtual memory    虚拟内存<br>vowel [‘vauəl] 元音字母<br>Web Services   web服务<br>WHERE clause   WHERE子句 (for database)<br>wildcard [‘waildka:d]  characters 通配符字符 (for database)<br>wildcard search     通配符搜索 (for database)<br>window              窗口<br>window function     窗口函数<br>window procedure    窗口过程<br>Windows authentication [ɔː,θentɪ’keɪʃən] Windows身份验证<br>wizard [‘wizəd]向导<br>word    单词<br>word processor 字处理器<br>wrapper [‘ræpə]包装、包装器<br>write enable[iˈneibl] 写启用 (for database)<br>write-ahead log 预写日志 (for database)<br>write-only只写<br>WSDL (Web Service Description Language)Web Service描述语言<br>XML(eXtensible [ik’stensəbl] Message Interface (XMI)<br>XML消息接口-                                               39<br>XML (extensible Markup Language) 可扩展标记语言<br>XSD (XML Schema [‘ski:mə] Definition) XML模式定义语言<br>XSL (extensible Stylesheet Language) 可扩展样式表语言<br>XSLT (extensible Stylesheet Language Transformation)可扩展样式表语言转换<br>xxx based     基于xxx的<br>xxx oriented 面向xxx<br>网址：(<a href="http://www.ryedu.net/syy/hyyy/200912/15824_2.html" target="_blank" rel="external">http://www.ryedu.net/syy/hyyy/200912/15824_2.html</a>)</p>
<p>application [ˌæplɪ’keɪʃ(ə)n]应用程式 应用、应用程序<br>application framework[‘freɪmwɜːk] 应用程式框架、应用框架 应用程序框架<br>architecture[‘ɑːkɪtektʃə] 架构、系统架构 体系结构<br>argument [‘ɑːgjʊm(ə)nt]引数（传给函式的值）<br>parameter 叁数、实质叁数、实叁、自变量<br>array [ə’reɪ] 阵列 数组<br>arrow [‘ærəʊ] 箭头<br>operator [‘ɔpəreitə] arrow运算子 箭头操作符<br>assembly [ə’semblɪ]装配件<br>assembly language [‘læŋgwɪdʒ]组合语言 汇编语言<br>assert(ion) [ə’sɜːt] [ə’sɜːʃ(ə)n]断言<br>assign [ə’saɪn]指派、指定、设值、赋值 赋值<br>assignment [ə’saɪnm(ə)nt]指派、指定 赋值、分配<br>assignment operator [‘ɒpəreɪtə]指派（赋值）运算子 = 赋值操作符<br>associated [ə’soʃɪetɪd]相应的、相关的 相关的、关联、相应的<br>associative [ə’səʊʃɪətɪv] container [kən’teɪnə]关联式容器<br>sequential container 关联式容器<br>atomic [ə’tɔmik]不可分割的 原子的<br>attribute [ə’trɪbjuːt] 属性、特性<br>audio [‘ɔːdɪəʊ]音讯 音频<br>A.I. 人工智慧 人工智能（artificial [ɑ:ti’fiʃəl] intelligence [ɪn’telɪdʒ(ə)ns]）<br>background [‘bækgraʊnd]背景 背景（用於图形着色）<br>backward [‘bækwəd] compatible [kəm’pætɪb(ə)l]回溯相容 向下兼容<br>bandwidth [‘bændwidθ]频宽 带宽<br>base [beis] class [klɑːs]基础类别 基类<br>base type [taip]基础型别 (等同於 base class)<br>batch [bætʃ]批次（意思是整批作业） 批处理<br>benefit [‘benɪfɪt]利益 收益<br>best [best] viable [‘vaiəbl] function [‘fʌŋ(k)ʃ(ə)n]最佳可行函式<br>binary [‘baɪnərɪ] search [sɜːtʃ]二分搜寻法 二分查找<br>binary tree [triː]二元树 二叉树<br>binary function 二元函式 双叁函数<br>binary operator [‘ɒpəreɪtə]二元操作符<br>binding [‘baɪndɪŋ]系结 绑定<br>bit <a href="发音为beit">bɪt</a>位元 位<br>bit field [fiːld]位元栏 位域<br>bitmap [‘bɪtmæp]位元图 位图<br>bitwise 以 bit 为单元逐一┅<br>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝<br>block [英][blɔk]&nbsp;[美][blɑk]&nbsp;区块,区段 块、区块、语句块<br>boolean [‘bu:li:ən]布林值（真假值，true 或 false） 布尔值<br>border [‘bɔ:də]边框、框线 边框<br>curly [‘kə:li] brace [breis]大括弧、大括号 花括弧、花括号<br>square [skwεə] bracket [‘brækit]中括弧、中括号 方括弧、方括号<br>breakpoint [‘breikpɔint]中断点 断点<br>build [bild]建造、构筑、建置（MS 用语）<br>build－in 内建 内置<br>bus 汇流排 总线<br>business [‘bɪznɪs]商务,业务 业务<br>buttons [bʌtəns]按钮 按钮<br>byte [bait] 字节   位元组（由 8 bits 组成）<br>cache [kæʃ] 快取 高速缓存<br>call [kɔ:l] 调用 呼叫、叫用<br>callback [‘kɔ:lbæk] 回调 回呼<br>operator [‘ɔpəreitə] call（函式呼叫）运算子调用操作符 （同 function call operator）<br>candidate [‘kændidit] function 候选函式 候选函数 （在函式多载决议程序中出现的候选函式）<br>chain [tʃein]串链（例 chain of function calls）链<br>character [‘kærəktə] 字符 字元<br>check [tʃek] box复选框 核取方块 (i.e. check button)<br>checked [tʃekt] exception [ik’sepʃən]可控式异常 (Java)<br>check button [‘bʌtən] 复选按钮 方钮 (i.e. check box)<br>child [tʃaild] class 子类别（或称为derived [di’raivd] class, subtype [‘sʌbtaip] 图表类型） 子类<br>class [klɑ:s]类别 类<br>class body 类别本体 类体<br>class declaration [,deklə’reiʃən] 类声明 类别宣告、类别宣告式<br>class definition [,defi’niʃən] 类定义 类别定义、类别定义式<br>class derivation [,deri’veiʃən] list类继承列表 类别衍化列<br>class head [hed] 类头 类别表头<br>class hierarchy [‘haiərɑ:ki]类别继承体系, 类别阶层 类层次体系<br>class library [‘laibrəri] 类库 类别程式库、类别库<br>class template [‘templit]类别模板、类别范本 类模板<br>class template partial [‘pɑ:ʃəl] specializations [‘speʃəlaiz]类别模板偏特化 类模板部分特化<br>class template specializations 类别模板特化 类模板特化<br>cleanup [‘kli:nʌp]清理、善後 清理、清除<br>client [‘klaiənt] 客户端、客端、客户 客户<br>client－server [‘sə:və]主从架构 客户/服务器<br>clipboard [‘klipbɔ:d] 剪贴板 剪贴簿<br>clone [kləun]复制 克隆<br>collection [kə’lekʃən] 集合 群集<br>combo [‘kɔmbəu] box [bɔks]复合方块 复合框 组合框<br>command [kə’mɑ:nd] line [lain] 命令行 命令列 (系统文字模式下的整行执行命令)<br>communication [kə,mju:ni’keiʃən]通讯<br>compatible [kəm’pætəbl] 兼容 相容<br>compile [kəm’pail]time 编译期 编译期、编译时<br>compiler [kəm’pailə]编译器 编译器<br>component [kəm’pəunənt]组件 组件<br>composition[,kɔmpə’ziʃən]  复合、合成、组合 组合<br>computer [kəm’pju:tə]电脑、计算机 计算机、电脑<br>concept [‘kɔnsept]概念 概念<br>concrete [kən’kri:t]具象的 实在的<br>concurrent [kən’kʌrənt]并行 并发<br>configuration [kən,fiɡju’reiʃən] 配置 组态<br>connection [kə’nekʃən]连接，连线（网络,资料库） 连接<br>constraint[kən’streint]  约束（条件）<br>construct [kən’strʌkt]构件 构件<br>container [kən’teinə]容器 容器 （存放资料的某种结构如 list, vector…）<br>containment [kən’teinmənt]内含 包容<br>context[‘kɔntekst] 背景关系、周遭环境、上下脉络 环境、上下文<br>control [kən’trəul]控制元件、控件 控件<br>console [kən’səul]主控台 控制台<br>const [‘kɔnstənt]常数（constant 的缩写，C++ 关键字）<br>constant[‘kɔnstənt]  常数（相对於 variable） 常量<br>constructor[kɔn’strʌktə]（ctor） 建构式 构造函数 （与class 同名的一种 member functions）<br>copy[‘kɔpi] (v) 复制、拷贝 拷贝<br>copy (n) 复件, 副本<br>cover [‘kʌvə] 涵盖 覆盖<br>create [kri’eit]创建、建立、产生、生成 创建<br>creation [kri:’eiʃən]产生、生成 创建<br>cursor [‘kə:sə]游标 光标<br>custom [‘kʌstəm] 订制、自定 定制<br>data [‘deitə]资料 数据<br>database [‘deitəbeis]资料库 数据库<br>database schema [‘ski:mə] 数据库结构纲目<br>data member [‘membə] 资料成员、成员变数 数据成员、成员变量<br>data structure [‘strʌktʃə]资料结构 数据结构<br>datagram [‘deitəɡræm]资料元 数据报文<br>dead [ded] lock [lɔk]死结 死锁<br>debug [di:’bʌɡ]除错 调试<br>debugger [di:’bʌɡə]除错器 调试器<br>declaration [,deklə’reiʃən]宣告、宣告式 声明<br>deduction [di’dʌkʃən]推导（例：template argument deduction） 推导、推断<br>default [di’fɔ:lt]预设 缺省、默认<br>defer [di’fə:] 延缓 推迟<br>define [di’fain]定义 预定义<br>definition [,defi’niʃən]定义、定义区、定义式 定义<br>delegate [‘deliɡeit]委派、委托、委任 委托<br>delegation [,deli’ɡeiʃən] （同上）<br>demarshal 反编列 散集<br>dereference [di’refərəns]提领（取出指标所指物体的内容） 解叁考<br>operator dereference（提领）运算子 * 解叁考操作符<br>derived [di’raivd] class 衍生类别 派生类<br>design [di’zain] by contract [kən’trækt]契约式设计<br>design [di’zain] pattern [‘pætən] 设计范式、设计样式 设计模式<br>※ 最近我比较喜欢「设计范式」一词<br>destroy [di’strɔi] 摧毁、销毁<br>destructor [di’strʌktə] 解构式 析构函数<br>device [di’vais] 装置、设备 设备<br>dialog [‘daiəlɔɡ]对话窗、对话盒 对话框<br>directive [di’rektiv] 指令（例：using directive） (编译)指示符<br>directory [di’rektəri] 目录 目录<br>disk [disk] 碟 盘<br>dispatch [dis’pætʃ] 分派 分派<br>distributed [di’stribjutid] computing [kəm’pju:tiŋ] 分布式计算 (分布式电算) 分布式计算<br>分散式计算 (分散式电算)<br>document [‘dɔkjumənt]文件 文档<br>dot [dɔt] operator [‘ɔpəreitə] dot（句点）运算子 . (圆)点操作符<br>driver [draivə]驱动程式 驱动（程序）<br>dynamic [dai’næmik] binding [‘baindiŋ] 动态系结 动态绑定<br>efficiency [i’fiʃənsi] 效率 效率<br>efficient [i’fiʃənt]高效 高效<br>end [end] user [‘ju:zə]终端用户<br>entity [‘entəti] 物体 实体、物体<br>encapsulation [in,-kæpsə’leiʃən] 封装 封装<br>enclosing [in’kləuz] class 外围类别（与巢状类别 nested <a href="嵌套的">‘nestid</a> class 有关）外围类<br>enum (enumeration [i,nju:mə’reiʃən]) 枚举 列举（一种 C++ 资料型别）枚举<br>enumerators [i’nju:məreitə]列举元（enum 型别中的成员） 枚举成员、枚举器<br>equal [‘i:kwəl] 相等 相等<br>equality [i:’kwɔləti]相等性 相等性<br>operator [‘ɔpəreitə] equality（等号）运算子 == 等号操作符<br>equivalence [i’kwivələns] 等价性、等同性、对等性 等价性<br>equivalent [i’kwivələnt]等价、等同、对等 等价<br>escape [i’skeip] code 转义码 转义码<br>evaluate [i’væljueit] 评估、求值、核定 评估 </p>
<p>application 应用程式 应用、应用程序﻿<br>application framework 应用程式框架、应用框架 应用程序框架﻿<br>architecture 架构、系统架构 体系结构﻿<br>argument 参数（传给函式的值）。﻿<br>array 阵列 数组﻿<br>arrow operator arrow（箭头）运算子 箭头操作符﻿<br>assembly 装配件﻿<br>assembly language 组合语言 汇编语言﻿<br>assert(ion) 断言﻿<br>assign 指派、指定、设值、赋值 赋值﻿<br>assignment 指派、指定 赋值、分配﻿<br>assignment operator 指派（赋值）运算子 = 赋值操作符﻿<br>associated 相应的、相关的 相关的、关联、相应的﻿<br>associative container 关联式容器（对应 sequential container）关联式容器﻿<br>atomic不可分割的 原子的﻿<br>attribute 属性 属性、特性﻿<br>audio 音讯 音频﻿<br>A.I. 人工智慧 人工智能﻿<br>background 背景 背景（用於图形着色）後台（用於行程）﻿<br>backward compatible 回溯相容 向下兼容﻿<br>bandwidth 频宽 带宽﻿<br>base class 基础类别 基类﻿<br>base type 基础型别 (等同於﻿<br>base class) batch 批次（意思是整批作业） 批处理﻿<br>benefit 利益 收益﻿<br>best viable function 最佳可行函式 最佳可行函式﻿<br>binary search 二分搜寻法 二分查找﻿<br>binary tree 二元树 二叉树﻿<br>binary function 二元函式 双叁函数﻿<br>binary operator 二元运算子 二元操作符﻿<br>binding 系结 绑定﻿<br>bit 位元 位﻿<br>bit field 位元栏 位域﻿<br>bitmap 位元图 位图﻿<br>bitwise 以 bit 为单元逐一﻿<br>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝﻿<br>block 区块,区段 块、区块、语句块﻿<br>boolean 布林值（真假值，true 或 false）布尔值<br>border 边框、框线 边框﻿<br>brace(curly brace) 大括弧、大括号 花括弧、花括号﻿<br>bracket(square bracket) 中括弧、中括号 方括弧、方括号﻿<br>breakpoint 中断点 断点﻿<br>build 建造、构筑、建置（MS 用语）﻿<br>build－in 内建 内置﻿<br>bus 汇流排 总线﻿<br>business 商务,业务 业务﻿<br>buttons 按钮 按钮﻿<br>byte 位元组（由 8 bits 组成） 字节﻿<br>cache 快取 高速缓存﻿<br>call 呼叫、叫用 调用﻿<br>callback 回呼 回调﻿<br>call operator call（函式呼叫）运算子调用操作符﻿<br>candidate function 候选函式 候选函数﻿<br>chain 串链（例 chain of function calls） 链﻿<br>character 字元 字符﻿<br>check box 核取方块 (i.e. check button) 复选框﻿<br>checked exception 可控式异常﻿<br>check button 方钮 (i.e. check box) 复选按钮﻿<br>child class 子类别（或称为derived class, subtype） 子类﻿<br>class 类别 类﻿<br>class body 类别本体 类体﻿<br>class declaration 类别宣告、类别宣告式 类声明﻿<br>class definition 类别定义、类别定义式 类定义﻿<br>class derivation list 类别衍化列 类继承列表﻿<br>class head 类别表头 类头﻿<br>class hierarchy 类别继承体系, 类别阶层 类层次体系﻿<br>class library 类别程式库、类别库 类库﻿<br>class template 类别模板、类别范本 类模板﻿<br>class template partial specializations 类别模板偏特化 类模板部分特化﻿<br>class template specializations 类别模板特化 类模板特化﻿<br>cleanup 清理、善後 清理、清除﻿<br>client 客端、客户端、客户 客户﻿<br>client－server 主从架构 客户/服务器﻿<br>clipboard 剪贴簿 剪贴板﻿<br>clone 复制 克隆﻿<br>collection 群集 集合﻿<br>combo box 复合方块、复合框 组合框﻿<br>command line 命令列 命令行(系统文字模式下的整行执行命令)﻿<br>communication 通讯 通讯﻿<br>compatible 相容 兼容﻿<br>compile time 编译期 编译期、编译时﻿<br>compiler 编译器 编译器﻿<br>component 组件 组件﻿<br>composition 复合、合成、组合 组合﻿<br>computer 电脑、计算机 计算机、电脑﻿<br>concept 概念 概念﻿<br>concrete 具象的 实在的﻿<br>concurrent 并行 并发﻿<br>configuration组态 配置﻿<br>connection 连接，连线（网络,资料库） 连接﻿<br>constraint 约束（条件）﻿<br>construct 构件 构件﻿<br>container 容器 容器(存放资料的某种结构如list, vector…）﻿<br>containment 内含 包容﻿<br>context背景关系、周遭环境、上下脉络 环境、上下文﻿<br>control 控制元件、控件 控件﻿<br>console 主控台 控制台﻿<br>const常数（constant 的缩写，C++ 关键字）﻿<br>constant 常数（相对於variable） 常量﻿<br>constructor（ctor） 建构式 构造函数（与class 同名的一种 member functions）﻿<br>copy (v) 复制、拷贝 拷贝﻿<br>copy (n) 复件, 副本﻿<br>cover 涵盖 覆盖﻿<br>create 创建、建立、产生、生成 创建﻿<br>creation 产生、生成 创建﻿<br>cursor 游标 光标custom、订制、自定 定制<br>data 资料 数据﻿<br>database 资料库 数据库﻿<br>database schema 数据库结构纲目﻿<br>data member 资料成员、成员变数 数据成员、成员变量﻿<br>data structure 资料结构 数据结构﻿<br>datagram 资料元 数据报文﻿<br>dead lock 死结 死锁﻿<br>debug 除错 调试﻿<br>debugger 除错器 调试器﻿<br>declaration 宣告、宣告式 声明﻿<br>deduction 推导（例：template argument deduction） 推导、推断﻿<br>default 预设 缺省、默认﻿<br>defer 延缓 推迟﻿<br>define 定义 预定义﻿<br>definition 定义、定义区、定义式 定义﻿<br>delegate 委派、委托、代理﻿<br>delegation （同上）﻿<br>demarshal 反编列 散集﻿<br>dereference 提领（取出指标所指物体的内容） 解叁考﻿<br>dereference operator dereference（提领）运算子 * 解叁考操作符﻿<br>derived class 衍生类别 派生类﻿<br>design by contract 契约式设计﻿<br>design pattern 设计范式、设计样式 设计模式﻿<br>destroy 摧毁、销毁﻿<br>destructor  解构式 析构函数﻿<br>device 装置、设备 设备﻿<br>dialog 对话窗、对话盒 对话框﻿<br>directive 指令（例：using directive） (编译)指示符﻿<br>directory 目录 目录﻿<br>disk 碟 盘﻿<br>dispatch 分派 分派﻿<br>distributed computing 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算)﻿<br>document 文件 文档﻿<br>dot operator dot（句点）运算子 . (圆)点操作符﻿<br>driver 驱动程式 驱动（程序）﻿<br>dynamic binding 动态系结 动态绑定﻿<br>efficiency 效率 效率﻿<br>efficient 高效 高效﻿<br>end user 终端用户﻿<br>entity 物体 实体、物体﻿<br>encapsulation 封装 封装﻿<br>enclosing class外围类别（与巢状类别 nested class有关）外围类﻿<br>enum (enumeration) 列举（一种 C++ 资料型别） 枚举﻿<br>enumerators 列举元（enum 型别中的成员） 枚举成员、枚举器﻿<br>equal 相等 相等﻿<br>equality 相等性 相等性﻿<br>equality operator equality（等号）运算子 == 等号操作符﻿<br>equivalence等价性、等同性、对等性 等价性﻿<br>equivalent 等价、等同、对等 等价﻿<br>escape code 转义码 转义码﻿<br>evaluate 评估、求值、核定 评估﻿<br>event 事件 事件﻿<br>event driven 事件驱动的 事件驱动的﻿<br>exception 异常情况 异常﻿<br>exception declaration 异常宣告（ref. C++ Primer 3/e, 11.3）异常声明﻿<br>exception handling 异常处理、异常处理机制 异常处理、异常处理机制﻿<br>exception specification 异常规格（ref. C++ Primer 3/e, 11.4）异常规范﻿<br>exit 退离（指离开函式时的那一个执行点） 退出﻿<br>explicit 明白的、明显的、显式 显式﻿<br>export 汇出 引出、导出﻿<br>facility 设施、设备 设施、设备﻿<br>feature 特性﻿<br>field 栏位,资料栏（Java） 字段, 值域（Java）﻿<br>file 档案 文件﻿<br>firmware 韧体 固件﻿<br>flag 旗标 标记﻿<br>flash memory 快闪记忆体 闪存﻿<br>flexibility 弹性 灵活性﻿<br>flush 清理、扫清 刷新﻿<br>font 字型 字体﻿<br>form 表单（programming 用语） 窗体﻿<br>formal parameter形式叁数 形式叁数</p>
<p>forward declaration 前置宣告 前置声明﻿<br>forwarding 转呼叫,转发 转发﻿<br>forwarding function 转呼叫函式,转发函式 转发函数﻿<br>fractal 碎形 分形﻿<br>framework 框架 框架﻿<br>full specialization 全特化（ref. partial specialization）﻿<br>function 函式、函数 函数﻿<br>function call operator 同﻿<br>call operator function object 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象﻿<br>function overloaded resolution 函式多载决议程序 函数重载解决（方案）﻿<br>functionality 功能、机能 功能﻿<br>function template 函式模板、函式范本 函数模板﻿<br>functor 仿函式 仿函式、函子<br>game 游戏 游戏﻿<br>generate 生成﻿<br>generic 泛型、一般化的 一般化的、通用的、泛化﻿<br>generic algorithm 泛型演算法 通用算法﻿<br>getter (相对於 setter) 取值函式﻿<br>global 全域的（对应於 local） 全局的﻿<br>global object 全域物件 全局对象﻿<br>global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符﻿<br>group 群组<br>group box 群组方块 分组框<br>guard clause 卫述句 (Refactoring, p250) 卫语句<br>GUI 图形介面 图形界面﻿<br>hand shaking握手协商﻿<br>handle 识别码、识别号、号码牌、权柄 句柄﻿<br>handler 处理常式 处理函数﻿<br>hard－coded 编死的 硬编码的﻿<br>hard－copy 硬拷图 屏幕截图﻿<br>hard disk硬碟 硬盘﻿<br>hardware 硬体 硬件﻿<br>hash table 杂凑表 哈希表、散列表﻿<br>header file 表头档、标头档 头文件﻿<br>heap堆积 堆﻿<br>hierarchy 阶层体系 层次结构（体系）﻿<br>hook 挂钩 钩子﻿<br>hyperlink 超链结 超链接﻿<br>icon 图示、图标 图标﻿<br>IDE 整合开发环境 集成开发环境﻿<br>identifier 识别字、识别符号 标识符﻿<br>if and only if 若且唯若 当且仅当﻿<br>Illinois 伊利诺 伊利诺斯﻿<br>image 影像 图象﻿<br>immediate base 直接的（紧临的）上层 base class。 直接上层基类﻿<br>immediate derived 直接的（紧临的）下层derived class。 直接下层派生类﻿<br>immutability 不变性﻿<br>immutable不可变（的）﻿<br>implement实作、实现 实现﻿<br>implementation实作品、实作体、实作码、实件 实现﻿<br>implicit 隐喻的、暗自的、隐式 隐式﻿<br>import汇入 导入﻿<br>increment operator累加运算子 ++ 增加操作符﻿<br>infinite loop 无穷回圈 无限循环﻿<br>infinite recursive 无穷递回 无限递归﻿<br>information 资讯 信息﻿<br>infrastructure 公共基础建设﻿<br>inheritance继承、继承机制 继承、继承机制﻿<br>inline 行内 内联﻿<br>inline expansion 行内展开 内联展开﻿<br>initialization 初始化（动作） 初始化﻿<br>initialization list 初值列 初始值列表﻿<br>initialize 初始化 初始化﻿<br>inner class 内隐类别 内嵌类﻿<br>instance 实体 实例（根据某种表述而实际产生的「东西」）﻿<br>instantiated 具现化、实体化（常应用於 template） 实例化﻿<br>instantiation 具现体、具现化实体（常应用於 template） 实例﻿<br>integer (integral) 整数（的） 整型（的）﻿<br>integrate 整合 集成﻿<br>interacts 交谈、互动 交互﻿<br>interface 介面 接口﻿<br>interpreter 直译器 解释器﻿<br>invariants 恒常性,约束条件 约束条件﻿<br>invoke 唤起 调用﻿<br>iterate迭代（回圈一个轮回一个轮回地进行） 迭代﻿<br>iterative 反覆的，迭代的﻿<br>iterator 迭代器（一种泛型指标） 迭代器﻿<br>iteration 迭代（回圈每次轮回称为一个 iteration） 迭代﻿<br>item 项目、条款 项、条款、项目﻿<br>laser 雷射 激光﻿<br>level 阶 层 (级) 例high level高阶 高层﻿<br>library 程式库、函式库 库、函数库﻿<br>lifetime生命期、寿命 生命期、寿命﻿<br>link联结、连结 连接,链接﻿<br>linker联结器、连结器 连接器﻿<br>literal constant 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数﻿<br>list串列（linked－list） 列表、表、链表﻿<br>list box 列表方块、列表框 列表框﻿</p>
<p>load 载入 装载﻿<br>loader 载入器 装载器、载入器﻿<br>local 区域的（对应於 global） 局部的﻿<br>local object 区域物件 局部对象﻿<br>lock机锁﻿<br>loop 回圈 循环﻿<br>lvalue左值 左值﻿<br>﻿<br>macro 巨集 宏﻿<br>magic number 魔术数字 魔法数﻿<br>maintain 维护 维护﻿<br>manipulator操纵器（iostream预先定义的一种东西） 操纵器﻿<br>marshal 编列 列集叁考<br>demarshal mechanism 机制 机制﻿<br>member 成员 成员﻿<br>member access operator 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符﻿<br>member function 成员函式 成员函数﻿<br>member initialization list 成员初值列 成员初始值列表﻿<br>member wise 以 member 为单元┅、members 逐一┅ 以成员为单位﻿<br>member wise copy 以 members 为单元逐一复制﻿<br>memory 记忆体 内存﻿<br>menu 表单、选单 菜单﻿<br>message 讯息 消息<br>message based 以讯息为基础的 基於消息的﻿<br>message loop讯息回圈 消息环﻿<br>method 方法、行为、函式 方法﻿<br>meta－ 超－ 元－﻿<br>meta－programming 超编程 元编程﻿<br>micro 微 微﻿<br>middleware 中介层 中间件﻿<br>modeling 模塑﻿<br>modeling language 塑模语言，建模语言﻿<br>modem 数据机 调制解调器﻿<br>module 模组 模块﻿<br>modifier 饰词 修饰符﻿<br>most derived class 最末层衍生类别 最底层的派生类﻿<br>mouse 滑鼠 鼠标﻿<br>mutable可变的 可变的﻿<br>multi－tasking 多工 多任务﻿<br>namespace 命名空间 名字空间、命名空间﻿<br>native 原生的 本地的、固有的﻿<br>nested class 巢状类别 嵌套类﻿<br>network 网路 网络﻿<br>network card网路卡 网卡<br>object 物件 对象﻿<br>object based 以物件为基础的 基於对象的﻿<br>object file 目的档 目标文件﻿<br>object model 物件模型 对象模型﻿<br>object oriented 物件导向的 面向对象的﻿<br>online 线上 在线﻿<br>opaque不透明的﻿<br>operand 运算元 操作数﻿<br>operating system (OS) 作业系统 操作系统﻿<br>operation 操作、操作行为 操作﻿<br>operator 运算子 操作符、运算符﻿<br>option 选项，可选方案 选项﻿<br>ordinary 常规的 常规的﻿<br>overflow 上限溢位（相对於 underflow） 溢出（underflow:下溢）﻿<br>overhead 额外负担、额外开销 额外开销﻿<br>overload 多载化、多载化、重载 重载﻿<br>overloaded function 多载化函式 重载的函数﻿<br>overloaded operator 多载化运算子 被重载的操作符﻿<br>overloaded set 多载集合 重载集合﻿<br>override 改写、覆写 重载、改写、重新定义（在 derived class 中重新定义虚拟函式)<br>package套件 包<br>pair 对组﻿<br>palette 调色盘、组件盘、工具箱﻿<br>pane 窗格 窗格﻿<br>parallel平行 并行﻿<br>parameter 叁数（函式叁数列上的变数） 叁数、形式叁数、形叁﻿<br>parameter list 叁数列 叁数列表﻿<br>parent class 父类别（或称 base class） 父类﻿<br>parentheses 小括弧、小括号 圆括弧、圆括号﻿<br>parse 解析 解析﻿<br>part零件 部件﻿<br>partial specialization 偏特化（ref. C++ Primer 3/e, 16.10）局部特化﻿<br>pass by address 传址（函式引数的传递方式）（非正式用语）传地址﻿<br>pass by reference传址（函式引数的一种传递方式） 传地址, 按引用传递﻿<br>pass by value 传值（函式引数的一种传递方式） 按值传递﻿<br>pattern 范式、样式 模式﻿<br>performance 效率、性能兼而有之 性能﻿<br>persistence 永续性 持久性﻿<br>pixel 图素、像素 像素﻿<br>platform 平台 平台﻿<br>pointer指标 指针址位器（和址叁器 reference 形成对映，满好）﻿<br>poll 轮询 轮询﻿<br>polymorphism多型 多态﻿<br>pop up 冒起式、弹出式 弹出式﻿<br>port 埠 端口﻿<br>postfix 後置式、後序式 後置式﻿<br>precedence 优先序（通常用於运算子的优先执行次序）﻿<br>prefix 前置式、前序式 前置式﻿<br>preprocessor 前处理器 预处理器﻿<br>prime质数 素数﻿<br>primitive type 基本型别 (不同於 base class,基础类别)﻿<br>print 列印 打印﻿<br>printer 印表机 打印机﻿<br>priority优先权 (通常用於执行绪获得 CPU 时间的优先次序）﻿<br>procedure 程序 过程﻿<br>procedural 程序的、程序式的 过程式的、过程化的﻿</p>
<p>process 行程 进程﻿<br>profile 评测 评测﻿<br>profiler 效能（效率）评测器 效能（性能）评测器﻿<br>programmer 程式员 程序员﻿<br>programming 编程、程式设计、程式化 编程﻿<br>progress bar 进度指示器 进度指示器﻿<br>project 专案 项目、工程﻿<br>property 属性﻿<br>protocol协定 协议﻿<br>pseudo code 假码、虚拟码、伪码 伪码﻿<br>﻿<br>qualified 经过资格修饰（例如加上scope 运算子） 限定﻿<br>qualifier 资格修饰词、饰词 限定修饰词﻿<br>quality品质 质量﻿<br>queue 伫列 队列﻿<br>radian 径度 弧度﻿<br>radio button 圆钮 单选按钮﻿<br>raise 引发（常用来表示发出一个 exception） 引起、引发﻿<br>random number 随机数、乱数 随机数﻿<br>range范围、区间（用於 STL 时） 范围、区间﻿<br>rank 等级、分等（ref. C++Primer 3/e 9,15章） 等级﻿<br>raw 生鲜的、未经处理的 未经处理的﻿<br>record记录 记录﻿<br>recordset 记录集 记录集﻿<br>recursive 递回 递归﻿<br>re－direction重导向 重定向﻿<br>refactoring 重构、重整 重构﻿<br>refer 取用 叁考﻿<br>refer to指向、指涉、指代﻿<br>reference 引用、叁考 址叁器,﻿<br>see pointer register暂存器 寄存器﻿<br>reflection 反射 反射、映像﻿<br>relational database 关联式资料库 关系数据库﻿<br>represent 表述，表现 表述，表现﻿<br>resolve 决议（为算式中的符号名称寻找 解析对应之宣告式的过程）﻿<br>resolution 决议程序、决议过程 解析过程﻿<br>resolution 解析度 分辨率﻿<br>restriction 局限﻿<br>return 传回、回返 返回﻿<br>return type 回返型别 返回类型﻿<br>return value 回返值 返回值﻿<br>robust 强固、稳健 健壮﻿<br>robustness强固性、稳健性 健壮性﻿<br>routine常式 例程﻿<br>runtime 执行期 运行期、运行时﻿<br>common language runtime(CLR) 译为「通用语言执行层」﻿<br>rvalue 右值 右值﻿<br>save 保存﻿<br>save point 保存点﻿<br>SAX (Simple API for XML)scalable可伸缩的、可扩展的﻿<br>schedule 调度</p>
<p>scheduler 调度程序﻿<br>schema模式、纲目结构﻿<br>scroll bar 滚动条﻿<br>scope 作用域、生存空间﻿<br>scope operator 生存空间操作符﻿<br>scope resolution operator生存空间解析操作符﻿<br>screen 屏幕﻿<br>SDK (Software Development Kit) 软件开发包﻿<br>sealed class 密封类﻿<br>search 查找﻿<br>semantics 语义﻿<br>semaphore信号量﻿<br>sequential container序列式容器﻿<br>server 服务器、服务端﻿<br>serial 串行﻿<br>serialization/serialize 序列化﻿<br>server cursor服务端游标、服务器游标﻿<br>session 会话﻿<br>setter 设值函数﻿<br>shared lock 共享锁﻿<br>sibling 同级﻿<br>side effect 副作用﻿<br>signature 签名﻿<br>single-threaded 单线程﻿<br>slider滑块﻿<br>slot 槽﻿<br>smart pointer 智能指针﻿<br>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议﻿<br>snapshot 截屏图﻿<br>snapshot 快照﻿<br>specialization 特化﻿<br>specification 规范、规格﻿<br>splitter 切分窗口﻿<br>SOAP (simple object access protocol)简单对象访问协议﻿<br>software 软件﻿<br>source code 源码、源代码﻿<br>SQL (Structured Query Language) 结构化查询语言﻿<br>stack 栈、堆栈﻿<br>stack unwinding 叠辗转开解(此词用于exception主题)﻿<br>standard library 标准库﻿<br>standard template library 标准模板库﻿<br>stateless 无状态的﻿<br>statement 语句、声明﻿<br>static cursor 静态游标﻿<br>static SQL statements 静态SQL语句﻿<br>stored procedure 存储过程﻿<br>status bar 状态条﻿<br>stream 流﻿<br>string 字符串﻿<br>stub 存根﻿<br>subobject子对象﻿<br>subquery 子查询﻿<br>subroutine 子例程﻿<br>subscript operator 下标操作符﻿<br>subset 子集﻿<br>subtype 子类型﻿<br>support 支持﻿<br>suspend挂起﻿<br>symbol记号﻿<br>syntax 语法﻿<br>system databases 系统数据库﻿<br>system tables 系统表﻿<br>tag标签 标记 索引标签,页签﻿<br>target 标的（例target pointer：标的指标） 目标﻿<br>task switch 工作切换 任务切换﻿<br>template 模板、范本 模板﻿<br>template argument deduction 模板引数推导 模板叁数推导﻿<br>template explicit specialization 模板显式特化（版本） 模板显式特化﻿<br>template parameter 模板叁数 模板叁数﻿<br>temporary object 暂时物件 临时对象﻿<br>text文字 文本﻿<br>text file程式本文档（放置程式原始码的档案） 文本文件﻿<br>thread 执行绪 线程﻿<br>thread safe 多绪安全 多线程安全﻿<br>throw丢掷（常指发出一个exception） 丢掷、引发﻿<br>token 语汇单元 符号、标记﻿<br>transaction 交易 事务﻿<br>transaction log 事务日志﻿<br>transaction rollback 事务回滚﻿<br>transactional replication 事务复制﻿<br>translation unit 翻译单元﻿<br>transparent(ly) 透通的(地)﻿<br>traverse 巡访（来回走动） 遍历﻿<br>trigger 触发 触发﻿<br>type型别 类型﻿<br>table 表﻿<br>table lock 表锁﻿<br>table-level constraint表级约束﻿<br>tape backup 磁带备份﻿<br>task switch 工作切换﻿<br>TCP (Transport Control Protocol) 传输控制协议﻿<br>temporary table临时表﻿<br>thin client瘦客户端﻿<br>third-party第三方﻿<br>trace 跟踪﻿<br>traverse 遍历﻿<br>two-phase commit两阶段提交﻿<br>tupletwo-phase lookup 两阶段查找﻿<br>UML unified modeling language统一建模语言﻿<br>unary function 一元函式 单叁函数﻿<br>unary operator一元运算子 一元操作符﻿<br>underflow下限溢位（相对於overflow） 下溢﻿<br>unchecked exception 不可控异常﻿<br>unqualified 未经资格修饰（而直接取用）﻿<br>user 使用者、用户 用户﻿<br>user interface使用者界面、用户界面、人机界面﻿<br>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成﻿<br>unboxing 拆箱、拆箱转换﻿<br>Union query 联合查询﻿<br>UNIQUE constraints UNIQUE约束﻿<br>unique index 唯一索引﻿<br>unmanaged code 非受控代码、非托管代码﻿<br>unmarshal散集﻿<br>unqualified 未经限定的、未经修饰的﻿<br>URI (Uniform Resource identifier) 统一资源标识符﻿<br>URL (Uniform Resource Locator)统一资源定位器﻿<br>variable 变数（相对於常数const） 变量﻿<br>vector 向量（一种容器，有点类似array） 向量、矢量﻿<br>viable可实行的、可行的 可行的﻿<br>viable function可行函式 可行函数﻿<br>video 视讯 视频<br>view (1) 视图﻿<br>(document/view)文档/视图﻿<br>virtual function 虚拟函式 虚函数﻿<br>virtual machine虚拟机器 虚拟机﻿<br>virtual memory虚拟记忆体 虚内存, 虚存﻿<br>volatile 易挥发的、易变的﻿<br>vowel 母音 元音字母﻿<br>window 视窗 窗口﻿<br>window function 视窗函式 窗口函数﻿<br>window procedure 视窗函式 窗口过程﻿<br>word 字 单词﻿<br>word processor文书处理器 字处理器﻿<br>wrapper 外覆、外包 包装﻿<br>Web Services web 服务﻿<br>WHERE clause WHERE子句﻿<br>wildcard characters 通配符字符﻿<br>wildcard search 通配符搜索﻿<br>Windows authentication Windows 身份验证﻿<br>wizard 向导﻿<br>write enable写启用﻿<br>write-ahead log 预写日志﻿<br>write-only 只写﻿<br>WSDL (Web Service Description Language)Web Service 描述语言﻿<br>XML (eXtensible Markup Language)可扩展标记语言﻿<br>XSD (XML Schema Definition)  XML 模式定义语言﻿<br>XSL (eXtensible Stylesheet Language)可扩展样式表语言﻿<br>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换﻿<br>xxx based基于xxx的﻿</p>
<p>xxx oriented面向xxxXML (eXtensible Markup Language) 可扩展标记语言</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios面试题题总结]]></title>
      <url>http://yoursite.com/2017/02/23/Summary/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[TheInterviewSummary]]></title>
      <url>http://yoursite.com/2017/02/23/TheInterviewSummary/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git]]></title>
      <url>http://yoursite.com/2017/02/21/Git/</url>
      <content type="html"><![CDATA[<h2 id="GIT简介"><a href="#GIT简介" class="headerlink" title="GIT简介"></a>GIT简介</h2><h4 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git?"></a>什么是git?</h4><ul>
<li>git是一款开源的分布式版本控制工具</li>
<li>在世界上所有的分布式版本控制工具中，git是最快、最简单、最流行的版本管理工具<h4 id="git的起源"><a href="#git的起源" class="headerlink" title="git的起源"></a>git的起源</h4></li>
<li>作者是Linux之父：Linus Benedict Torvalds</li>
<li>当初开发git仅仅是为了辅助Linux内核的开发（管理源代码）<h4 id="git的现状"><a href="#git的现状" class="headerlink" title="git的现状"></a>git的现状</h4></li>
<li>在国外已经非常普及，国内并未普及（在慢慢普及）</li>
<li>越来越多的开源项目已经转移到git<h3 id="其他版本控制工具"><a href="#其他版本控制工具" class="headerlink" title="其他版本控制工具"></a>其他版本控制工具</h3><h4 id="CVS"><a href="#CVS" class="headerlink" title="CVS"></a>CVS</h4></li>
<li>最早的开源、免费的集中式版本控制工具</li>
<li>自身设计有问题，会造成提交文件不完整，版本库莫名其妙损坏的情况</li>
</ul>
<h4 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h4><ul>
<li>修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制工具</li>
</ul>
<h4 id="ClearCase"><a href="#ClearCase" class="headerlink" title="ClearCase"></a>ClearCase</h4><ul>
<li>收费的集中式版本控制工具，安装比Windows还大，运行比蜗牛还慢</li>
<li>能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗或者人傻钱多</li>
</ul>
<h4 id="VSS"><a href="#VSS" class="headerlink" title="VSS"></a>VSS</h4><ul>
<li>微软的集中式版本控制工具，集成在Visual Studio中</li>
<li>由于它反人类的设计，连微软自己都不好意思用了</li>
</ul>
<h3 id="集中式版本控制"><a href="#集中式版本控制" class="headerlink" title="集中式版本控制"></a>集中式版本控制</h3><p><img src="/img/1.png" alt="集中式版本控制"></p>
<h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p><img src="/img/2.png" alt="分布式版本控制"></p>
<h3 id="git和SVN的简单对比"><a href="#git和SVN的简单对比" class="headerlink" title="git和SVN的简单对比"></a>git和SVN的简单对比</h3><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><ul>
<li>在很多情况下，git的速度远远比SVN快</li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li>SVN是集中式管理，git是分布式管理</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>SVN使用分支比较笨拙，git可以轻松拥有无限个分支</li>
<li>SVN必须联网才能正常工作，git支持本地版本控制工作</li>
<li>旧版本的SVN会在每一个目录置放一个.svn，git只会在根目录拥有一个.git</li>
</ul>
<h3 id="SVN的工作流程"><a href="#SVN的工作流程" class="headerlink" title="SVN的工作流程"></a>SVN的工作流程</h3><p><img src="/img/3.png" alt="SVN的工作流程"></p>
<h3 id="git的工作流程"><a href="#git的工作流程" class="headerlink" title="git的工作流程"></a>git的工作流程</h3><ul>
<li>分布式和集中式的最大区别在于：在分布式下开发者可以本地提交每个开发者机器上都有一个服务器的数据库<br><img src="/img/4.png" alt="git的工作流程"></li>
</ul>
<h3 id="使用Git"><a href="#使用Git" class="headerlink" title="使用Git"></a>使用Git</h3><p>跟SVN一样，你可以通过命令行敲指令或者图形界面客户端使用git，在Mac上，比较好用的git图形界面客户端有<br>SourceTree<br>下载地址：（<a href="http://www.sourcetreeapp.com/download/）" target="_blank" rel="external">http://www.sourcetreeapp.com/download/）</a><br>GitHub<br>下载地址：(<a href="https://mac.github.com" target="_blank" rel="external">https://mac.github.com</a>)<br>不过它是专门为GitHub网站而设计的</p>
<h3 id="Git的常用的指令"><a href="#Git的常用的指令" class="headerlink" title="Git的常用的指令"></a>Git的常用的指令</h3><p>git help ：git指令帮助手册</p>
<ul>
<li>查看其他指令的做法：git help 其他指令</li>
</ul>
<p>git config ：git的配置信息相关（修改的是.git/config文件）</p>
<ul>
<li>配置用户名：git config “user.name” 用户名（用于跟踪修改记录）</li>
<li>配置邮箱：git config “user.email” 邮箱（用于多人开发间的沟通）</li>
<li>查看配置信息：git config –l</li>
<li>编辑配置信息：git config –e（用vim编辑，:wq是退出vim编辑器）</li>
<li>设置指令的别名：git config alias.别名 原指令名称</li>
<li>设置带参数指令的别名：git config alias.别名 “原指令名称 参数”</li>
<li>将此设置应用到整个系统中：git config ––gloabal</li>
</ul>
<p>git status ：查文件的状态</p>
<ul>
<li>查看某个文件的状态：git status 文件名</li>
<li>查看当前路径所有文件的状态：git status</li>
</ul>
<p>git log ：查看文件的修改日志</p>
<ul>
<li>查看某个文件的修改日志：git log 文件名</li>
<li>查看当前路径所有文件的修改日志：git log</li>
<li>用一行的方式查看简单的日志信息：git log ––pretty=oneline</li>
<li>查看最近的N次修改：git log –N（N是一个整数）</li>
</ul>
<p>git diff ：查看文件最新改动的地方</p>
<ul>
<li>查看某个文件的最新改动的地方：git diff 文件名</li>
<li>查看当前路径所有文件最新改动的地方：git diff</li>
</ul>
<p>git init ：初始化一个空的本地仓库，生成一个.git目录，用于维护版本信息</p>
<ul>
<li>在当前路径初始化仓库：git init</li>
<li>在其他路径初始化仓库：git init 仓库路径</li>
</ul>
<p>git add ：将工作区的文件保存到暂缓区</p>
<ul>
<li>保存某个文件到暂缓区：git add 文件名</li>
<li>保存当前路径的所有文件到暂缓区：git add .（注意，最后是一个点 . ）</li>
</ul>
<p>git commit ：将暂缓区的文件提交到当前分支</p>
<ul>
<li>提交某个文件到分支：git commit -m ”注释” 文件名</li>
<li>保存当前路径的所有文件到分支：git commit -m ”注释” </li>
</ul>
<p>git reset ：版本回退（建议加上––hard参数，git支持无限次后悔）</p>
<ul>
<li>回退到上一个版本：git reset ––hard HEAD^</li>
<li>回退到上上一个版本：git reset ––hard HEAD^^</li>
<li>回退到上N个版本：git reset ––hard HEAD~N（N是一个整数）</li>
<li>回退到任意一个版本：git reset ––hard 版本号（版本号用7位即可）</li>
</ul>
<p>git reflog ：查看分支引用记录（能够查看所有的版本号）<br>git rm：删除文件（删完之后要进行commit操作，才能同步到版本库）<br>git clone：下载远程仓库到本地</p>
<ul>
<li>下载远程仓库到当前路径：git clone 仓库的URL</li>
<li>下载远程仓库到特定路径：git clone 仓库的URL 存放仓库的路径</li>
</ul>
<p>git pull：下载远程仓库的最新信息到本地仓库<br>git push：将本地的仓库信息推送到远程仓库</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>如果是多人团队开发，最好还是搭建一个远程仓库,搭建远程仓库的途径</p>
<p>自己搭建一个git服务器：费时费力<br>在GitHub上托管项目：公开项目免费、私有项目收费，很多第三方开源项目<br>在oschina上托管项目：完全免费，在国内访问速度快（推荐使用）</p>
<h4 id="搭建GitHub远程仓库-–-配置SSH-Key"><a href="#搭建GitHub远程仓库-–-配置SSH-Key" class="headerlink" title="搭建GitHub远程仓库 – 配置SSH Key"></a>搭建GitHub远程仓库 – 配置SSH Key</h4><p>注册一个GitHub帐号：（<a href="https://github.com" target="_blank" rel="external">https://github.com</a>)<br>打开“Account Settings”<br>点击“SSH keys”<br>配置Mac的SSH Key的公钥（用于限制提交）<br>在Mac上生成SSH Key（在终端输入下面指令）<br>cd ~/.ssh<br>ssh-keygen -t rsa -C “你的邮箱地址”<br>然后一直敲回车<br>然后就会在~/.ssh目录下生成SSK Key的秘钥对<br>id_rsa ：私钥，不可泄露<br>id_rsa.pub ：公钥，可以公开（将这个文件的内容粘贴到GitHub上）<br>利用cat指令可以查看文件的内容<br>cat id_rsa.pub</p>
<h4 id="搭建GitHub远程仓库–-添加仓库"><a href="#搭建GitHub远程仓库–-添加仓库" class="headerlink" title="搭建GitHub远程仓库– 添加仓库"></a>搭建GitHub远程仓库– 添加仓库</h4><p><img src="/img/6.png" alt="添加一个仓库"></p>
<h4 id="拷贝仓库地址，用于下载到本地"><a href="#拷贝仓库地址，用于下载到本地" class="headerlink" title="拷贝仓库地址，用于下载到本地"></a>拷贝仓库地址，用于下载到本地</h4><p><img src="/img/7.png" alt="拷贝仓库地址用于下载到本地"></p>
<h4 id="如果想删除仓库，也很简单"><a href="#如果想删除仓库，也很简单" class="headerlink" title="如果想删除仓库，也很简单"></a>如果想删除仓库，也很简单</h4><p><img src="/img/8.png" alt="删除"></p>
<h2 id="搭建oschina远程仓库-–创建仓库"><a href="#搭建oschina远程仓库-–创建仓库" class="headerlink" title="搭建oschina远程仓库 –创建仓库"></a>搭建oschina远程仓库 –创建仓库</h2><p>注册一个oschina帐号:(<a href="https://git.oschina.net" target="_blank" rel="external">https://git.oschina.net</a>)<br><img src="/img/9.png" alt="创建一个新项目"><br><img src="/img/10.png" alt=""></p>
<h2 id="搭建oschina远程仓库-–仓库地址"><a href="#搭建oschina远程仓库-–仓库地址" class="headerlink" title="搭建oschina远程仓库 –仓库地址"></a>搭建oschina远程仓库 –仓库地址</h2><p><img src="/img/11.png" alt=""></p>
<p><img src="/img/12.png" alt="添加项目组成员"></p>
<h2 id="搭建oschina远程仓库-–-删除仓库"><a href="#搭建oschina远程仓库-–-删除仓库" class="headerlink" title="搭建oschina远程仓库 – 删除仓库"></a>搭建oschina远程仓库 – 删除仓库</h2><p><img src="/img/13.png" alt="添加项目组成员"></p>
<h1 id="二、本地的Git操作"><a href="#二、本地的Git操作" class="headerlink" title="二、本地的Git操作"></a>二、本地的Git操作</h1><hr>
<h2 id="1-GIT命令行帮助"><a href="#1-GIT命令行帮助" class="headerlink" title="1.GIT命令行帮助"></a>1.GIT命令行帮助</h2><p>$ svn help<br>查看svn所有命令的帮助<br>$ svn help 子命令</p>
<ul>
<li>要退出帮助信息，按”q”</li>
<li>翻看下页，按”空格”</li>
<li>翻看上页，按”CTRL+B”</li>
<li>要搜索相关文字，按”/“然后输入”相关文字”</li>
</ul>
<h2 id="2-创建代码库-amp-配置个人信息"><a href="#2-创建代码库-amp-配置个人信息" class="headerlink" title="2.创建代码库 &amp; 配置个人信息"></a>2.创建代码库 &amp; 配置个人信息</h2><h3 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h3><p>$ git init</p>
<h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><p>$ git config user.name lnj<br>$ git config user.email lnj@gmail.com</p>
<ul>
<li>以上两个命令会将用户信息保存在当前代码仓库中,只有配置了用户和邮箱之后，git才能识别出操作的人员信息，通过钩子(hooks)程序可以设置一些动作, 例如单元测试发现问题后，自动给相关人员发送电子邮件</li>
</ul>
<h3 id="如果要一次性配置完成可以使用一下命令"><a href="#如果要一次性配置完成可以使用一下命令" class="headerlink" title="如果要一次性配置完成可以使用一下命令"></a>如果要一次性配置完成可以使用一下命令</h3><p>$ git config –global user.name lnj<br>$ git config –global user.email lnj321@gmail.com</p>
<ul>
<li>以上两个命令会将用户信息保存在用户目录下的 .gitconfig 文件中</li>
</ul>
<h3 id="查看当前所有配置"><a href="#查看当前所有配置" class="headerlink" title="查看当前所有配置"></a>查看当前所有配置</h3><p>$ git config -l</p>
<h2 id="3-实际开发"><a href="#3-实际开发" class="headerlink" title="3.实际开发"></a>3.实际开发</h2><h3 id="创建代码，开始开发"><a href="#创建代码，开始开发" class="headerlink" title="创建代码，开始开发"></a>创建代码，开始开发</h3><p>$ touch main.c<br>$ open main.c</p>
<h3 id="将代码添加到代码库"><a href="#将代码添加到代码库" class="headerlink" title="将代码添加到代码库"></a>将代码添加到代码库</h3><h4 id="查看当前代码库状态"><a href="#查看当前代码库状态" class="headerlink" title="查看当前代码库状态"></a>查看当前代码库状态</h4><p>$ git status</p>
<h4 id="将文件添加到代码库"><a href="#将文件添加到代码库" class="headerlink" title="将文件添加到代码库"></a>将文件添加到代码库</h4><p>$ git add main.c</p>
<h4 id="将修改提交到代码库"><a href="#将修改提交到代码库" class="headerlink" title="将修改提交到代码库"></a>将修改提交到代码库</h4><p>$ git commit -m “添加了main.c”</p>
<p>提示：</p>
<ul>
<li>在此一定要使用 -m 参数指定修改的备注信息</li>
<li>否则会进入 vim 编辑器，如果对vim不熟悉，会是很糟糕的事情</li>
</ul>
<h3 id="将当前文件夹下的所有新建或修改的文件一次性添加到代码库"><a href="#将当前文件夹下的所有新建或修改的文件一次性添加到代码库" class="headerlink" title="将当前文件夹下的所有新建或修改的文件一次性添加到代码库"></a>将当前文件夹下的所有新建或修改的文件一次性添加到代码库</h3><p>$ git add .</p>
<h4 id="添加多个文件"><a href="#添加多个文件" class="headerlink" title="添加多个文件"></a>添加多个文件</h4><p>$ touch Person.h Person.m<br>$ git add .<br>$ git commit -m “添加了Person类”<br>$ open Person.h<br>$ git add .<br>$ git commit -m “增加Person类属性”</p>
<ul>
<li>注意 使用git时，每一次修改都需要添加再提交，这一点是与svn不一样的<h4 id="git-的重要概念及工作原理"><a href="#git-的重要概念及工作原理" class="headerlink" title="git 的重要概念及工作原理"></a>git 的重要概念及工作原理</h4>工作区<br>暂存区(staged)<br>分支(HEAD)</li>
</ul>
<h2 id="3-别名-amp-日志"><a href="#3-别名-amp-日志" class="headerlink" title="3.别名 &amp; 日志"></a>3.别名 &amp; 日志</h2><p>$ git config alias.st status<br>$ git config alias.ci “commit -m”</p>
<ul>
<li>个人建议：除非特殊原因，最好不要设置别名，否则换一台机器就不会用了<h4 id="查看所有版本库日志"><a href="#查看所有版本库日志" class="headerlink" title="查看所有版本库日志"></a>查看所有版本库日志</h4>$ git log<h4 id="查看指定文件的版本库日志"><a href="#查看指定文件的版本库日志" class="headerlink" title="查看指定文件的版本库日志"></a>查看指定文件的版本库日志</h4>$ git log 文件名<h4 id="配置带颜色的log别名"><a href="#配置带颜色的log别名" class="headerlink" title="配置带颜色的log别名"></a>配置带颜色的log别名</h4>$ git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”<br>提示：在git中，版本号是一个由SHA1生成的哈希值</li>
</ul>
<h2 id="4-版本号，让我们在任意版本之间穿梭"><a href="#4-版本号，让我们在任意版本之间穿梭" class="headerlink" title="4.版本号，让我们在任意版本之间穿梭"></a>4.版本号，让我们在任意版本之间穿梭</h2><h3 id="回到当前版本，放弃所有没有提交的修改"><a href="#回到当前版本，放弃所有没有提交的修改" class="headerlink" title="回到当前版本，放弃所有没有提交的修改"></a>回到当前版本，放弃所有没有提交的修改</h3><p>$ git reset –hard HEAD</p>
<h3 id="回到上一个版本"><a href="#回到上一个版本" class="headerlink" title="回到上一个版本"></a>回到上一个版本</h3><p>$ git reset –hard HEAD^</p>
<h3 id="回到之前第3个修订版本"><a href="#回到之前第3个修订版本" class="headerlink" title="回到之前第3个修订版本"></a>回到之前第3个修订版本</h3><p>$ git reset –hard HEAD~(3)</p>
<h3 id="回到指定版本号的版本"><a href="#回到指定版本号的版本" class="headerlink" title="回到指定版本号的版本"></a>回到指定版本号的版本</h3><p>$ git reset e695b67</p>
<h3 id="查看分支引用记录"><a href="#查看分支引用记录" class="headerlink" title="查看分支引用记录"></a>查看分支引用记录</h3><p>$ git reflog</p>
<h2 id="5-单个文件的修改管理"><a href="#5-单个文件的修改管理" class="headerlink" title="5.单个文件的修改管理"></a>5.单个文件的修改管理</h2><h3 id="查看文件变化"><a href="#查看文件变化" class="headerlink" title="查看文件变化"></a>查看文件变化</h3><p>$ git diff</p>
<h3 id="撤销对文件做的修改"><a href="#撤销对文件做的修改" class="headerlink" title="撤销对文件做的修改"></a>撤销对文件做的修改</h3><p>$ git checkout Person.h</p>
<h3 id="从代码库（暂存区中删除文件）"><a href="#从代码库（暂存区中删除文件）" class="headerlink" title="从代码库（暂存区中删除文件）"></a>从代码库（暂存区中删除文件）</h3><h1 id="三、Git团队开发操作"><a href="#三、Git团队开发操作" class="headerlink" title="三、Git团队开发操作"></a>三、Git团队开发操作</h1><hr>
<h2 id="1-建立代码仓库-专门用于团队开发的代码仓库"><a href="#1-建立代码仓库-专门用于团队开发的代码仓库" class="headerlink" title="1.建立代码仓库(专门用于团队开发的代码仓库)"></a>1.建立代码仓库(专门用于团队开发的代码仓库)</h2><h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><p>$ cd /Users/lnj/Desktop/git演练/公司/weibo</p>
<h3 id="建立空白代码库-专门用于团队开发"><a href="#建立空白代码库-专门用于团队开发" class="headerlink" title="建立空白代码库(专门用于团队开发)"></a>建立空白代码库(专门用于团队开发)</h3><p>$ git init –bare</p>
<h2 id="2-项目经理准备项目-前奏"><a href="#2-项目经理准备项目-前奏" class="headerlink" title="2.项目经理准备项目(前奏)"></a>2.项目经理准备项目(前奏)</h2><h3 id="切换目录-1"><a href="#切换目录-1" class="headerlink" title="切换目录"></a>切换目录</h3><p>$ cd /Users/lnj/Desktop/git演练/经理</p>
<h3 id="“克隆”代码库到本地"><a href="#“克隆”代码库到本地" class="headerlink" title="“克隆”代码库到本地"></a>“克隆”代码库到本地</h3><p>$ git clone /Users/lnj/Desktop/git演练/公司/weibo/</p>
<h3 id="个人信息配置-因为要演示一台机器上的多人协作，日常开发可以忽略"><a href="#个人信息配置-因为要演示一台机器上的多人协作，日常开发可以忽略" class="headerlink" title="个人信息配置(因为要演示一台机器上的多人协作，日常开发可以忽略)"></a>个人信息配置(因为要演示一台机器上的多人协作，日常开发可以忽略)</h3><p>$ git config user.name manager<br>$ git config user.email manager@163.com</p>
<p>.gitignore<br>.gitignore可以指定哪些文件不纳入版本库的管理</p>
<p>参考网址:(<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a>)</p>
<h1 id="命令行中进入与-git同级的目录"><a href="#命令行中进入与-git同级的目录" class="headerlink" title="命令行中进入与.git同级的目录"></a>命令行中进入与.git同级的目录</h1><p>$ cd /Users/lnj/Desktop/git演练/经理/weibo</p>
<ul>
<li>将以下命令一次性粘贴到命令行中</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">echo -e "# Xcode</div><div class="line">#</div><div class="line">build/</div><div class="line">*.pbxuser</div><div class="line">*.mode1v3</div><div class="line">*.mode2v3</div><div class="line">*.perspectivev3</div><div class="line">xcuserdata</div><div class="line">*.xccheckout</div><div class="line">*.moved-aside</div><div class="line">DerivedData</div><div class="line">*.hmap</div><div class="line">*.ipa</div><div class="line">*.xcuserstate</div><div class="line"># CocoaPods</div><div class="line">#</div><div class="line"># We recommend against adding the Pods directory to your .gitignore. However</div><div class="line"># you should judge for yourself, the pros and cons are mentioned at:</div><div class="line"># http://guides.cocoapods.org/using/using-cocoapods.html#should-i-ignore-the-pods-directory-in-source-control</div><div class="line">#</div><div class="line"># Pods/" &gt; .gitignore</div></pre></td></tr></table></figure>
<h3 id="将-gitignore添加到代码库"><a href="#将-gitignore添加到代码库" class="headerlink" title="将.gitignore添加到代码库"></a>将.gitignore添加到代码库</h3><p>$ git add .gitignore</p>
<h2 id="3-创建项目"><a href="#3-创建项目" class="headerlink" title="3.创建项目"></a>3.创建项目</h2><ul>
<li>提交同时”push”到远程代码仓库</li>
</ul>
<h2 id="4-新人加入"><a href="#4-新人加入" class="headerlink" title="4.新人加入"></a>4.新人加入</h2><p>…</p>
<h2 id="5-分布式的代码库-仅供参考"><a href="#5-分布式的代码库-仅供参考" class="headerlink" title="5.分布式的代码库 - 仅供参考"></a>5.分布式的代码库 - 仅供参考</h2><ul>
<li>由于git是分布式的，任何一台计算机上都保留有完整的代码库的内容，因此可以把团队开发的代码库放在任何位置</li>
</ul>
<h2 id="6-分支管理-Tag"><a href="#6-分支管理-Tag" class="headerlink" title="6.分支管理 - Tag"></a>6.分支管理 - Tag</h2><h3 id="查看当前标签"><a href="#查看当前标签" class="headerlink" title="查看当前标签"></a>查看当前标签</h3><p>$ git tag</p>
<h3 id="在本地代码库给项目打上一个标签"><a href="#在本地代码库给项目打上一个标签" class="headerlink" title="在本地代码库给项目打上一个标签"></a>在本地代码库给项目打上一个标签</h3><p>$ git tag -a v1.0 -m ‘Version 1.0’</p>
<h3 id="将标签添推送到远程代码库中"><a href="#将标签添推送到远程代码库中" class="headerlink" title="将标签添推送到远程代码库中"></a>将标签添推送到远程代码库中</h3><p>$ git push origin v1.0</p>
<ul>
<li>使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本</li>
</ul>
<h3 id="签出v1-0标签"><a href="#签出v1-0标签" class="headerlink" title="签出v1.0标签"></a>签出v1.0标签</h3><p>$ git checkout v1.0</p>
<h3 id="从签出状态创建v1-0bugfix分支"><a href="#从签出状态创建v1-0bugfix分支" class="headerlink" title="从签出状态创建v1.0bugfix分支"></a>从签出状态创建v1.0bugfix分支</h3><p>$ git checkout -b bugfix1.0</p>
<h3 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h3><p>$ git branch -r</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>$ git branch -r -d origin/bugfix1.0</p>
<h1 id="四、Git分支管理-了解"><a href="#四、Git分支管理-了解" class="headerlink" title="四、Git分支管理(了解)"></a>四、Git分支管理(了解)</h1><hr>
<h2 id="1-分布式的代码库-仅供参考"><a href="#1-分布式的代码库-仅供参考" class="headerlink" title="1.分布式的代码库 - 仅供参考"></a>1.分布式的代码库 - 仅供参考</h2><ul>
<li>由于git是分布式的，任何一台计算机上都保留有完整的代码库的内容，因此可以把团队开发的代码库放在任何位置</li>
<li>多个远程代码库之间的同步演练”提示，此演练仅供了解，具体的使用，需要一定的团队规模之后，才能够体会”</li>
</ul>
<h2 id="2-分支管理-Tag"><a href="#2-分支管理-Tag" class="headerlink" title="2.分支管理 - Tag"></a>2.分支管理 - Tag</h2><h3 id="查看当前标签-1"><a href="#查看当前标签-1" class="headerlink" title="查看当前标签"></a>查看当前标签</h3><p>$ git tag</p>
<h3 id="在本地代码库给项目打上一个标签-1"><a href="#在本地代码库给项目打上一个标签-1" class="headerlink" title="在本地代码库给项目打上一个标签"></a>在本地代码库给项目打上一个标签</h3><p>$ git tag -a v1.0 -m ‘Version 1.0’</p>
<h3 id="将标签添推送到远程代码库中-1"><a href="#将标签添推送到远程代码库中-1" class="headerlink" title="将标签添推送到远程代码库中"></a>将标签添推送到远程代码库中</h3><p>$ git push origin v1.0</p>
<h3 id="使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本"><a href="#使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本" class="headerlink" title="使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本"></a>使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本</h3><h3 id="签出v1-0标签-1"><a href="#签出v1-0标签-1" class="headerlink" title="签出v1.0标签"></a>签出v1.0标签</h3><p>$ git checkout v1.0</p>
<h3 id="从签出状态创建v1-0bugfix分支-1"><a href="#从签出状态创建v1-0bugfix分支-1" class="headerlink" title="从签出状态创建v1.0bugfix分支"></a>从签出状态创建v1.0bugfix分支</h3><p>$ git checkout -b bugfix1.0</p>
<h3 id="查看远程分支-1"><a href="#查看远程分支-1" class="headerlink" title="查看远程分支"></a>查看远程分支</h3><p>$ git branch -r</p>
<h3 id="删除远程分支-1"><a href="#删除远程分支-1" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>$ git branch -r -d origin/bugfix1.0</p>
<h1 id="四、Github使用-amp-如何学习第三方库"><a href="#四、Github使用-amp-如何学习第三方库" class="headerlink" title="四、Github使用&amp;如何学习第三方库"></a>四、Github使用&amp;如何学习第三方库</h1><hr>
<h2 id="如何使用-学习第三方框架-优秀的第三方框架都在-github-com。"><a href="#如何使用-学习第三方框架-优秀的第三方框架都在-github-com。" class="headerlink" title="如何使用/学习第三方框架?优秀的第三方框架都在 github.com。"></a>如何使用/学习第三方框架?优秀的第三方框架都在 github.com。</h2><h3 id="1-搜索"><a href="#1-搜索" class="headerlink" title="1.搜索"></a>1.搜索</h3><h3 id="2-git-clone-获得完整版本"><a href="#2-git-clone-获得完整版本" class="headerlink" title="2.git clone 获得完整版本"></a>2.git clone 获得完整版本</h3><p>$ git clone <a href="https://github.com/AFNetworking/AFNetworking.git" target="_blank" rel="external">https://github.com/AFNetworking/AFNetworking.git</a></p>
<h3 id="3-获取最新版本-git-pull"><a href="#3-获取最新版本-git-pull" class="headerlink" title="3.获取最新版本 git pull"></a>3.获取最新版本 git pull</h3><ul>
<li>进入clone的本地文件夹<br>$ git pull<h3 id="4-看github上的文档-优秀的第三方框架都有好的文档"><a href="#4-看github上的文档-优秀的第三方框架都有好的文档" class="headerlink" title="4.看github上的文档,优秀的第三方框架都有好的文档"></a>4.看github上的文档,优秀的第三方框架都有好的文档</h3><h3 id="5-编写测试程序-看运行结果"><a href="#5-编写测试程序-看运行结果" class="headerlink" title="5.编写测试程序,看运行结果"></a>5.编写测试程序,看运行结果</h3><h3 id="6-针对感兴趣的部分-看源代码"><a href="#6-针对感兴趣的部分-看源代码" class="headerlink" title="6.针对感兴趣的部分,看源代码"></a>6.针对感兴趣的部分,看源代码</h3><h3 id="7-有问题去-http-stackoverflow-com"><a href="#7-有问题去-http-stackoverflow-com" class="headerlink" title="7.有问题去(http://stackoverflow.com)"></a>7.有问题去(<a href="http://stackoverflow.com" target="_blank" rel="external">http://stackoverflow.com</a>)</h3></li>
</ul>
<h1 id="五、练习笔记"><a href="#五、练习笔记" class="headerlink" title="五、练习笔记"></a>五、练习笔记</h1><hr>
<p>1.新建一个“本地仓库”<br>$ git init</p>
<p>2.配置仓库<br>》告诉git你是谁<br>git config user.name lnj<br>》告诉git怎么联系你<br>git config user.email lnj@itcast.cn</p>
<p>》上面一种配置方式是一次性的配置， 会配置到被管理文件的。git文件夹下<br>》下面一种配置方式是一劳永逸的方式:<br>git config –global user.name lmj<br>git config –global user.email lmj@itcast.cn</p>
<p>》如何学习git指令</p>
<blockquote>
<p>学习git指令和SVN指令的学习其实是一样的， 只不过展现的方式不太一样， git是通过使用指南的方式告诉我们某一个指令如何使用<br>这个指南其实是一个不可编辑的vim<br>Q退出指南<br>按空格下一页<br>control + B 上一页<br>/需要搜索的内容 可以进行搜索</p>
</blockquote>
<p>git常规指令<br>》git status 查看文件状态<br>》git add 添加文件到“暂存区”<br>》git commit 文件名称   添加文件到”本地仓库“<br>注意：如果没有在commit后面加上 -m说明修改了什么， 会自动进入vim界面， 要求我们输入修改信息<br>按键盘上的 i 代表开始输入内容<br>输入完毕之后按 esc 然后按 ：wq<br>所以： 如果以后在终端中提交最好在后面加上-m<br>》注意： git中的add和SVN中的add不太一样， SVN中只需要add一次， 而git中每次新建或者修改之后都需要重新add</p>
<p>》1.为添加之前的颜色<br>红色 代表在”工作区“<br>》2.添加到暂存区之后的颜色<br>绿色 代码在”暂存区“</p>
<p>》注意： git默认没有简写指令<br>》注意： 一般情况下不建议自定义简写指令<br>》git中的简写称之为起别名</p>
<blockquote>
<p>查看log<br>》git log 文件名<br>》注意： GIt中的版本号是一个”40位“的哈希值， 而SVN中的版本号是一个递增的整数<br>》已经提交<br>git reset —hard HEAD^ 返回上一个版本<br>其中—hard代表强制重置<br>git reset —hard 版本号（只需要写前7位）<br>》未提交<br>git checkout 文件名 回退到上一次提交的版本<br>git reset —hard HEAD  回退到上一次提交的版, 注意HEAD后面没有尖号^</p>
</blockquote>
<p>c9ad690 HEAD@{0}: commit: main.c</p>
<p>7026f99 HEAD@{1}: commit: 输出结果</p>
<p>e950c89 HEAD@{2}: commit: 新增输入</p>
<p>c7bf91c HEAD@{3}: commit: 添加变量</p>
<p>cbd9e52 HEAD@{4}: commit: 删除print函数</p>
<p>45ea44d HEAD@{5}: commit: 添加了printf函数</p>
<p>0da06d8 HEAD@{6}: commit (initial): i</p>
<blockquote>
<p>git reflog  查看所有修改信息（所有版本）</p>
</blockquote>
<p>》查看文件被修改的什么地方<br>】    》git diff 文件名<br>》如果显示绿色代表新增<br>》如果显示红色代表删除</p>
<p>远程仓库<br>SVN需要一个单独的服务器<br>Git不需要： 文件中、U盘中、云上、github、OSChina…</p>
<p>1.新建git远程仓库<br>》git init —bare<br>注意： 这个仓库仅仅是用于管理代码， 不参与开发</p>
<p>2.项目经理初始化项目<br>》2.1先克隆一份空得仓库到本地<br>git clone /Users/apple/Desktop/working/公司远程仓库</p>
<p>》2.2忽略不需要加入版本控制器的文件以及文件夹<br>.gitignore<br>注意： 配置忽略文件只需要到github上搜索.gitignore拷贝别人写好的代码即可<br>配置.gitignore一定要在和.git隐藏文件夹同一级的目录下<br>》2.3生成好.gitignore文件之后， 还需要将.gitignore文件添加到版本控制<br>git add  .gitignore<br>git commit .gitignore -m””</p>
<p>》2.4新建项目<br>》 source conrol—&gt;commit  将代码提交到本地仓库<br>》source conrol—&gt;push 将代码提交到远程仓库</p>
<p>git中默认就会创建一个分支， 这个分支叫做origin/master， 相当于svn中的trunk</p>
<p>专业人员只需要在git仓库的hooks文件夹中写一些指令， 就可以完成自动测试（压力测试、自动测试、集成测试、冒烟测试、。。。）</p>
<p>》 和SVN一样， 如果服务器仓库的代码被修改了， 我们再提交代码也会报错。<br>fetch first == out of data</p>
<p>总结：<br>git和svn最大的区别<br>》1.git每次修改新增都需要add<br>》2.git每台电脑都有一个仓库<br>》3.git是先提交到本地仓库， 再提交到远程仓库</p>
<p>新人服务器搭建<br>1.新建一个新人服务器<br>2.初始化仓库<br>git init –bare<br>3.添加一个新的远程仓库<br>source control —&gt; master —&gt;config —&gt;remotes —&gt;add —&gt; add remote<br>4.将经理最新的代码提交到新人服务器<br>5.经理分配新人服务器的地址给新人</p>
<p>GIT的分支管理<br>》在本地代码库给项目打上一个标签<br>git tag -a v1.0 -m ‘Version 1.0’<br>》查看当前标签<br>git tag<br>注意： 此时此刻打上的这个标签仅仅是一个本地标签。（和服务器没有关系）<br>》将标签添推送到远程代码库中<br>git push origin v1.0</p>
<p>1.开发<br>2.发布<br>3.保存稳定版本<br>4.继续开发<br>5.出现bug<br>6.分配员工到分支上修复bug</p>
<blockquote>
<p>员工从服务器下载最新代码<br>》员工利用git checkout v1.0指令快速切换到1.0版本<br>》根据提示：开启一个新的分支开始修复代码<br>git checkout -b 1.0bug_fix</p>
</blockquote>
<p>7.合并修复后的代码到主线<br>8.备份稳定版本</p>
<p>通过Xcode将代码提交到github上， 把仓库放在github上</p>
<p>》1.注册一个github账号<br>》2.配置SSH Keys， 只要配置了SSH Keys就可以和github无缝衔接</p>
<p>》点击昵称来到个人主页<br>》点击主页中的设置（setting）<br>》点击SSH Keys<br>》点击 generating SSH keys</p>
<p>》1.检查本地的ssh keys<br>在“用户目录”下 ls -al ~/.ssh</p>
<p>2.如果文件夹不存在需要手动创建一个<br>mkdir .ssh</p>
<p>3.根据github的提示2生成ssh keys<br>在.ssh目录下执行 ssh-keygen -t rsa -C “your_email@example.com”<br>输入完成之后连续按下回车， 知道出现牛逼的图形位置</p>
<p>4.生成完公钥和私钥之后输入<br>ls -la查看是否生成成功   id_rsa（私钥） id_rsa.pub(公钥)</p>
<p>5.根据提示3获得公钥<br>pbcopy &lt; ~/.ssh/id_rsa.pub</p>
<p>6.点击 setting —》 ssh key —&gt;add ssh key<br>将刚才获取到得公钥添加进去</p>
<p>7.更具github第4步提示， 验证公钥<br>验证成功网页上的灰色圆点会变成绿色</p>
<p>8.拷贝到公钥之后打开github主页<br>》点击仓库（Repositories）<br>》再点击new来到github创建仓库界面</p>
<p>9.通过github提供的地址下载一个空得仓库到本地<br>》创建一个新的项目到本地仓库文件夹中<br>》利用Xcode提交代码到github<br>》注意： 要求输入用户名密码时候， 输入的是github上显示的昵称而不是登录账号</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[StaticLibrary]]></title>
      <url>http://yoursite.com/2017/02/20/StaticLibrary/</url>
      <content type="html"><![CDATA[<h3 id="一-为什么要做静态库"><a href="#一-为什么要做静态库" class="headerlink" title="一. 为什么要做静态库"></a>一. 为什么要做静态库</h3><ol>
<li>国内的企业，掌握有核心技术，同时是又希望更多的程序员来使用其技术，因此采用”闭源”的方式开发使用<br>例如：百度地图，友盟，JPush等</li>
<li>在企业开发中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，也会提供静态库给程序员使用</li>
</ol>
<h3 id="二-静态库的特点"><a href="#二-静态库的特点" class="headerlink" title="二. 静态库的特点"></a>二. 静态库的特点</h3><p>.a + .h</p>
<h3 id="三-静态库简单演练"><a href="#三-静态库简单演练" class="headerlink" title="三. 静态库简单演练"></a>三. 静态库简单演练</h3><ul>
<li>新建CZTools项目</li>
<li>创建一个类方法，实现一个简单的加法</li>
<li>编译<br> 注意，在编译静态库时，需要编译两个版本 -&gt; 真机(arm) | 模拟器(i386)</li>
<li>新建项目将编译生成的.a + .h拖到项目中使用</li>
</ul>
<h3 id="四-静态库中的资源包的使用"><a href="#四-静态库中的资源包的使用" class="headerlink" title="四. 静态库中的资源包的使用"></a>四. 静态库中的资源包的使用</h3><p>问题：有些第三方库会使用到一些图片素材，例如公司的logo等。</p>
<p>但是由于Xcode默认在编译时会把所有的素材文件导入到mainBundle中，为了避免与使用静态库的程序冲突。<br>在静态库中如果要使用图片素材，会利用bundle的手段</p>
<ul>
<li>建立bundle，并且向其中添加图片</li>
<li>创建一个类方法，返回图片</li>
<li>编译</li>
<li>调用方如果需要使用，需要导入 .h + .a + XXX.bundle</li>
</ul>
<h3 id="五-静态库中的自定义视图"><a href="#五-静态库中的自定义视图" class="headerlink" title="五. 静态库中的自定义视图"></a>五. 静态库中的自定义视图</h3><p>问题：程序需要测试<br>静态库如何测试呢？</p>
<p>创建复合项目</p>
<ul>
<li>复习块代码传值</li>
</ul>
<h3 id="六-静态库的使用"><a href="#六-静态库的使用" class="headerlink" title="六. 静态库的使用"></a>六. 静态库的使用</h3><p>新建项目将编译生成的.a + .h拖到项目中使用</p>
<h3 id="七-静态库的种类"><a href="#七-静态库的种类" class="headerlink" title="七. 静态库的种类"></a>七. 静态库的种类</h3><p>静态库文件的版本(4种)<br>1.真机-Debug版本<br>2.真机-Release版本<br>3.模拟器-Debug版本<br>4.模拟器-Release版本</p>
<p>调试版本 VS 发布版本</p>
<ul>
<li>调试版本会包含完整的符号信息，以方便调试</li>
<li>调试版本不会对代码进行优化</li>
<li>发布版本不会包含完整的符号信息</li>
<li>发布版本的执行代码是进行过优化的</li>
<li>发布版本的大小会比调试版本的略小</li>
<li>在执行速度方面，调试版本会更快些，但不意味着会有显著的提升</li>
</ul>
<h3 id="八-静态库的合并"><a href="#八-静态库的合并" class="headerlink" title="八. 静态库的合并"></a>八. 静态库的合并</h3><p>检测.a的类型<br>$ lipo -info libCZTools.a</p>
<p> 合并.a<br>lipo -create Debug-iphoneos/libCZTools.a Debug-iphonesimulator/libCZTools.a -output libCZTools.a</p>
<p>合并.a的好处，开发过程中既可以在真机上调试，也可以在模拟器上调试<br>合并.a的坏处，如果静态库太大，合并打包后，会非常大，因此很多第三方的静态库的.a是区分版本的<br>今后在使用.a时一定注意版本</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[const、static、extern简介]]></title>
      <url>http://yoursite.com/2017/02/20/const-static-extern%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="const、static、extern简介"><a href="#const、static、extern简介" class="headerlink" title="const、static、extern简介"></a>const、static、extern简介</h3><h3 id="一、const与宏的区别（面试题）"><a href="#一、const与宏的区别（面试题）" class="headerlink" title="一、const与宏的区别（面试题）:"></a>一、const与宏的区别（面试题）:</h3><ul>
<li><code>const简介</code>:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。</li>
<li><code>编译时刻</code>:宏是预编译（编译之前处理），const是编译阶段。</li>
<li><code>编译检查</code>:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>
<li><code>宏的好处</code>:宏能定义一些函数，方法。 const不能。</li>
<li><code>宏的坏处</code>:使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>
</ul>
<p>注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。<br><img src="/Users/yuanzheng/Desktop/项目准备/课堂笔记/Const/Snip20151014_1.png" alt=""></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常见的常量：抽成宏</span></div><div class="line"><span class="meta">#define XMGAccount @<span class="meta-string">"account"</span></span></div><div class="line"></div><div class="line"><span class="meta">#define XMGUserDefault [NSUserDefaults standardUserDefaults]</span></div><div class="line"></div><div class="line"><span class="comment">// 字符串常量</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> account = <span class="string">@"account"</span>;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line"><span class="comment">// 偏好设置存储</span></div><div class="line"><span class="comment">// 使用宏</span></div><div class="line">[XMGUserDefault setValue:<span class="string">@"123"</span> forKey:XMGAccount];</div><div class="line"></div><div class="line"><span class="comment">// 使用const常量</span></div><div class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setValue:<span class="string">@"123"</span> forKey:account];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、const作用：限制类型"><a href="#二、const作用：限制类型" class="headerlink" title="二、const作用：限制类型"></a>二、const作用：限制类型</h3><ul>
<li>1.const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）</li>
<li><p>2.被const修饰的变量是只读的。</p>
</li>
<li><p><code>const基本使用</code></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line"><span class="comment">// 定义变量</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// 允许修改值</span></div><div class="line">a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// const两种用法</span></div><div class="line"><span class="comment">// const:修饰基本变量p</span></div><div class="line"><span class="comment">// 这两种写法是一样的，const只修饰右边的基本变量b</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></div><div class="line"></div><div class="line"><span class="comment">// 不允许修改值</span></div><div class="line">b = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// const:修饰指针变量*p，带*的变量，就是指针变量.</span></div><div class="line"><span class="comment">// 定义一个指向int类型的指针变量，指向a的地址</span></div><div class="line"><span class="keyword">int</span> *p = &amp;a;</div><div class="line"></div><div class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</div><div class="line"></div><div class="line">p = &amp;c;</div><div class="line"></div><div class="line"><span class="comment">// 允许修改p指向的地址，</span></div><div class="line"><span class="comment">// 允许修改p访问内存空间的值</span></div><div class="line">*p = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// const修饰指针变量访问的内存空间，修饰的是右边*p1，</span></div><div class="line"><span class="comment">// 两种方式一样</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1; <span class="comment">// *p1：常量 p1:变量</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1; <span class="comment">// *p1：常量 p1:变量</span></div><div class="line"></div><div class="line"><span class="comment">// const修饰指针变量p1</span></div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1:变量 p1:常量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 第一个const修饰*p1 第二个const修饰 p1</span></div><div class="line"><span class="comment">// 两种方式一样</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1：常量 p1：常量</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p1;  <span class="comment">// *p1：常量 p1：常量</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三、const开发中使用场景"><a href="#三、const开发中使用场景" class="headerlink" title="三、const开发中使用场景:"></a>三、const开发中使用场景:</h3><ul>
<li>1.当一个方法参数只读</li>
<li>2.定义只读全局变量</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"><span class="comment">// 定义只读全局常量</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> str  = <span class="string">@"123"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 当一个方法的参数，只读.</span></div><div class="line">- (<span class="keyword">void</span>)test:(<span class="built_in">NSString</span> * <span class="keyword">const</span>)name</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 指针只读,不能通过指针修改值</span></div><div class="line">- (<span class="keyword">void</span>)test1:(<span class="keyword">int</span> <span class="keyword">const</span> *)a&#123;</div><div class="line"></div><div class="line"><span class="comment">//    *a = 10;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 基本数据类型只读</span></div><div class="line">- (<span class="keyword">void</span>)test2:(<span class="keyword">int</span> <span class="keyword">const</span>)a&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="四、static和extern简单使用-要使用一个东西，先了解其作用"><a href="#四、static和extern简单使用-要使用一个东西，先了解其作用" class="headerlink" title="四、static和extern简单使用(要使用一个东西，先了解其作用)"></a>四、static和extern简单使用(要使用一个东西，先了解其作用)</h3><ul>
<li><code>static作用</code>:</li>
<li>修饰局部变量：</li>
</ul>
<p>1.延长局部变量的生命周期,程序结束才会销毁。</p>
<p>2.局部变量只会生成一份内存,只会初始化一次。</p>
<ul>
<li>修饰全局变量</li>
</ul>
<p>1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改</p>
<ul>
<li><code>extern作用</code>:</li>
<li>只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</li>
<li><code>extern工作原理</code>:</li>
<li>先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量：只有一份内存，所有文件共享，与extern联合使用。</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// static修饰全局变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)test</div><div class="line">&#123;</div><div class="line"><span class="comment">// static修饰局部变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">0</span>;</div><div class="line">age++;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line"></div><div class="line"></div><div class="line">    [<span class="keyword">self</span> test];</div><div class="line">    [<span class="keyword">self</span> test];</div><div class="line"></div><div class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,age);</div><div class="line">&#125;</div><div class="line">I</div></pre></td></tr></table></figure>
<h3 id="五、static与const联合使用"><a href="#五、static与const联合使用" class="headerlink" title="五、static与const联合使用"></a>五、static与const联合使用</h3><ul>
<li>static与const作用:声明一个只读的静态变量</li>
<li>开发使用场景:在<code>一个文件中</code>经常使用的字符串常量，可以使用static与const组合</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开发中常用static修饰全局变量,只改变作用域</span></div><div class="line"></div><div class="line"><span class="comment">// 为什么要改变全局变量作用域，防止重复声明全局变量。</span></div><div class="line"></div><div class="line"><span class="comment">// 开发中声明的全局变量，有些不希望外界改动，只允许读取。</span></div><div class="line"></div><div class="line"><span class="comment">// 比如一个基本数据类型不希望别人改动</span></div><div class="line"></div><div class="line"><span class="comment">// 声明一个静态的全局只读常量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// staic和const联合的作用:声明一个静态的全局只读常量</span></div><div class="line"></div><div class="line"><span class="comment">// iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量.</span></div><div class="line"></div><div class="line"><span class="comment">// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。</span></div><div class="line"><span class="keyword">static</span>  <span class="built_in">NSString</span> * <span class="keyword">const</span> key = <span class="string">@"name"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。</span></div><div class="line"></div><div class="line"><span class="keyword">static</span>  <span class="built_in">NSString</span> <span class="keyword">const</span> *key1 = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure>
<h3 id="六、extern与const联合使用"><a href="#六、extern与const联合使用" class="headerlink" title="六、extern与const联合使用"></a>六、extern与const联合使用</h3><ul>
<li>开发中使用场景:在<code>多个文件中</code>经常使用的同一个字符串常量，可以使用extern与const组合。</li>
<li>原因:</li>
<li>static与const组合：在每个文件都需要定义一份静态全局变量。</li>
<li>extern与const组合:只需要定义一份全局变量，多个文件共享。</li>
<li>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</li>
</ul>
<ul>
<li>GlobeConst.h</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> nameKey = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>GlobeConst.m</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> nameKey = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Runtime]]></title>
      <url>http://yoursite.com/2017/02/20/Runtime/</url>
      <content type="html"><![CDATA[<h3 id="一、runtime简介"><a href="#一、runtime简介" class="headerlink" title="一、runtime简介"></a>一、runtime简介</h3><ul>
<li>RunTime简称运行时。OC就是<code>运行时机制</code>，也就是在运行时候的一些机制，其中最主要的是消息机制。</li>
<li>对于C语言，<code>函数的调用在编译的时候会决定调用哪个函数</code>。</li>
<li>对于OC的函数，属于<code>动态调用过程</code>，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>
<li>事实证明：</li>
<li>在编译阶段，OC可以<code>调用任何函数</code>，即使这个函数并未实现，只要声明过就不会报错。</li>
<li>在编译阶段，C语言调用<code>未实现的函数</code>就会报错。</li>
</ul>
<h3 id="二、runtime作用"><a href="#二、runtime作用" class="headerlink" title="二、runtime作用"></a>二、runtime作用</h3><h4 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1.发送消息"></a>1.发送消息</h4><ul>
<li>方法调用的本质，就是让对象发送消息。</li>
<li>objc_msgSend,只有对象才能发送消息，因此以objc开头.</li>
<li>使用<code>消息机制</code>前提，必须导入#import <objc message.h=""></objc></li>
<li>消息机制简单使用</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建person对象</span></div><div class="line">Person *p = [[Person alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 调用对象方法</span></div><div class="line">[p eat];</div><div class="line"></div><div class="line"><span class="comment">// 本质：让对象发送消息</span></div><div class="line">objc_msgSend(p, <span class="keyword">@selector</span>(eat));</div><div class="line"></div><div class="line"><span class="comment">// 调用类方法的方式：两种</span></div><div class="line"><span class="comment">// 第一种通过类名调用</span></div><div class="line">[Person eat];</div><div class="line"><span class="comment">// 第二种通过类对象调用</span></div><div class="line">[[Person <span class="keyword">class</span>] eat];</div><div class="line"></div><div class="line"><span class="comment">// 用类名调用类方法，底层会自动把类名转换成类对象调用</span></div><div class="line"><span class="comment">// 本质：让类对象发送消息</span></div><div class="line">objc_msgSend([Person <span class="keyword">class</span>], <span class="keyword">@selector</span>(eat));</div></pre></td></tr></table></figure>
<ul>
<li>消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现</li>
<li><img src="Snip20151013_4.png" alt=""></li>
</ul>
<h4 id="2-交换方法"><a href="#2-交换方法" class="headerlink" title="2.交换方法"></a>2.交换方法</h4><ul>
<li>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。</li>
<li>方式一:继承系统的类，重写方法.</li>
<li>方式二:使用runtime,交换方法.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。</span></div><div class="line">    <span class="comment">// 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;</span></div><div class="line">    <span class="comment">// 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"123"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">Image</span>)</span></div><div class="line"><span class="comment">// 加载分类到内存的时候调用</span></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 交换方法</span></div><div class="line">    <span class="comment">// 获取imageWithName方法地址</span></div><div class="line">    Method imageWithName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageWithName:));</div><div class="line"></div><div class="line">    <span class="comment">// 获取imageWithName方法地址</span></div><div class="line">    Method imageName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageNamed:));</div><div class="line"></div><div class="line">    <span class="comment">// 交换方法地址，相当于交换实现方式</span></div><div class="line">    method_exchangeImplementations(imageWithName, imageName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</span></div><div class="line"></div><div class="line"><span class="comment">// 既能加载图片又能打印</span></div><div class="line">+ (<span class="keyword">instancetype</span>)imageWithName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 这里调用imageWithName，相当于调用imageName</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageWithName:name];</div><div class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"加载空的图片"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>交换原理：</li>
<li><p>交换之前：<br><img src="Snip20151013_2.png" alt=""></p>
</li>
<li><p>交换之后：<br><img src="Snip20151013_3.png" alt=""></p>
</li>
</ul>
<h4 id="3-动态添加方法"><a href="#3-动态添加方法" class="headerlink" title="3.动态添加方法"></a>3.动态添加方法</h4><ul>
<li>开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。</li>
<li>经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。</li>
<li>简单使用</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    Person *p = [[Person alloc] init];</div><div class="line">    <span class="comment">// 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span></div><div class="line">    <span class="comment">// 动态添加方法就不会报错</span></div><div class="line">    [p performSelector:<span class="keyword">@selector</span>(eat)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"><span class="comment">// void(*)()</span></div><div class="line"><span class="comment">// 默认方法都有两个隐式参数，</span></div><div class="line"><span class="keyword">void</span> eat(<span class="keyword">id</span> <span class="keyword">self</span>,SEL sel)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,<span class="keyword">self</span>,<span class="built_in">NSStringFromSelector</span>(sel));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></div><div class="line"><span class="comment">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(eat)) &#123;</div><div class="line">        <span class="comment">// 动态添加eat方法</span></div><div class="line">        <span class="comment">// 第一个参数：给哪个类添加方法</span></div><div class="line">        <span class="comment">// 第二个参数：添加方法的方法编号</span></div><div class="line">        <span class="comment">// 第三个参数：添加方法的函数实现（函数地址）</span></div><div class="line">        <span class="comment">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></div><div class="line">        class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(eat), eat, <span class="string">"v@:"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="4-给分类添加属性"><a href="#4-给分类添加属性" class="headerlink" title="4.给分类添加属性"></a>4.给分类添加属性</h4><ul>
<li>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 给系统NSObject类动态添加属性name</span></div><div class="line">    <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    objc.name = <span class="string">@"小码哥"</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,objc.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 定义关联的key</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"name"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Property</span>)</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 根据关联的key，获取关联的值。</span></div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 第一个参数：给哪个对象添加关联</span></div><div class="line">    <span class="comment">// 第二个参数：关联的key，通过这个key获取</span></div><div class="line">    <span class="comment">// 第三个参数：关联的value</span></div><div class="line">    <span class="comment">// 第四个参数:关联的策略</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="5-字典转模型"><a href="#5-字典转模型" class="headerlink" title="5.字典转模型"></a>5.字典转模型</h4><ul>
<li>设计模型：字典转模型的第一步</li>
<li>模型属性，通常需要跟字典中的key一一对应</li>
<li>问题：一个一个的生成模型属性，很慢？</li>
<li>需求：能不能自动根据一个字典，生成对应的属性。</li>
<li>解决：提供一个分类，专门根据字典生成对应的属性字符串。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Log</span>)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 自动打印属性字符串</span></div><div class="line">+ (<span class="keyword">void</span>)resolveDict:(<span class="built_in">NSDictionary</span> *)dict&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 拼接属性字符串代码</span></div><div class="line">    <span class="built_in">NSMutableString</span> *strM = [<span class="built_in">NSMutableString</span> string];</div><div class="line"></div><div class="line">    <span class="comment">// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</span></div><div class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 类型经常变，抽出来</span></div><div class="line">    <span class="built_in">NSString</span> *type;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFString"</span>)]) &#123;</div><div class="line">        type = <span class="string">@"NSString"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFArray"</span>)])&#123;</div><div class="line">        type = <span class="string">@"NSArray"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFNumber"</span>)])&#123;</div><div class="line">        type = <span class="string">@"int"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFDictionary"</span>)])&#123;</div><div class="line">        type = <span class="string">@"NSDictionary"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 属性字符串</span></div><div class="line">    <span class="built_in">NSString</span> *str;</div><div class="line">    <span class="keyword">if</span> ([type containsString:<span class="string">@"NS"</span>]) &#123;</div><div class="line">    str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, strong) %@ *%@;"</span>,type,key];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">    str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, assign) %@ %@;"</span>,type,key];</div><div class="line">&#125;</div><div class="line">    <span class="comment">// 每生成属性字符串，就自动换行。</span></div><div class="line">    [strM appendFormat:<span class="string">@"\n%@\n"</span>,str];</div><div class="line"></div><div class="line">    &#125;];</div><div class="line">    <span class="comment">// 把拼接好的字符串打印出来，就好了。</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strM);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>字典转模型的方式一：KVC</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Status</span></span></div><div class="line"></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)statusWithDict:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    Status *status = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    [status setValuesForKeysWithDictionary:dict];</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。</li>
<li>如果不一致，就会调用<code>[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]</code><br>报<code>key</code>找不到的错。    </li>
<li>分析:模型中的属性和字典的key不一一对应，系统就会调用<code>setValue:forUndefinedKey:</code>报错。</li>
<li>解决:重写对象的<code>setValue:forUndefinedKey:</code>,把系统的方法覆盖，<br>就能继续使用KVC，字典转模型了。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>字典转模型的方式二：Runtime</li>
<li>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。</li>
<li>步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 解析Plist文件</span></div><div class="line">    <span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"status.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSDictionary</span> *statusDict = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:filePath];</div><div class="line">    <span class="comment">// 获取字典数组</span></div><div class="line">    <span class="built_in">NSArray</span> *dictArr = statusDict[<span class="string">@"statuses"</span>];</div><div class="line">    <span class="comment">// 自动生成模型的属性字符串</span></div><div class="line">    <span class="comment">// [NSObject resolveDict:dictArr[0][@"user"]];</span></div><div class="line">    _statuses = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">    <span class="comment">// 遍历字典数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> dictArr) &#123;</div><div class="line">        Status *status = [Status modelWithDict:dict];</div><div class="line">        [_statuses addObject:status];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 测试数据</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,_statuses,[_statuses[<span class="number">0</span>] user]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Model</span>)</span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 思路：遍历模型中所有属性-》使用运行时</span></div><div class="line"></div><div class="line">    <span class="comment">// 0.创建对应的对象</span></div><div class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 1.利用runtime给对象中的成员属性赋值</span></div><div class="line"></div><div class="line">    <span class="comment">// class_copyIvarList:获取类中的所有成员属性</span></div><div class="line">    <span class="comment">// Ivar：成员属性的意思</span></div><div class="line">    <span class="comment">// 第一个参数：表示获取哪个类中的成员属性</span></div><div class="line">    <span class="comment">// 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</span></div><div class="line">    <span class="comment">// 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</span></div><div class="line">    <span class="comment">/* 类似下面这种写法</span></div><div class="line"></div><div class="line">    Ivar ivar;</div><div class="line">    Ivar ivar1;</div><div class="line">    Ivar ivar2;</div><div class="line">    // 定义一个ivar的数组a</div><div class="line">    Ivar a[] = &#123;ivar,ivar1,ivar2&#125;;</div><div class="line"></div><div class="line">    // 用一个Ivar *指针指向数组第一个元素</div><div class="line">    Ivar *ivarList = a;</div><div class="line"></div><div class="line">    // 根据指针访问数组第一个元素</div><div class="line">    ivarList[0];</div><div class="line"></div><div class="line">    */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="comment">// 获取类中的所有成员属性</span></div><div class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 根据角标，从数组取出对应的成员属性</span></div><div class="line">                Ivar ivar = ivarList[i];</div><div class="line"></div><div class="line">                <span class="comment">// 获取成员属性名</span></div><div class="line">                <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">                <span class="comment">// 处理成员属性名-&gt;字典中的key</span></div><div class="line">                <span class="comment">// 从第一个角标开始截取</span></div><div class="line">                <span class="built_in">NSString</span> *key = [name substringFromIndex:<span class="number">1</span>];</div><div class="line"></div><div class="line">                <span class="comment">// 根据成员属性名去字典中查找对应的value</span></div><div class="line">                <span class="keyword">id</span> value = dict[key];</div><div class="line"></div><div class="line">                <span class="comment">// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span></div><div class="line">                <span class="comment">// 判断下value是否是字典</span></div><div class="line">                <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                    <span class="comment">// 字典转模型</span></div><div class="line">                    <span class="comment">// 获取模型的类对象，调用modelWithDict</span></div><div class="line">                    <span class="comment">// 模型的类名已知，就是成员属性的类型</span></div><div class="line"></div><div class="line">                    <span class="comment">// 获取成员属性类型</span></div><div class="line">                    <span class="built_in">NSString</span> *type = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class="line">                    <span class="comment">// 生成的是这种@"@\"User\"" 类型 -》 @"User"  在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符</span></div><div class="line">                    <span class="comment">// 裁剪类型字符串</span></div><div class="line">                    <span class="built_in">NSRange</span> range = [type rangeOfString:<span class="string">@"\""</span>];</div><div class="line"></div><div class="line">                    type = [type substringFromIndex:range.location + range.length];</div><div class="line"></div><div class="line">                    range = [type rangeOfString:<span class="string">@"\""</span>];</div><div class="line"></div><div class="line">                    <span class="comment">// 裁剪到哪个角标，不包括当前角标</span></div><div class="line">                    type = [type substringToIndex:range.location];</div><div class="line"></div><div class="line">                    <span class="comment">// 根据字符串类名生成类对象</span></div><div class="line">                    Class modelClass = <span class="built_in">NSClassFromString</span>(type);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (modelClass) &#123; <span class="comment">// 有对应的模型才需要转</span></div><div class="line">                        <span class="comment">// 把字典转模型</span></div><div class="line">                        value  =  [modelClass modelWithDict:value];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span></div><div class="line">        <span class="comment">// 判断值是否是数组</span></div><div class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="comment">// 判断对应类有没有实现字典数组转模型数组的协议</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(arrayContainModelClass)]) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 转换成id类型，就能调用任何对象的方法</span></div><div class="line">                <span class="keyword">id</span> idSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 获取数组中字典对应的模型</span></div><div class="line">                <span class="built_in">NSString</span> *type =  [idSelf arrayContainModelClass][key];</div><div class="line"></div><div class="line">                <span class="comment">// 生成模型</span></div><div class="line">                Class classModel = <span class="built_in">NSClassFromString</span>(type);</div><div class="line">                <span class="built_in">NSMutableArray</span> *arrM = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">                <span class="comment">// 遍历字典数组，生成模型数组</span></div><div class="line">                <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> value) &#123;</div><div class="line">                    <span class="comment">// 字典转模型</span></div><div class="line">                    <span class="keyword">id</span> model =  [classModel modelWithDict:dict];</div><div class="line">                    [arrM addObject:model];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 把模型数组赋值给value</span></div><div class="line">                value = arrM;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (value) &#123; <span class="comment">// 有值，才需要给模型的属性赋值</span></div><div class="line">            <span class="comment">// 利用KVC给模型中的属性赋值</span></div><div class="line">            [objc setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> objc;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ReactiveCocoa]]></title>
      <url>http://yoursite.com/2017/02/19/ReactiveCocoa/</url>
      <content type="html"><![CDATA[<h3 id="1-ReactiveCocoa简介"><a href="#1-ReactiveCocoa简介" class="headerlink" title="1.ReactiveCocoa简介"></a>1.ReactiveCocoa简介</h3><p>ReactiveCocoa（简称为<code>RAC</code>）,是由<code>Github</code>开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。</p>
<h3 id="2-ReactiveCocoa作用"><a href="#2-ReactiveCocoa作用" class="headerlink" title="2.ReactiveCocoa作用"></a>2.ReactiveCocoa作用</h3><ul>
<li>在我们iOS开发过程中，当某些事件响应的时候，需要处理某些业务逻辑,这些事件都用不同的方式来处理。</li>
<li>比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO等系统提供的方式。</li>
<li>其实这些事件，都可以通过RAC处理</li>
<li>ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中<code>高聚合，低耦合</code>的思想。</li>
</ul>
<h3 id="3-编程思想"><a href="#3-编程思想" class="headerlink" title="3.编程思想"></a>3.编程思想</h3><p>在开发中我们也不能太依赖于某个框架，否则这个框架不更新了，导致项目后期没办法维护，比如之前Facebook提供的<code>Three20框架</code>，在当时也是神器，但是后来不更新了，也就没什么人用了。因此我感觉学习一个框架，还是有必要了解它的<code>编程思想</code>。</p>
<p><code>编程思想的由来</code>：在开发中我们会遇见各种各样的需求，经常会思考如何快速的完成这些需求，这样就会慢慢形成快速完成这些需求的思想。</p>
<p>先简单介绍下目前咱们已知的<code>编程思想</code>。</p>
<p>3.1 <code>面向过程</code>：处理事情以过程为核心，一步一步的实现。</p>
<p>3.2 <code>面向对象</code>：万物皆对象</p>
<p>3.3 <code>链式编程思想</code>：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3)</p>
<ul>
<li><p><code>链式编程特点</code>：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）</p>
</li>
<li><p><code>代表</code>：masonry框架。</p>
</li>
<li><p><code>练习一</code>:模仿masonry，写一个加法计算器，练习链式编程思想。</p>
</li>
</ul>
<p>3.4 <code>响应式编程思想</code>：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。</p>
<ul>
<li><p><code>代表</code>：KVO运用。</p>
</li>
<li><p><code>练习二</code>:KVO底层实现。</p>
</li>
</ul>
<p>3.5 <code>函数式编程思想</code>：是把操作尽量写成一系列嵌套的函数或者方法调用。</p>
<ul>
<li><code>函数式编程本质</code>:就是往方法中传入Block,方法中嵌套Block调用，把代码聚合起来管理</li>
<li><p><code>函数式编程特点</code>：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）</p>
</li>
<li><p><code>代表</code>：ReactiveCocoa。</p>
</li>
<li><p><code>练习三</code>:用函数式编程实现，写一个加法计算器,并且加法计算器自带判断是否等于某个值.</p>
</li>
</ul>
<h3 id="4-ReactiveCocoa编程思想"><a href="#4-ReactiveCocoa编程思想" class="headerlink" title="4.ReactiveCocoa编程思想"></a>4.ReactiveCocoa编程思想</h3><p>ReactiveCocoa结合了几种编程风格：</p>
<p><code>函数式编程（Functional Programming）</code></p>
<p><code>响应式编程（Reactive Programming）</code></p>
<p>所以，你可能听说过ReactiveCocoa被描述为函数响应式编程（FRP）框架。</p>
<p>以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。</p>
<h3 id="5-如何导入ReactiveCocoa框架"><a href="#5-如何导入ReactiveCocoa框架" class="headerlink" title="5.如何导入ReactiveCocoa框架"></a>5.如何导入ReactiveCocoa框架</h3><p>通常都会使用CocoaPods（用于管理第三方框架的插件）帮助我们导入。</p>
<p>CocoaPods教程（<a href="http://code4app.com/article/cocoapods-install-usage）" target="_blank" rel="external">http://code4app.com/article/cocoapods-install-usage）</a></p>
<p><code>练习四</code>:创建一个新的工程，演示下，框架的导入。</p>
<p><code>注意</code>：</p>
<ul>
<li>podfile如果只描述pod ‘ReactiveCocoa’, ‘~&gt; 4.0.2-alpha-1’，会导入不成功<br><img src="Snip20150926_1.png" alt=""></li>
<li>报错信息<br><img src="Snip20150926_2.png" alt=""></li>
<li>需要在podfile加上use_frameworks，重新pod install 才能导入成功。<br><img src="Snip20150926_3.png" alt=""></li>
</ul>
<h3 id="6-ReactiveCocoa常见类。"><a href="#6-ReactiveCocoa常见类。" class="headerlink" title="6.ReactiveCocoa常见类。"></a>6.ReactiveCocoa常见类。</h3><p>学习框架首要之处:个人认为先要搞清楚框架中常用的类，在RAC中最核心的类RACSiganl,搞定这个类就能用ReactiveCocoa开发了。</p>
<p><code>练习五</code>:介绍常见类</p>
<p><code>RACSiganl</code>:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>
<ul>
<li><p>信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</p>
</li>
<li><p>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</p>
</li>
<li><p>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。</p>
</li>
<li><p><code>RACSiganl简单使用:</code></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACSignal使用步骤：</span></div><div class="line"><span class="comment">// 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span></div><div class="line"><span class="comment">// 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 3.发送信号 - (void)sendNext:(id)value</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RACSignal底层实现：</span></div><div class="line"><span class="comment">// 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。</span></div><div class="line"><span class="comment">// 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock</span></div><div class="line"><span class="comment">// 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。</span></div><div class="line"><span class="comment">// 2.1 subscribeNext内部会调用siganl的didSubscribe</span></div><div class="line"><span class="comment">// 3.siganl的didSubscribe中调用[subscriber sendNext:@1];</span></div><div class="line"><span class="comment">// 3.1 sendNext底层其实就是执行subscriber的nextBlock</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"><span class="comment">// block调用时刻：每当有订阅者订阅信号，就会调用block。</span></div><div class="line"></div><div class="line"><span class="comment">// 2.发送信号</span></div><div class="line">[subscriber sendNext:@<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</span></div><div class="line">[subscriber sendCompleted];</div><div class="line"></div><div class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line"></div><div class="line"><span class="comment">// block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</span></div><div class="line"></div><div class="line"><span class="comment">// 执行完Block后，当前信号就不在被订阅了。</span></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"信号被销毁"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号,才会激活信号.</span></div><div class="line">[siganl subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// block调用时刻：每当有信号发出数据，就会调用block.</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"接收到数据:%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>RACSubscriber</code>:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</p>
<p><code>RACDisposable</code>:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</p>
<ul>
<li><code>使用场景</code>:不想监听某个信号时，可以通过它主动取消订阅信号。</li>
</ul>
<p><code>RACSubject</code>:RACSubject:信号提供者，自己可以充当信号，又能发送信号。</p>
<ul>
<li><code>使用场景</code>:通常用来代替代理，有了它，就不必要定义代理了。</li>
</ul>
<p><code>RACReplaySubject</code>:重复提供信号类，RACSubject的子类。</p>
<ul>
<li><code>RACReplaySubject</code>与<code>RACSubject</code>区别:</li>
<li>RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。</li>
<li><code>使用场景一</code>:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li>
<li><p><code>使用场景二</code>:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。</p>
</li>
<li><p><code>RACSubject和RACReplaySubject简单使用:</code></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACSubject使用步骤</span></div><div class="line"><span class="comment">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span></div><div class="line"><span class="comment">// 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 3.发送信号 sendNext:(id)value</span></div><div class="line"></div><div class="line"><span class="comment">// RACSubject:底层实现和RACSignal不一样。</span></div><div class="line"><span class="comment">// 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</span></div><div class="line"><span class="comment">// 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSubject *subject = [RACSubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// block调用时刻：当信号发出新值，就会调用.</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者%@"</span>,x);</div><div class="line">&#125;];</div><div class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// block调用时刻：当信号发出新值，就会调用.</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.发送信号</span></div><div class="line">[subject sendNext:<span class="string">@"1"</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RACReplaySubject使用步骤:</span></div><div class="line"><span class="comment">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span></div><div class="line"><span class="comment">// 2.可以先订阅信号，也可以先发送信号。</span></div><div class="line"><span class="comment">// 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 2.2 发送信号 sendNext:(id)value</span></div><div class="line"></div><div class="line"><span class="comment">// RACReplaySubject:底层实现和RACSubject不一样。</span></div><div class="line"><span class="comment">// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span></div><div class="line"><span class="comment">// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock</span></div><div class="line"></div><div class="line"><span class="comment">// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。</span></div><div class="line"><span class="comment">// 也就是先保存值，在订阅值。</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACReplaySubject *replaySubject = [RACReplaySubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 2.发送信号</span></div><div class="line">[replaySubject sendNext:@<span class="number">1</span>];</div><div class="line">[replaySubject sendNext:@<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号</span></div><div class="line">[replaySubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者接收到的数据%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 订阅信号</span></div><div class="line">[replaySubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者接收到的数据%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li><code>RACSubject替换代理</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 需求:</span></div><div class="line"><span class="comment">// 1.给当前控制器添加一个按钮，modal到另一个控制器界面</span></div><div class="line"><span class="comment">// 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器</span></div><div class="line"></div><div class="line">步骤一：在第二个控制器.h，添加一个RACSubject代替代理。</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TwoViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSubject *delegateSignal;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">步骤二：监听第二个控制器按钮点击</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TwoViewController</span></span></div><div class="line">- (<span class="keyword">IBAction</span>)notice:(<span class="keyword">id</span>)sender &#123;</div><div class="line"><span class="comment">// 通知第一个控制器，告诉它，按钮被点了</span></div><div class="line"></div><div class="line"><span class="comment">// 通知代理</span></div><div class="line"><span class="comment">// 判断代理信号是否有值</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.delegateSignal) &#123;</div><div class="line"><span class="comment">// 有值，才需要通知</span></div><div class="line">[<span class="keyword">self</span>.delegateSignal sendNext:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OneViewController</span></span></div><div class="line">- (<span class="keyword">IBAction</span>)btnClick:(<span class="keyword">id</span>)sender &#123;</div><div class="line"></div><div class="line"><span class="comment">// 创建第二个控制器</span></div><div class="line">TwoViewController *twoVc = [[TwoViewController alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 设置代理信号</span></div><div class="line">twoVc.delegateSignal = [RACSubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 订阅代理信号</span></div><div class="line">[twoVc.delegateSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"点击了通知按钮"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 跳转到第二个控制器</span></div><div class="line">[<span class="keyword">self</span> presentViewController:twoVc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>RACTuple</code>:元组类,类似NSArray,用来包装值.</p>
<p><code>RACSequence</code>:RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。</p>
<p><code>使用场景</code>：1.字典转模型</p>
<p><code>RACSequence和RACTuple简单使用</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.遍历数组</span></div><div class="line"><span class="built_in">NSArray</span> *numbers = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// 这里其实是三步</span></div><div class="line"><span class="comment">// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence</span></div><div class="line"><span class="comment">// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal</span></div><div class="line"><span class="comment">// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。</span></div><div class="line">[numbers.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)</span></div><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"name"</span>:<span class="string">@"xmg"</span>,<span class="string">@"age"</span>:@<span class="number">18</span>&#125;;</div><div class="line">[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;</div><div class="line"></div><div class="line"><span class="comment">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span></div><div class="line">RACTupleUnpack(<span class="built_in">NSString</span> *key,<span class="built_in">NSString</span> *value) = x;</div><div class="line"></div><div class="line"><span class="comment">// 相当于以下写法</span></div><div class="line"><span class="comment">//        NSString *key = x[0];</span></div><div class="line"><span class="comment">//        NSString *value = x[1];</span></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,key,value);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3.字典转模型</span></div><div class="line"><span class="comment">// 3.1 OC写法</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *items = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> dictArr) &#123;</div><div class="line">FlagItem *item = [FlagItem flagWithDict:dict];</div><div class="line">[items addObject:item];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3.2 RAC写法</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *flags = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">_flags = flags;</div><div class="line"></div><div class="line"><span class="comment">// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。</span></div><div class="line">[dictArr.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// 运用RAC遍历字典，x：字典</span></div><div class="line"></div><div class="line">FlagItem *item = [FlagItem flagWithDict:x];</div><div class="line"></div><div class="line">[flags addObject:item];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,  <span class="built_in">NSStringFromCGRect</span>([<span class="built_in">UIScreen</span> mainScreen].bounds));</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3.3 RAC高级写法:</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"><span class="comment">// map:映射的意思，目的：把原始值value映射成一个新值</span></div><div class="line"><span class="comment">// array: 把集合转换成数组</span></div><div class="line"><span class="comment">// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。</span></div><div class="line"><span class="built_in">NSArray</span> *flags = [[dictArr.rac_sequence map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line"></div><div class="line"><span class="keyword">return</span> [FlagItem flagWithDict:value];</div><div class="line"></div><div class="line">&#125;] array];</div></pre></td></tr></table></figure>
<p><code>RACMulticastConnection</code>:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</p>
<p><code>使用注意</code>:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.</p>
<p><code>RACMulticastConnection简单使用</code>:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACMulticastConnection使用步骤:</span></div><div class="line"><span class="comment">// 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span></div><div class="line"><span class="comment">// 2.创建连接 RACMulticastConnection *connect = [signal publish];</span></div><div class="line"><span class="comment">// 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]</span></div><div class="line"><span class="comment">// 4.连接 [connect connect]</span></div><div class="line"></div><div class="line"><span class="comment">// RACMulticastConnection底层原理:</span></div><div class="line"><span class="comment">// 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号)  connect.signal -&gt; RACSubject</span></div><div class="line"><span class="comment">// 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。</span></div><div class="line"><span class="comment">// 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject</span></div><div class="line"><span class="comment">// 3.1.订阅原始信号，就会调用原始信号中的didSubscribe</span></div><div class="line"><span class="comment">// 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext</span></div><div class="line"><span class="comment">// 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。</span></div><div class="line"><span class="comment">// 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。</span></div><div class="line"><span class="comment">// 解决：使用RACMulticastConnection就能解决.</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建请求信号</span></div><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"发送请求"</span>);</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"接收数据"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"接收数据"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RACMulticastConnection:解决重复请求问题</span></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"发送请求"</span>);</div><div class="line">[subscriber sendNext:@<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2.创建连接</span></div><div class="line">RACMulticastConnection *connect = [signal publish];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号，</span></div><div class="line"><span class="comment">// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:</span></div><div class="line">[connect.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"订阅者一信号"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line">[connect.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"订阅者二信号"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 4.连接,激活信号</span></div><div class="line">[connect connect];</div></pre></td></tr></table></figure>
<p><code>RACCommand</code>:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</p>
<p><code>使用场景</code>:监听按钮点击，网络请求</p>
<p><code>RACCommand简单使用</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 一、RACCommand使用步骤:</span></div><div class="line"><span class="comment">// 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock</span></div><div class="line"><span class="comment">// 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值</span></div><div class="line"><span class="comment">// 3.执行命令 - (RACSignal *)execute:(id)input</span></div><div class="line"></div><div class="line"><span class="comment">// 二、RACCommand使用注意:</span></div><div class="line"><span class="comment">// 1.signalBlock必须要返回一个信号，不能传nil.</span></div><div class="line"><span class="comment">// 2.如果不想要传递信号，直接创建空的信号[RACSignal empty];</span></div><div class="line"><span class="comment">// 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</span></div><div class="line"></div><div class="line"><span class="comment">// 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</span></div><div class="line"><span class="comment">// 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。</span></div><div class="line"><span class="comment">// 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</span></div><div class="line"></div><div class="line"><span class="comment">// 四、如何拿到RACCommand中返回信号发出的数据。</span></div><div class="line"><span class="comment">// 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</span></div><div class="line"><span class="comment">// 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</span></div><div class="line"></div><div class="line"><span class="comment">// 五、监听当前命令是否正在执行executing</span></div><div class="line"></div><div class="line"><span class="comment">// 六、使用场景,监听按钮点击，网络请求</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 1.创建命令</span></div><div class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"执行命令"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建空信号,必须返回信号</span></div><div class="line"><span class="comment">//        return [RACSignal empty];</span></div><div class="line"></div><div class="line"><span class="comment">// 2.创建信号,用来传递数据</span></div><div class="line"><span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">[subscriber sendNext:<span class="string">@"请求数据"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。</span></div><div class="line">[subscriber sendCompleted];</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 强引用命令，不要被销毁，否则接收不到数据</span></div><div class="line">_conmmand = command;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3.执行命令</span></div><div class="line">[<span class="keyword">self</span>.conmmand execute:@<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// 4.订阅RACCommand中的信号</span></div><div class="line">[command.executionSignals subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line">[x subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// RAC高级用法</span></div><div class="line"><span class="comment">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号</span></div><div class="line">[command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 5.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</span></div><div class="line">[[command.executing skip:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ([x boolValue] == <span class="literal">YES</span>) &#123;</div><div class="line"><span class="comment">// 正在执行</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"正在执行"</span>);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="comment">// 执行完成</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"执行完成"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>RACScheduler</code>:RAC中的队列，用GCD封装的。</p>
<p><code>RACUnit</code> :表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.</p>
<p><code>RACEvent</code>: 把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。</p>
<h3 id="7-ReactiveCocoa开发中常见用法。"><a href="#7-ReactiveCocoa开发中常见用法。" class="headerlink" title="7.ReactiveCocoa开发中常见用法。"></a>7.ReactiveCocoa开发中常见用法。</h3><p>7.1 代替代理:</p>
<ul>
<li><code>rac_signalForSelector</code>：用于替代代理。</li>
</ul>
<p>7.2 代替KVO :</p>
<ul>
<li><code>rac_valuesAndChangesForKeyPath</code>：用于监听某个对象的属性改变。</li>
</ul>
<p>7.3 监听事件:</p>
<ul>
<li><code>rac_signalForControlEvents</code>：用于监听某个事件。</li>
</ul>
<p>7.4 代替通知:</p>
<ul>
<li><code>rac_addObserverForName</code>:用于监听某个通知。</li>
</ul>
<p>7.5 监听文本框文字改变:</p>
<ul>
<li><code>rac_textSignal</code>:只要文本框发出改变就会发出这个信号。</li>
</ul>
<p>7.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面</p>
<ul>
<li><code>rac_liftSelector:withSignalsFromArray:Signals</code>:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</li>
<li>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</li>
</ul>
<p>7.7 代码演示</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1.代替代理</span></div><div class="line"><span class="comment">// 需求：自定义redView,监听红色view中按钮点击</span></div><div class="line"><span class="comment">// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</span></div><div class="line"><span class="comment">// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</span></div><div class="line"><span class="comment">// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</span></div><div class="line">[[redV rac_signalForSelector:<span class="keyword">@selector</span>(btnClick:)] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"点击红色按钮"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2.KVO</span></div><div class="line"><span class="comment">// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</span></div><div class="line"><span class="comment">// observer:可以传入nil</span></div><div class="line">[[redV rac_valuesAndChangesForKeyPath:<span class="string">@"center"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.监听事件</span></div><div class="line"><span class="comment">// 把按钮点击事件转换为信号，点击按钮，就会发送信号</span></div><div class="line">[[<span class="keyword">self</span>.btn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"按钮被点击了"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 4.代替通知</span></div><div class="line"><span class="comment">// 把监听到的通知转换信号</span></div><div class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="built_in">UIKeyboardWillShowNotification</span> object:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"键盘弹出"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 5.监听文本框的文字改变</span></div><div class="line">[_textField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"文字改变了%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 6.处理多个请求，都返回结果的时候，统一做处理.</span></div><div class="line">RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"><span class="comment">// 发送请求1</span></div><div class="line">[subscriber sendNext:<span class="string">@"发送请求1"</span>];</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"><span class="comment">// 发送请求2</span></div><div class="line">[subscriber sendNext:<span class="string">@"发送请求2"</span>];</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</span></div><div class="line">[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 更新UI</span></div><div class="line">- (<span class="keyword">void</span>)updateUIWithR1:(<span class="keyword">id</span>)data r2:(<span class="keyword">id</span>)data1</div><div class="line">&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"更新UI%@  %@"</span>,data,data1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="8-ReactiveCocoa常见宏。"><a href="#8-ReactiveCocoa常见宏。" class="headerlink" title="8.ReactiveCocoa常见宏。"></a>8.ReactiveCocoa常见宏。</h3><p>8.1 <code>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</code>:用于给某个对象的某个属性绑定。</p>
<p><code>基本用法</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只要文本框文字改变，就会修改label的文字</span></div><div class="line">RAC(<span class="keyword">self</span>.labelView,text) = _textField.rac_textSignal;</div></pre></td></tr></table></figure>
<p>8.2 <code>RACObserve(self, name)</code>:监听某个对象的某个属性,返回的是信号。</p>
<p><code>基本用法</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[RACObserve(<span class="keyword">self</span>.view, center) subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>8.3  <code>@weakify(Obj)和@strongify(Obj)</code>,一般两个都是配套使用,解决循环引用问题.</p>
<p>8.4 <code>RACTuplePack</code>：把数据包装成RACTuple（元组类）</p>
<p><code>基本用法</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把参数中的数据包装成元组</span></div><div class="line">RACTuple *tuple = RACTuplePack(@<span class="number">10</span>,@<span class="number">20</span>);</div></pre></td></tr></table></figure></p>
<p>8.5 <code>RACTupleUnpack</code>：把RACTuple（元组类）解包成对应的数据。</p>
<p><code>基本用法</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把参数中的数据包装成元组</span></div><div class="line">RACTuple *tuple = RACTuplePack(<span class="string">@"xmg"</span>,@<span class="number">20</span>);</div><div class="line"></div><div class="line"><span class="comment">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span></div><div class="line"><span class="comment">// name = @"xmg" age = @20</span></div><div class="line">RACTupleUnpack(<span class="built_in">NSString</span> *name,<span class="built_in">NSNumber</span> *age) = tuple;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MemoryManagement]]></title>
      <url>http://yoursite.com/2016/12/31/MemoryManagement/</url>
      <content type="html"><![CDATA[<p>###苹果是如何“收垃圾”的?</p>
<p>不管搭载的iOS还是Android，设备的运行内存都是有限的。在你开了一大堆应用程序，快要把内存占满的时候，为了维持正常运行，iOS和Android都会Kill掉一些后台进程，这个行为也称为“垃圾回收机制”。但需要注意的是，iOS和Android“收垃圾”的方式不甚相同。iOS会依次把最老的应用直接关闭掉，所以时候在切换到很老的后台App时会发现，它们都会从标题界面重新启动。相比之下，Android的胆子则要小得多，它不会直接关掉App，而是筛选出其中的一些无用对象，率先把它们Kill掉，从而释放部分内存。但只要你不手动关，这些后台程序都不会自动消失。因此，苹果设备就算只有1GB运行内存，你正在用的App也绝对不会卡，而Android后台程序不会自动被关闭，需要提供更多的内存(2GB、3GB甚至更多)才能保证系统流畅运行。内存需求小不是苹果牛掰的意思，虽然1GB用着也很舒坦，但说“苹果优化好”似乎不太准确，因为iOS和Android的垃圾处理方法并不是一个高端、一个土鳖，而是各有利弊。</p>
<p>iOS会无差别地关掉老应用，这意味着如果你正在玩一个大型游戏，那么可能微信、微博、QQ这些软件就全都被关掉了。你若想切换回这些软件，就要经历一个相当闹心的启动过程。朋友圈发完了、微博也玩够了，这回天下该太平了吧?等等，但愿你的游戏还能回到刚才暂停的位置……另外一个比较闹心的场景就是你在Safari浏览器里开了N个标签，1GB运存承受不住那么多的内容，于是非常自觉地把最老的几个网页给挂起了。如果那几个页面刚好是你填了一半的付款界面或者是写了一半的文章，那么……那Android又是怎么坑爹的呢? 想必用家们都深有感触：切换界面会卡、接电话会卡、解锁会卡，连看个照片都得等半天。但是，Android的大内存也有得天独厚的好处，那就是不管你想开什么后台应用，它们都会把你上次干半截的事情完整地带到前台，不会连个招呼都不打就关了它们。尤其目前市面上具备3GB运行内存的Android手机，它们既能够保证大量应用同时运行，也能保持整个系统处在一个比较流畅的状态，整体的体验也还是可以的(开好几十个应用不关的除外)。所以，iOS的“霸道型小内存”和Android的“人文关怀型大内存”其实都是各有利弊的，并不是简单的一个比另一个好的关系。</p>
<p>###运存那么小，你以为苹果真的很满足?</p>
<p>苹果在iPhone 6和6 Plus上保持1GB运行内存，不单单是因为用起来不卡，其实也基于以下一些问题进行了考量：内存耗电：更多的内存会消耗更多的电能，iPhone6内存仅1GB，而且采用了LPDDR3低电压版模块，节能效果相当可观;成本问题：升级到2GB或者更高，单台手机的制造成本并不会提高多少，但是对于一个出货量动辄好几千万的产品来说，那算下来可得损失不少钱呢!用户需求问题：虽然存在着一些略显坑爹的关后台问题，但是果粉们早就习惯了，就算加大内存容量，整体体验的提升也不见得多明显。对于追求各方面性能均衡的苹果来说，单个指标不突出不算是缺憾。其实说到底，在理想状态下，苹果也非常想让内存更大一些，毕竟用户运行多任务的时候，谁都希望能多开几个应用。苹果也意识到随着用户需求的提高，内存问题势必变得愈加尖锐，他们已然开始行动了：iPad Air 2升级到了2GB内存，这样一来，相信下一代的iPhone离大运存也不会太远了。</p>
<p>###那么1G的内存是如何分配给各个App的嘞?</p>
<p>苹果给每个应用程序设置20M的内存警告量，30M的闪退量，游戏会略微放款10~20M，需要向系统申请。这一条说明除了系统本身占用内存以外，任何程序几乎都不可能占用超过50M内存。实际上，不是单个程序存在50M的内存使用上限，而是单线程使用上限是50M，同一个程序可以加载多个线程，同一个程序可以使用多个线程。</p>
<ul>
<li><p>关于后台:<br>苹果设计本身就没有后台，当你把程序最小化的时候程序就暂停了一切活动。如果应用想继续运行一部分功能的话，必须向系统申请运行时长，或者调用系统功能，比如音乐播放。由此跟安卓需要大内存来支持后台运行的区别就显而易见了，因为安卓是在Linux上跑的Java虚拟机，他的内存管理机制是申请之后就一直在那放着，等一个Runtime周期结束之后会自动收回不必要的内存。</p>
</li>
<li><p>关于内存：<br>个人认为，IOS只要不彻底重新编写的话，苹果几乎不可能开放海量内存，因为它既不支持真后台，又给APP设置了50M的内存使用上限。打个比方：你开法拉利（超大内存），我开QQ（1G内存），咱俩一起在路上跑（使用内存），但是限速50（内存使用限制），只要超过限速就扣车（超过限制即强行释放内存），你开再好的车也不可能比我快多少，因为苹果不让，除非苹果放开限速让你随便跑（开放内存配额上限）。但是不把路挖掉重新铺的话（系统限制，除非大刀阔斧的做改造，否则开放意义也不大，主要是苹果公司认为没意义……），就不能开放限速，所以现阶段只能限速50.这就是IPHONE只用1G内存的原因。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Enum]]></title>
      <url>http://yoursite.com/2016/12/30/Enum/</url>
      <content type="html"><![CDATA[<p>Ios中常用的枚举的几种写法</p>
<p>###1.普通的枚举<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</div><div class="line">    XMtop,</div><div class="line">    XMbottom,</div><div class="line">&#125;XM;</div></pre></td></tr></table></figure></p>
<p>###2.自定义类型枚举<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, KSType) &#123;</div><div class="line">    KSTypeTop,</div><div class="line">    KSTypeBottom,</div><div class="line">    KSTypeRight,</div><div class="line">    KSTypeLeft,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>###3.移位枚举:一个参数可以传递多个值<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, SType) &#123;</div><div class="line">    STypeTop        = <span class="number">1</span>&lt;&lt;<span class="number">0</span>,</div><div class="line">    STypeBottom     = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,</div><div class="line">    STypeRight      = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,</div><div class="line">    STypeLeft       = <span class="number">1</span>&lt;&lt;<span class="number">3</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSDecimalNumber]]></title>
      <url>http://yoursite.com/2015/12/20/Ios%E7%B2%BE%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>NSDecimalNumber Ios精度计算</p>
<p>.m文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Iimport &lt;Foundation/Foundation.h&gt;</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HighPrecision</span> : <span class="title">NSObject</span> </span></div><div class="line">+ (<span class="built_in">NSString</span> *)plusWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 加法</span></div><div class="line">+ (<span class="built_in">NSString</span> *)minuWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 减法</span></div><div class="line">+ (<span class="built_in">NSString</span> *)multiplyWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 乘法</span></div><div class="line">+ (<span class="built_in">NSString</span> *)devideWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 除法</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>.h文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HighPrecision</span></span></div><div class="line">+ (<span class="built_in">NSString</span> *)plusWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *b = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:B];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *h = [a decimalNumberByAdding: b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line">    <span class="built_in">NSString</span> *result = [h stringValue];</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSString</span> *)minuWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line"> 	<span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line"> 	<span class="built_in">NSDecimalNumber</span> *c = [a decimalNumberBySubtracting:b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line"> 	<span class="built_in">NSString</span> *result = [c stringValue];</div><div class="line"> 	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSString</span> *)multiplyWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line">   <span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line">   <span class="built_in">NSDecimalNumber</span> *b = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:B];</div><div class="line">   <span class="built_in">NSDecimalNumber</span> *j = [a decimalNumberByMultiplyingBy:b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line">   <span class="built_in">NSString</span> *result = [j stringValue];</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSString</span> *)devideWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *b = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:B];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *s = [a decimalNumberByDividingBy:b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line">    <span class="built_in">NSString</span> *result = [s stringValue];</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSDecimalNumberHandler</span> *)format</div><div class="line">&#123;</div><div class="line">   <span class="comment">// NSRoundPlain 貌似取整</span></div><div class="line">   <span class="comment">// NSRoundDown 只舍不入</span></div><div class="line">   <span class="comment">// NSRoundUp 只入不舍</span></div><div class="line">   <span class="comment">// NSRoundBankers 貌似四舍五入</span></div><div class="line">    </div><div class="line">   <span class="built_in">NSDecimalNumberHandler</span> *roundUp = [<span class="built_in">NSDecimalNumberHandler</span></div><div class="line">        decimalNumberHandlerWithRoundingMode:<span class="built_in">NSRoundBankers</span></div><div class="line">                                       scale:<span class="number">2</span></div><div class="line">                                       raiseOnExactness:<span class="literal">NO</span></div><div class="line">                                       raiseOnOverflow:<span class="literal">NO</span></div><div class="line">                                       raiseOnUnderflow:<span class="literal">NO</span></div><div class="line">                                       raiseOnDivideByZero:<span class="literal">YES</span>];</div><div class="line">    <span class="keyword">return</span> roundUp;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
  
  
</search>
