<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[音乐锁屏键的处理]]></title>
      <url>http://yoursite.com/2017/12/20/2014/%E9%9F%B3%E4%B9%90%E9%94%81%E5%B1%8F%E9%94%AE%E7%9A%84%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h4 id="完整的思路"><a href="#完整的思路" class="headerlink" title="完整的思路"></a>完整的思路</h4><ul>
<li>1.App如果需要在锁屏界面上显示相关的信息和按钮, 必须先开启远程控制事件(Remote Control Event), 否则锁屏界面只显示滑动解锁.</li>
<li>2.实现锁屏界面信息, 将歌曲的相关信息更新到锁屏界面上</li>
<li>3.实现锁屏界面的事件处理, 在锁屏界面和上拉的快速功能菜单中实现播放控制</li>
</ul>
<h4 id="远程控制事件的实现"><a href="#远程控制事件的实现" class="headerlink" title="远程控制事件的实现"></a>远程控制事件的实现</h4><p>在iOS7.1之前, 远程控制事件主要涉及以下三个方法:<br>开始接收远程控制事件<br>结束接收远程控制事件<br>触发远程控制事件后的捕获处理<br>官方文档对这三个方法的描述如下, 这里做了简单的翻译.</p>
<h4 id="开始接收远程控制事件"><a href="#开始接收远程控制事件" class="headerlink" title="开始接收远程控制事件"></a>开始接收远程控制事件</h4><p>让App开始接收远程控制事件, 该方法属于UIApplication类<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)beginReceivingRemoteControlEvents;</div></pre></td></tr></table></figure></p>
<p>在iOS7.1之后, 使用MPRemoteCommandCenter的共享对象来注册远程控制事件. 当使用shared command center时, 不需要再调用该方法.<br>该方法会开始使用事件响应链来传递远程控制事件. 远程控制事件是当耳机和外部附件意图控制App的多媒体表现时发出的命令. 要停止远程控制事件的接收, 必须调用endReceivingRemoteControlEvents方法</p>
<p>让App停止接收远程控制事件, 该方法属于UIApplication类<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)endReceivingRemoteControlEvents;</div></pre></td></tr></table></figure></p>
<p>在iOS7.1之前, 使用shared MPRemoteCommandCenter对象来注册远程控制事件. 当使用shared command center时, 不需要再调用该方法.<br>该方法会停止通过事件响应链来传递远程控制事件. 远程控制事件是当耳机和外部附件意图控制App的多媒体表现时发出的命令.</p>
<h4 id="远程控制事件的捕获处理"><a href="#远程控制事件的捕获处理" class="headerlink" title="远程控制事件的捕获处理"></a>远程控制事件的捕获处理</h4><p>当远程控制事件发生时触发该方法, 该方法属于UIResponder类<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</div></pre></td></tr></table></figure></p>
<p>远程控制事件是由外部附件(包括耳机)所发出的命令. 应用需要响应这些命令来控制音频或视频媒体的对用户的表示. 事件响应者通过检查事件的subtype, 来判断命令的意图. 比如UIEventSubtypeRemoteControlPlay为播放操作, 然后做相关处理要允许远程控制事件的传递, 需要调用UIApplication的beginReceivingRemoteControlEvents方法; 要关闭远程控制事件的传递则调用endReceivingRemoteControlEvents</p>
<h4 id="项目中的代码实现"><a href="#项目中的代码实现" class="headerlink" title="项目中的代码实现"></a>项目中的代码实现</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    <span class="comment">// 在App启动后开启远程控制事件, 接收来自锁屏界面和上拉菜单的控制</span></div><div class="line">    [application beginReceivingRemoteControlEvents];</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 在App要终止前结束接收远程控制事件, 也可以在需要终止时调用该方法终止</span></div><div class="line">    [application endReceivingRemoteControlEvents];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 在具体的控制器或其它类中捕获处理远程控制事件</span></div><div class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 根据事件的子类型(subtype) 来判断具体的事件类型, 并做出处理</span></div><div class="line">    <span class="keyword">switch</span> (event.subtype) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>: &#123;</div><div class="line">            <span class="comment">// 执行播放或暂停的相关操作 (锁屏界面和上拉快捷功能菜单处的播放按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>: &#123;</div><div class="line">            <span class="comment">// 执行上一曲的相关操作 (锁屏界面和上拉快捷功能菜单处的上一曲按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>: &#123;</div><div class="line">            <span class="comment">// 执行下一曲的相关操作 (锁屏界面和上拉快捷功能菜单处的下一曲按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlTogglePlayPause</span>: &#123;</div><div class="line">            <span class="comment">// 进行播放/暂停的相关操作 (耳机的播放/暂停按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="iOS7-1后-更新了远程控制事件的实现方式"><a href="#iOS7-1后-更新了远程控制事件的实现方式" class="headerlink" title="iOS7.1后, 更新了远程控制事件的实现方式"></a>iOS7.1后, 更新了远程控制事件的实现方式</h4><p>相关方法的描述中, 已经说明, iOS7.1之后使用MPRemoteCommandCenter类来进行远程控制事件的相关处理, 因此可以不再使用上面所描述的三个方法. 官方文档MPRemoteCommandCenter的描述如下:</p>
<ul>
<li>MPRemoteCommandCenter<br>MPRemoteCommandCenter类提供了处理远程控制事件的对象, 包括由外部附件和系统传输控制发送的远程控制事件. 不需要自己创建该类的实例. 而是使用shareCommandCenter方法获取默认的命令中心(share command center)对象. share command center对象的属性包含了MPRemoteCommand对象(表示iOS支持的每种远程控件事件). 如果要对响应的事件特殊处理, 使用适当的MPRemoteCommand对象注册一个handler即可.远程命令中心(remote command center)对象为许多不同类型的事件提供了命令(command)对象. 如果你的App不需要支持某些特定类型的事件, 可以通过设置其enabled属性为NO来禁用关联的MPRemoteCommand对象. 使用command对象注册一个handler, 以便让系统知道你的App已经做好了接收事件的准备. 只有当你的App是当前正在播放(Now Playing App)时才能接收到事件的传递.</li>
<li>项目中的代码实现<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在需要处理远程控制事件的具体控制器或其它类中实现</span></div><div class="line">- (<span class="keyword">void</span>)remoteControlEventHandler</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 直接使用sharedCommandCenter来获取MPRemoteCommandCenter的shared实例</span></div><div class="line">    <span class="built_in">MPRemoteCommandCenter</span> *commandCenter = [<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter];</div><div class="line"></div><div class="line">    <span class="comment">// 启用播放命令 (锁屏界面和上拉快捷功能菜单处的播放按钮触发的命令)</span></div><div class="line">    commandCenter.playCommand.enabled = <span class="literal">YES</span>;</div><div class="line">    <span class="comment">// 为播放命令添加响应事件, 在点击后触发</span></div><div class="line">    [commandCenter.playCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(playAction:)];</div><div class="line"></div><div class="line">    <span class="comment">// 播放, 暂停, 上下曲的命令默认都是启用状态, 即enabled默认为YES</span></div><div class="line">    <span class="comment">// 为暂停, 上一曲, 下一曲分别添加对应的响应事件</span></div><div class="line">    [commandCenter.pauseCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pauseAction:)];</div><div class="line">    [commandCenter.previousTrackCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(previousTrackAction:)];</div><div class="line">    [commandCenter.nextTrackCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(nextTrackAction:)];</div><div class="line"></div><div class="line">    <span class="comment">// 启用耳机的播放/暂停命令 (耳机上的播放按钮触发的命令)</span></div><div class="line">    commandCenter.togglePlayPauseCommand.enabled = <span class="literal">YES</span>;</div><div class="line">    <span class="comment">// 为耳机的按钮操作添加相关的响应事件</span></div><div class="line">    [commandCenter.togglePlayPauseCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(playOrPauseAction:)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="锁屏界面相关信息更新"><a href="#锁屏界面相关信息更新" class="headerlink" title="锁屏界面相关信息更新"></a>锁屏界面相关信息更新</h4><p>实现了远程控制事件后, App在进行音乐播放时, 上拉快捷功能菜单都会提供远程控件按钮, 锁屏界面会有改动, 出现远程控制按钮, 以及歌曲进度等信息, 接下来需要将歌曲的相关信息更新到锁屏界面上. 主要通过MPNowPlayingInfoCenter类来实现, 下面是官方文档的描述:</p>
<ul>
<li>MPNowPlayingInfoCenter<br>使用now playing info center来设置App当前正在播放的媒体文件的信息(now-playing information).系统会在设备的锁屏界面和上划的快捷控制面板的多媒体控制部分显示当前播放文件的信息. 如果用户直接通过AirPlay在Apple TV上播放媒体文件时, now-playing信息会显示在电视屏幕上. 如果用户将设备连接到iPad附件, 比如汽车(通过CarPlay连接)上, 附件上可能会显示now-playing的信息.你不能直接控制哪些信息要被显示出来, 以及这些信息显示的样式. 只需要设置now playing info center dictionary的相关value, 将这些相关信息提交给系统即可. 系统或已经连接的附件, 会用一致的方式为所有的App处理这些信息的展示.<h4 id="可以配置的锁屏界面信息"><a href="#可以配置的锁屏界面信息" class="headerlink" title="可以配置的锁屏界面信息"></a>可以配置的锁屏界面信息</h4>可以使用的information属性, 是定义在MPMediaItem类的General Media Item Property Keys属性中的子集(即其中的某些属性). 在iOS5.0后, now playing info center支持下列media item属性的Key: (仅列举了常用的Key!)</li>
<li>MPMediaItemPropertyAlbumTitle<br>专辑的标题, value是NSString对象</li>
<li>MPMediaItemPropertyArtist<br>media item的创作者, value是NSString对象</li>
<li>MPMediaItemPropertyArtwork<br>media item的插图. value是MPMediaItemArtwork类的对象</li>
<li>MPMediaItemPropertyPlaybackDuration<br>media item的播放总时长. value是表示包装了时长秒数(NSTimeInterval)的NSNumber类型</li>
<li>MPMediaItemPropertyTitle<br>media item的名字或标题. 该属性与MPMediaItemPropertyAlbumTitle属性无关, value是NSString对象<br>额外添加的一些可以使用的属性在MPNowPlayingInfoCenter类的描述文档中的Additional Metadata Properties中作了声明. (仅列举了常用的Key!)</li>
<li>MPNowPlayingInfoPropertyElapsedPlaybackTime<br>当前播放的item所消逝的时间(歌曲当前时间), 单位为秒. value是包装了double值的NSNumber对象. elapsed time是由系统根据之前提供elapsed tiime和playback rate进行自动进行计算的. 请不要频繁的更新该属性, 这是没有必要的.</li>
<li>MPNowPlayingInfoPropertyPlaybackRate<br>当前播放的item的播放速率, value为1.0表示正常的播放速率. value是包装了double值的NSNumber对象. 默认值是1.0. playback rate的值为2.0表示普通播放速率的2倍; 此时media从播放到结束只需要一半时间.<h4 id="项目中的代码实现-1"><a href="#项目中的代码实现-1" class="headerlink" title="项目中的代码实现"></a>项目中的代码实现</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updatelockScreenInfo </div><div class="line">&#123;</div><div class="line">    <span class="comment">// 直接使用defaultCenter来获取MPNowPlayingInfoCenter的默认唯一实例</span></div><div class="line">    <span class="built_in">MPNowPlayingInfoCenter</span> *infoCenter = [<span class="built_in">MPNowPlayingInfoCenter</span> defaultCenter];</div><div class="line">    <span class="comment">// MPMediaItemArtwork 用来表示锁屏界面图片的类型</span></div><div class="line">    <span class="built_in">MPMediaItemArtwork</span> *artwork = [[<span class="built_in">MPMediaItemArtwork</span> alloc]     initWithImage:image];</div><div class="line">    <span class="comment">// 通过配置nowPlayingInfo的值来更新锁屏界面的信息</span></div><div class="line">    infoCenter.nowPlayingInfo = @&#123;</div><div class="line">        <span class="comment">// 歌曲名</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyTitle</span> : music.name,</div><div class="line">        <span class="comment">// 艺术家名</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyArtist</span> : music.singer,</div><div class="line">        <span class="comment">// 专辑名字</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyAlbumTitle</span> : music.album,</div><div class="line">        <span class="comment">// 歌曲总时长 </span></div><div class="line">        <span class="built_in">MPMediaItemPropertyPlaybackDuration</span> : @(duration),</div><div class="line">        <span class="comment">// 歌曲的当前时间</span></div><div class="line">        <span class="built_in">MPNowPlayingInfoPropertyElapsedPlaybackTime</span> : @(currentTime),</div><div class="line">        <span class="comment">// 歌曲的插图, 类型是MPMeidaItemArtwork对象</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyArtwork</span> : artwork,</div><div class="line"></div><div class="line">        <span class="comment">// 无效的, 歌词的展示是通过图片绘制完成的, 即将歌词绘制到歌曲插图, 通过更新插图来实现歌词的更新的</span></div><div class="line">        <span class="comment">// MPMediaItemPropertyLyrics : lyric.content,</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="类似网易新闻的锁屏控制按钮实现"><a href="#类似网易新闻的锁屏控制按钮实现" class="headerlink" title="类似网易新闻的锁屏控制按钮实现"></a>类似网易新闻的锁屏控制按钮实现</h4><p>通过上述代码实现后, 锁屏界面已经可以展示出歌曲信息与控制按钮, 通过按钮或耳机的按键也可以实现相关的控制效果. 但网易的控制按钮中最左边并是上一曲, 而是列表按钮, 点击后还能在锁屏界面弹出一个ActionSheet界面. 该功能其实是通过修改MPRemoteCommandCenter的反馈功能(提供喜欢, 不喜欢, 标记(bookmark)操作)来实现的.涉及到的反馈功能, 先了解MPFeedbackCommond这个类, 以下是文档的描述</p>
<ul>
<li>MPFeedbackCommond<br>MPFeedbackCommand对象反映了当前App所播放的反馈状态. MPRemoteCommandCenter对象提供feedback对象用于对媒体文件进行喜欢, 不喜欢, 标记的操作. 使用这些对象为App支持的回馈(feedback)方式进行注册handler, 并在反馈状态修改时执行适当的任务(task). 在当前播放的item改变时, 也可以使用该对象为新的item设置反馈状态.当item的反馈状态改变时, 系统传递适当的事件到该对象注册的handler上. handler的代码必须决定哪一个media item来接收反馈, 然后再为该item执行更新反馈状态的操作. 你也可以执行与接收到反馈相关的其它任务. 比如, 当用户喜欢当前播放的歌曲时你可能要在UI上做出适当调整, 并使用该信息来进行相关歌曲的推荐.</li>
<li>MPRemoteCommandCenterr提供了相关属性(反馈按钮)<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">MPFeedbackCommand</span> *likeCommand;  <span class="comment">// 喜欢命令</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">MPFeedbackCommand</span> *dislikeCommand;  <span class="comment">// 不喜欢命令</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">MPFeedbackCommand</span> *bookmarkCommand; <span class="comment">// 标记(书签)命令</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>事实上, 系统的锁屏界面并不支持自定义. 这里边只需要添加反馈按钮, 则系统默认的锁屏界面就是网易云音乐所展示的样式. 包括点击后弹出的ActionSheet都是系统针对反馈按钮所提供了, 网易云音乐只是巧妙的将”不喜欢”按钮的标题修改成”上一曲”, 并在该按钮的响应事件里实现上一曲的代码, 即完成相关功能.</p>
<ul>
<li>项目中的代码实现<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 添加"喜欢"按钮, 需要启用, 并且设置了相关Action后才会生效</span></div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].likeCommand.enabled = <span class="literal">YES</span>;</div><div class="line">[[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].likeCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(likeItemAction)];</div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].likeCommand.localizedTitle = <span class="string">@"喜欢"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 添加"不喜欢"按钮</span></div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].dislikeCommand.enabled = <span class="literal">YES</span>;</div><div class="line"><span class="comment">// 自定义该按钮的响应事件, 实现在点击"不喜欢"时去执行上一首的功能</span></div><div class="line">[[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].dislikeCommand </div><div class="line">addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(previousCommandAction)];</div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span></div><div class="line"><span class="comment">// 自定义"不喜欢"的标题, 伪装成"上一首"</span></div><div class="line">sharedCommandCenter].dislikeCommand.localizedTitle = <span class="string">@"上一首"</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意: 反馈按钮默认不启用, 因此需要将enabled设置为YES, 同时必须添加对应的响应事件, 按钮才会在锁屏界面显示.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MemoryManagement]]></title>
      <url>http://yoursite.com/2016/03/02/2014/MemoryManagement/</url>
      <content type="html"><![CDATA[<p>###苹果是如何“收垃圾”的?</p>
<p>不管搭载的iOS还是Android，设备的运行内存都是有限的。在你开了一大堆应用程序，快要把内存占满的时候，为了维持正常运行，iOS和Android都会Kill掉一些后台进程，这个行为也称为“垃圾回收机制”。但需要注意的是，iOS和Android“收垃圾”的方式不甚相同。iOS会依次把最老的应用直接关闭掉，所以时候在切换到很老的后台App时会发现，它们都会从标题界面重新启动。相比之下，Android的胆子则要小得多，它不会直接关掉App，而是筛选出其中的一些无用对象，率先把它们Kill掉，从而释放部分内存。但只要你不手动关，这些后台程序都不会自动消失。因此，苹果设备就算只有1GB运行内存，你正在用的App也绝对不会卡，而Android后台程序不会自动被关闭，需要提供更多的内存(2GB、3GB甚至更多)才能保证系统流畅运行。内存需求小不是苹果牛掰的意思，虽然1GB用着也很舒坦，但说“苹果优化好”似乎不太准确，因为iOS和Android的垃圾处理方法并不是一个高端、一个土鳖，而是各有利弊。</p>
<p>iOS会无差别地关掉老应用，这意味着如果你正在玩一个大型游戏，那么可能微信、微博、QQ这些软件就全都被关掉了。你若想切换回这些软件，就要经历一个相当闹心的启动过程。朋友圈发完了、微博也玩够了，这回天下该太平了吧?等等，但愿你的游戏还能回到刚才暂停的位置……另外一个比较闹心的场景就是你在Safari浏览器里开了N个标签，1GB运存承受不住那么多的内容，于是非常自觉地把最老的几个网页给挂起了。如果那几个页面刚好是你填了一半的付款界面或者是写了一半的文章，那么……那Android又是怎么坑爹的呢? 想必用家们都深有感触：切换界面会卡、接电话会卡、解锁会卡，连看个照片都得等半天。但是，Android的大内存也有得天独厚的好处，那就是不管你想开什么后台应用，它们都会把你上次干半截的事情完整地带到前台，不会连个招呼都不打就关了它们。尤其目前市面上具备3GB运行内存的Android手机，它们既能够保证大量应用同时运行，也能保持整个系统处在一个比较流畅的状态，整体的体验也还是可以的(开好几十个应用不关的除外)。所以，iOS的“霸道型小内存”和Android的“人文关怀型大内存”其实都是各有利弊的，并不是简单的一个比另一个好的关系。</p>
<p>###运存那么小，你以为苹果真的很满足?</p>
<p>苹果在iPhone 6和6 Plus上保持1GB运行内存，不单单是因为用起来不卡，其实也基于以下一些问题进行了考量：内存耗电：更多的内存会消耗更多的电能，iPhone6内存仅1GB，而且采用了LPDDR3低电压版模块，节能效果相当可观;成本问题：升级到2GB或者更高，单台手机的制造成本并不会提高多少，但是对于一个出货量动辄好几千万的产品来说，那算下来可得损失不少钱呢!用户需求问题：虽然存在着一些略显坑爹的关后台问题，但是果粉们早就习惯了，就算加大内存容量，整体体验的提升也不见得多明显。对于追求各方面性能均衡的苹果来说，单个指标不突出不算是缺憾。其实说到底，在理想状态下，苹果也非常想让内存更大一些，毕竟用户运行多任务的时候，谁都希望能多开几个应用。苹果也意识到随着用户需求的提高，内存问题势必变得愈加尖锐，他们已然开始行动了：iPad Air 2升级到了2GB内存，这样一来，相信下一代的iPhone离大运存也不会太远了。</p>
<p>###那么1G的内存是如何分配给各个App的嘞?</p>
<p>苹果给每个应用程序设置20M的内存警告量，30M的闪退量，游戏会略微放款10~20M，需要向系统申请。这一条说明除了系统本身占用内存以外，任何程序几乎都不可能占用超过50M内存。实际上，不是单个程序存在50M的内存使用上限，而是单线程使用上限是50M，同一个程序可以加载多个线程，同一个程序可以使用多个线程。</p>
<ul>
<li><p>关于后台:<br>苹果设计本身就没有后台，当你把程序最小化的时候程序就暂停了一切活动。如果应用想继续运行一部分功能的话，必须向系统申请运行时长，或者调用系统功能，比如音乐播放。由此跟安卓需要大内存来支持后台运行的区别就显而易见了，因为安卓是在Linux上跑的Java虚拟机，他的内存管理机制是申请之后就一直在那放着，等一个Runtime周期结束之后会自动收回不必要的内存。</p>
</li>
<li><p>关于内存：<br>个人认为，IOS只要不彻底重新编写的话，苹果几乎不可能开放海量内存，因为它既不支持真后台，又给APP设置了50M的内存使用上限。打个比方：你开法拉利（超大内存），我开QQ（1G内存），咱俩一起在路上跑（使用内存），但是限速50（内存使用限制），只要超过限速就扣车（超过限制即强行释放内存），你开再好的车也不可能比我快多少，因为苹果不让，除非苹果放开限速让你随便跑（开放内存配额上限）。但是不把路挖掉重新铺的话（系统限制，除非大刀阔斧的做改造，否则开放意义也不大，主要是苹果公司认为没意义……），就不能开放限速，所以现阶段只能限速50.这就是IPHONE只用1G内存的原因。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[网络库AFNetworking详解]]></title>
      <url>http://yoursite.com/2014/12/17/2014/%E7%BD%91%E7%BB%9C%E5%BA%93%E7%9A%84%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="为什么要用AFNetworking"><a href="#为什么要用AFNetworking" class="headerlink" title="为什么要用AFNetworking"></a>为什么要用AFNetworking</h2><p>为什么要用AFNetworking  在ios开发中，一般情况下，简单的向某个web站点简单的页面提交请求并获取服务器的响应，用xcode自带的NSURLConnection是能胜任的。但是，在绝大部分下我们所需要访问的web页面则是属于那种受到权限保护的页面，并不是有一个简单的URL可以访问的。这就涉及到了Session和Cookie的处理了，在此时使用NSURLConnection也是能够达到要求的，只是其中处理起来的复杂度和难度就提升了。  为了更好的处理向Web站点的请求，包括处理Session，Cookie等细节问题，使用AFNetworking则是更好的选择，他可以用于发送HTTP请求，接收HTTP的响应，但是不会缓存服务器的响应，不能执行HTML页面中的JAvascript代码,同时，AFNetworking还内置支持JSON，plist文件和XML文件的解析，使用比较方便。 </p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>1、Session：中文有译作时域的，就是只某个客户端在访问服务器起到停止访问这一段的时间间隔被称为时域。<br>2、Cookie：由服务器发送给客服端，把Cookie的key：value值储存在本地文件夹下，当下次请求的时候能够直接发送Cookie获得权限验证</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>AFNetworking 3.0 实现完全基于NSURLSessionTask进行封装，NSURLSessionTask 是苹果在iOS7 推出的网络请求api。AF支持https，网络数据请求，文件上传，文件下载，监听手机网络状态。AFHttpSessionManager 继承 AFURLSessionManager 对网络请求进行管理，使用AFURLRequestSerialization 对网络请求进行封装，使用AFURLReponseSerialization 响应体进行处理，使用AFSecurityPolicy 对服务器证书进行校验。支持https协议，支持本地证书和服务器证书进行对比验证，AF要求ios7或以上系统。AF数据传递主要使用block 和 notifacation的方式。</p>
<h2 id="AFURLSessionManager-使用方法"><a href="#AFURLSessionManager-使用方法" class="headerlink" title="AFURLSessionManager 使用方法"></a>AFURLSessionManager 使用方法</h2><ul>
<li><p>请求服务器数据</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>
</li>
<li><p>上传数据</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>
</li>
<li><p>多线程下载数据</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:<span class="string">@"POST"</span> URLString:<span class="string">@"http://example.com/upload"</span> parameters:<span class="literal">nil</span> constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;</div><div class="line">    [formData appendPartWithFileURL:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.jpg"</span>] name:<span class="string">@"file"</span> fileName:<span class="string">@"filename.jpg"</span> mimeType:<span class="string">@"image/jpeg"</span> error:<span class="literal">nil</span>];</div><div class="line">&#125; error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</div><div class="line"></div><div class="line">    <span class="built_in">NSURLSessionUploadTask</span> *uploadTask;</div><div class="line">    uploadTask = [manager</div><div class="line">    uploadTaskWithStreamedRequest:request</div><div class="line"></div><div class="line">    progress:^(<span class="built_in">NSProgress</span> * _Nonnull uploadProgress) &#123;</div><div class="line">        <span class="comment">// This is not called back on the main queue.</span></div><div class="line">        <span class="comment">// You are responsible for dispatching to the main queue for UI updates</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//Update the progress view</span></div><div class="line">        [progressView setProgress:uploadProgress.fractionCompleted];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">    completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AFHttpSessionManager-使用方法"><a href="#AFHttpSessionManager-使用方法" class="headerlink" title="AFHttpSessionManager 使用方法"></a>AFHttpSessionManager 使用方法</h2><h3 id="1-post请求"><a href="#1-post请求" class="headerlink" title="1.post请求"></a>1.post请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure DEPRECATED_ATTRIBUTE;</div></pre></td></tr></table></figure>
<h3 id="2-get请求"><a href="#2-get请求" class="headerlink" title="2.get请求"></a>2.get请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</div><div class="line">parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure</div></pre></td></tr></table></figure>
<h3 id="3-上传"><a href="#3-上传" class="headerlink" title="3.上传"></a>3.上传</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</div><div class="line">success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure DEPRECATED_ATTRIBUTE;</div></pre></td></tr></table></figure>
<h2 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *googleCertificateURL = [[<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]] URLForResource:<span class="string">@"google.com"</span> withExtension:<span class="string">@"cer"</span>];</div><div class="line"><span class="built_in">NSData</span> *googleCertificateData = [<span class="built_in">NSData</span> dataWithContentsOfURL:googleCertificateURL];</div><div class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://apple.com/"</span>]];</div><div class="line"></div><div class="line">[manager setResponseSerializer:[AFHTTPResponseSerializer serializer]];</div><div class="line">manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:[<span class="built_in">NSSet</span> setWithObject:googleCertificateData]];</div></pre></td></tr></table></figure>
<p>证书文件放在应用bundle 中 ，会把服务器证书和本地证书对比认证，加强网络通信的安全性，判断是否信任服务器证书过程</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</div><div class="line">    <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></div><div class="line">    <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></div><div class="line">    <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></div><div class="line">    <span class="comment">//  there is nothing to evaluate against.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  From Apple Docs:</span></div><div class="line">    <span class="comment">//          "Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></div><div class="line">    <span class="comment">//           Instead, add your own (self-signed) CA certificate to the list of trusted anchors."</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"In order to validate a domain name for self signed certificates, you MUST use pinning."</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</div><div class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</div><div class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</div><div class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</div><div class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</div><div class="line">            &#125;</div><div class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</div><div class="line">                <span class="comment">//服务器证书和存储在应用中的证书进行对比验证</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</div><div class="line">        <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</div><div class="line">            <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</div><div class="line">                trustedPublicKeyCount += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div></pre></td></tr></table></figure>
<h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><p>AFURLSessionManager管理所有的请求，session 设置了NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate 实现证书合法性校验，数据传输进度检测，数据请求成功或失败的回调。<br>使用runtime 用af_supend 替换 suspend,用af_resume 替换了resume 当调用这两个方法的时候往上层发送通知AFNetworkingTaskDidSuspendNotification AFNetworkingTaskDidResumeNotification</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Method afResumeMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_resume));</div><div class="line">Method afSuspendMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_suspend));</div><div class="line"></div><div class="line"><span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_resume), afResumeMethod)) &#123;</div><div class="line">    af_swizzleSelector(theClass, <span class="keyword">@selector</span>(resume), <span class="keyword">@selector</span>(af_resume));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_suspend), afSuspendMethod)) &#123;</div><div class="line">    af_swizzleSelector(theClass, <span class="keyword">@selector</span>(suspend), <span class="keyword">@selector</span>(af_suspend));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AFNetworking-3-0迁移指南"><a href="#AFNetworking-3-0迁移指南" class="headerlink" title="AFNetworking 3.0迁移指南"></a>AFNetworking 3.0迁移指南</h2><p><code>新设备要求:</code> iOS 7, Mac OS X 10.9, watchOS 2, tvOS 9, &amp; Xcode 7</p>
<h3 id="NSURLConnection的API已废弃"><a href="#NSURLConnection的API已废弃" class="headerlink" title="NSURLConnection的API已废弃"></a>NSURLConnection的API已废弃</h3><p>AFNetworking 1.0建立在NSURLConnection的基础API之上 ，AFNetworking 2.0开始使用NSURLConnection的基础API ，以及较新基于NSURLSession的API的选项。 AFNetworking 3.0现已完全基于NSURLSession的API，这降低了维护的负担，同时支持苹果增强关于NSURLSession提供的任何额外功能。由于Xcode 7中，NSURLConnection的API已经正式被苹果弃用。虽然该API将继续运行，但将没有新功能将被添加，并且苹果已经通知所有基于网络的功能，以充分使NSURLSession向前发展。AFNetworking 2.X将继续获得关键的隐患和安全补丁，但没有新的功能将被添加。Alamofire(Swift下的网络请求)软件基金会建议，所有的项目迁移到基于NSURLSession的API。</p>
<h4 id="弃用的类"><a href="#弃用的类" class="headerlink" title="弃用的类"></a>弃用的类</h4><p>下面的类已从AFNetworking 3.0中废弃</p>
<ul>
<li>AFURLConnectionOperation</li>
<li>AFHTTPRequestOperation</li>
<li>AFHTTPRequestOperationManager</li>
</ul>
<h4 id="修改的类"><a href="#修改的类" class="headerlink" title="修改的类"></a>修改的类</h4><p>下面的类包含基于NSURLConnection的API的内部实现。他们已经被使用NSURLSession重构</p>
<ul>
<li>UIImageView+AFNetworking</li>
<li>UIWebView+AFNetworking</li>
<li>UIButton+AFNetworking</li>
</ul>
<h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><h4 id="AFHTTPRequestOperationManager-核心代码"><a href="#AFHTTPRequestOperationManager-核心代码" class="headerlink" title="AFHTTPRequestOperationManager 核心代码"></a>AFHTTPRequestOperationManager 核心代码</h4><p>如果你以前使用 AFHTTPRequestOperationManager ， 你将需要迁移去使用 AFHTTPSessionManager。 以下的类在两者过渡间并没有变化</p>
<ul>
<li>securityPolicy</li>
<li>requestSerializer</li>
<li>responseSerializer<br>接下来举一个关于AFHTTPSessionManager的简单例子。注意HTTP网络请求返回的不再是AFHTTPRequestOperation, 修改成为了NSURLSessionTask，并且成功和失败的Block块中的参数也变更为了NSURLSessionTask，而不再是AFHTTPRequestOperation。</li>
</ul>
<p>AFNetworking 2.x</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</div><div class="line">[manager GET:<span class="string">@"请求的url"</span> parameters:<span class="literal">nil</span> success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"成功"</span>);</div><div class="line">&#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span>*error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"失败"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">AFNetworking <span class="number">3.0</span></div><div class="line">AFHTTPSessionManager *session = [AFHTTPSessionManager manager];</div><div class="line">[session GET:<span class="string">@"请求的url"</span> parameters:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"成功"</span>);</div><div class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"失败"</span>);        </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="AFHTTPRequestOperation-核心代码"><a href="#AFHTTPRequestOperation-核心代码" class="headerlink" title="AFHTTPRequestOperation 核心代码"></a>AFHTTPRequestOperation 核心代码</h3><p>与NSURLConnection对象不同，每个共享应用范围的设置如会话管理、缓存策略、Cookie存储以及URL协议等，这些NSURLSession对象都可以单独进行配置。使用特定的配置来初始化会话，它可以发送任务来获取数据，并上传或下载文件。在AFNetworking 2.0中，使用AFHTTPRequestOperation，有可能创建一个没有额外开销的独立的网络请求来获取数据。NSURLSession则需要更多的开销，为了获得所要请求的数据。接下来，将要通过AFHTTPSessionManager创建一个对象，并创建一个任务和启动它。</p>
<ul>
<li>AFNetworking 2.x</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line">AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];</div><div class="line">op.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line"></div><div class="line">[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JSON: %@"</span>, responseObject);</div><div class="line">&#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">&#125;];</div><div class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperation:op];</div></pre></td></tr></table></figure>
<ul>
<li>AFNetworking 3.0</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</div><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line">[manager GET:URL.absoluteString parameters:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JSON: %@"</span>, responseObject);</div><div class="line">&#125; failure:^(<span class="built_in">NSURLSessionTask</span> *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="UIKit的迁移"><a href="#UIKit的迁移" class="headerlink" title="UIKit的迁移"></a>UIKit的迁移</h3><p>图片下载已经被重构，以遵循AlamofireImage架构与新的AFImageDownloader类。这个类的图片下载职责的代理人是UIButton与UIImageView的类目，并且提供了一些方法，在必要时可以自定义。类别中，下载远程图片的实际方法没有改变。UIWebView的类目被重构为使用AFHTTPSessionManager作为其网络请求。</p>
<h3 id="UIAlertView的类目被废弃"><a href="#UIAlertView的类目被废弃" class="headerlink" title="UIAlertView的类目被废弃"></a>UIAlertView的类目被废弃</h3><p>从AFNetworking 3.0后UIAlertView的类目因过时而被废弃。并没有提供UIAlertController类目的计划，因为这是应用程序应处理的逻辑，而不是这个库。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图片缓存的优化]]></title>
      <url>http://yoursite.com/2014/10/30/2014/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="图片缓存的优化"><a href="#图片缓存的优化" class="headerlink" title="图片缓存的优化"></a>图片缓存的优化</h2><h4 id="一：从图片入手"><a href="#一：从图片入手" class="headerlink" title="一：从图片入手"></a>一：从图片入手</h4><p>内存占用大原因是图片太大，所以想到对图片进行压缩。找了好多压缩工具，最后发现一款比较好用的，名字是ppDuck（pp鸭），这里是<a href="http://ppduck.com/" target="_blank" rel="external">下载地址</a>,图片压缩后，内存确实是暂用较少了，但还没有根本结局。</p>
<h4 id="二：从加载图片的方式考虑"><a href="#二：从加载图片的方式考虑" class="headerlink" title="二：从加载图片的方式考虑"></a>二：从加载图片的方式考虑</h4><p>正确选择图片加载方式能够对内存优化起到很大的作用，常见的图片加载方式有下面三种：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法1  </span></div><div class="line"><span class="built_in">UIImage</span> *imag1 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>];  </div><div class="line"><span class="comment">//方法2  </span></div><div class="line"><span class="built_in">UIImage</span> *image2 = [<span class="built_in">UIImage</span> imageWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image@2x"</span> ofType:.png]];  </div><div class="line"><span class="comment">//方法3  </span></div><div class="line"><span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image@2x"</span> ofType:png]];  </div><div class="line"><span class="built_in">UIImage</span> *image3 = [<span class="built_in">UIImage</span> imageWithData:imageData]；</div></pre></td></tr></table></figure>
<ul>
<li>第一种方法:imageNamed:<br>为什么有两种方法完成同样的事情呢？imageNamed的优点在于可以缓存已经加载的图片。苹果的文档中有如下说法：这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回。对于同一个图像，系统只会把它Cache到内存一次，这对于图像的重复利用是非常有优势的。例如：你需要在 一个TableView里重复加载同样一个图标，那么用imageNamed加载图像，系统会把那个图标Cache到内存，在Table里每次利用那个图 像的时候，只会把图片指针指向同一块内存。这种情况使用imageNamed加载图像就会变得非常有效。</li>
</ul>
<ul>
<li><p>第二种方法和第三种方法本质是一样的:imageWithContentsOfFile:和imageWithData:<br>而imageWithContentsOfFile方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当你不需要重用该图像，或者你需要将</p>
</li>
<li><p>如何选择</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法1 cach  </span></div><div class="line"><span class="built_in">UIImage</span> *imag1 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>];  </div><div class="line"><span class="comment">//方法2 no cach  </span></div><div class="line"><span class="built_in">UIImage</span> *image2 = [<span class="built_in">UIImage</span> imageWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image.png"</span> ofType:<span class="literal">nil</span>]];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果加载一张很大的图片，并且只使用一次，那么就不需要缓存这个图片。这种情况imageWithContentsOfFile比较合适,系统不会浪费内存来缓存图片。然而，如果在程序中经常需要重用的图片，那么最好是选择imageNamed方法。这种方法可以节省出每次都从磁盘加载图片的时间。</p>
<h2 id="Ios圆角图片的优化"><a href="#Ios圆角图片的优化" class="headerlink" title="Ios圆角图片的优化"></a>Ios圆角图片的优化</h2><ul>
<li><p>原理<br>上面拖慢帧率的原因其实都是Off-Screen Rendering（离屏渲染）的原因。离屏渲染是个好东西，但是频繁发生离屏渲染是非常耗时的。</p>
</li>
<li><p>Off-Screen Rendering<br>离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。由上面的一个结论视图和圆角的大小对帧率并没有什么卵影响，数量才是伤害的核心输出啊。可以知道离屏渲染耗时是发生在离屏这个动作上面，而不是渲染。为什么离屏这么耗时？原因主要有创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。</p>
</li>
<li><p>上下文切换<br>上下文切换，不管是在GPU渲染过程中，还是一直所熟悉的进程切换，上下文切换在哪里都是一个相当耗时的操作。首先我要保存当前屏幕渲染环境，然后切换到一个新的绘制环境，申请绘制资源，初始化环境，然后开始一个绘制，绘制完毕后销毁这个绘制环境，如需要切换到On-Screen<br>Rendering或者再开始一个新的离屏渲染重复之前的操作。 下图描述了一次mask的渲染操作。</p>
</li>
</ul>
<p>一次mask发生了两次离屏渲染和一次主屏渲染。即使忽略昂贵的上下文切换，一次mask需要渲染三次才能在屏幕上显示，这已经是普通视图显示3陪耗时，若再加上下文环境切换，一次mask就是普通渲染的30倍以上耗时操作。问我这个30倍以上这个数据怎么的出来的？当我在cell的UIImageView的实例增加到150个，并去掉圆角的时候，帧数才跌至28帧每秒。虽然不是甚准确，但至少反映mask这个耗时是无mask操作的耗时的数十倍的。</p>
<h3 id="第一种-设置CALayer的cornerRadius"><a href="#第一种-设置CALayer的cornerRadius" class="headerlink" title="第一种:设置CALayer的cornerRadius"></a>第一种:设置CALayer的cornerRadius</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"img"</span>];</div><div class="line">imageView.image.layer.cornerRadius = <span class="number">5</span>;</div><div class="line">imageView.image.layer.masksToBounds = <span class="literal">YES</span>;</div></pre></td></tr></table></figure>
<p>这样设置会触发离屏渲染，比较消耗性能。比如当一个页面上有十几头像这样设置了圆角会明显感觉到卡顿。这种就是最常用的，也是最耗性能的。</p>
<p>注意：ios9.0之后对UIImageView的圆角设置做了优化，UIImageView这样设置圆角不会触发离屏渲染，ios9.0之前还是会触发离屏渲染。而UIButton还是都会触发离屏渲染。</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">imageView.clipsToBounds = <span class="literal">YES</span>;</div><div class="line">imageView.layer setCornerRadius:<span class="number">50</span>];</div><div class="line">imageView.layer.shouldRasterize = <span class="literal">YES</span>;</div></pre></td></tr></table></figure>
<p>shouldRasterize=YES设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图， 使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新 创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</p>
<h3 id="第三种-通过Core-Graphics重新绘制带圆角的视图"><a href="#第三种-通过Core-Graphics重新绘制带圆角的视图" class="headerlink" title="第三种 :通过Core Graphics重新绘制带圆角的视图"></a>第三种 :通过Core Graphics重新绘制带圆角的视图</h3><p>这种方式性能最好，但是UIButton上不知道怎么绘制，可以用UIimageView添加个 点击手势当做UIButton使用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">CircleImage</span>)</span></div><div class="line"></div><div class="line">- (<span class="built_in">UIImage</span> *)drawCircleImage &#123;</div><div class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size, <span class="literal">NO</span>, [<span class="built_in">UIScreen</span> mainScreen].scale); </div><div class="line">    [[<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span>.bounds cornerRadius:<span class="number">50</span>] addClip]; </div><div class="line">    [<span class="keyword">self</span> drawInRect:<span class="keyword">self</span>.bounds]; </div><div class="line">    <span class="built_in">UIImage</span> *output = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    <span class="keyword">return</span> output; </div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">//在需要圆角时调用如下</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="built_in">UIImage</span> *img = [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>] drawCircleImage];</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        imageView.image = img;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="四、通过混合图层"><a href="#四、通过混合图层" class="headerlink" title="四、通过混合图层"></a>四、通过混合图层</h3><p>此方法就是在要添加圆角的视图上再叠加一个部分透明的视图，只对圆角部分进行遮挡。图层混合的透明度处理方式与mask正好相反。此方法虽然是最优解，没有离屏渲染，没有额外的CPU计算，但是应用范围有限。</p>
<ul>
<li>总结</li>
</ul>
<p>在可以使用混合图层遮挡的场景下，优先使用第四种方法。即使是非iOS9以上系统，第一种方法在综合性能上依然强于后两者，iOS9以上由于没有了离屏渲染更是首选。方法三由于需要大量计算和增加部分内存，需要实际情况各自取舍。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常见的储存方案]]></title>
      <url>http://yoursite.com/2014/09/13/2014/%E5%82%A8%E5%AD%98%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h2 id="Ios四种常见的储存方案"><a href="#Ios四种常见的储存方案" class="headerlink" title="Ios四种常见的储存方案"></a>Ios四种常见的储存方案</h2><h3 id="概念问题"><a href="#概念问题" class="headerlink" title="概念问题"></a>概念问题</h3><p>首先要明确区分两个概念，数据结构和储存方式。所谓数据结构就是数据存在的形式。除了基本的NSDictionary、NSArray和NSSet这些对象，还有更复杂的如：关系模型、对象图和属性列表多种结构。而存储方式则简单的分为两种：内存与闪存。内存存储是临时的，运行时有效的，但效率高，而闪存则是一种持久化存储，但产生I/O消耗，效率相对低。把内存数据转移到闪存中进行持久化的操作称成为归档。二者结合起来才是完整的数据存储方案，我们最常谈起的那些：SQLite、CoreData、NSUserDefaults等都是数据存储方案。当然在这些框架提供的方案之外，我们自己也可以按照个性化需求订制方案。这些存储方案侧重不同，支持的形式和方式也各不相同，在不同的使用场景下表现也是各有优劣。但万变不离其宗。</p>
<h3 id="以下将对四种存储方式进行详细的介绍"><a href="#以下将对四种存储方式进行详细的介绍" class="headerlink" title="以下将对四种存储方式进行详细的介绍"></a>以下将对四种存储方式进行详细的介绍</h3><ul>
<li>NSUserDefaults，用于存储配置信息</li>
<li>SQLite，用于存储查询需求较多的数据</li>
<li>CoreData，用于规划应用中的对象</li>
<li>使用基本对象类型定制的个性化缓存方案</li>
</ul>
<h4 id="用NSUserDefaults存储配置信息"><a href="#用NSUserDefaults存储配置信息" class="headerlink" title="用NSUserDefaults存储配置信息"></a>用NSUserDefaults存储配置信息</h4><p>NSUserDefaults被设计用来存储设备和应用的配置信息，它通过一个工厂方法返回默认的、也是最常用到的实例对象。这个对象中储存了系统中用户的配置信息，开发者可以通过这个实例对象对这些已有的信息进行修改，也可以按照自己的需求创建新的配置项。<br>NSUserDefaults把配置信息以字典的形式组织起来，支持字典的项包括：字符串或者是数组，除此之外还支持数字等基本格式。一句话概括就是：基础类型的小数据的字典。操作方法几乎与NSDictionary的操作方法无异，另外还可以通过指定返回类型的方法获取到指定类型的返回值。<br>NSUserDefaults的所有数据都放在内存里，因此操作速度很快，并还提供一个归档方法：+ (void)synchronize。开发者自定义的配置项（如图2中的最后一项 key:alkdjfkladsjfmm）会以plist格式的文件归档在相应应用目录的/Library/Preferences/[App_Bundle_Identifier].plist文件。再次初始化获得实例对象后，框架会把用户自定义的这个配置和系统配置合并得到完整数据。</p>
<h4 id="用SQLite存储查询需求较多的数据"><a href="#用SQLite存储查询需求较多的数据" class="headerlink" title="用SQLite存储查询需求较多的数据"></a>用SQLite存储查询需求较多的数据</h4><p>iOS的SDK里预置了SQLite的库，开发者可以自建SQLite数据库。SQLite每次写入数据都会产生IO消耗，把数据归档到相应的文件。SQLite擅长处理的数据类型其实与NSUserDefaults差不多，也是基础类型的小数据，只是从组织形式上不同。开发者可以以关系型数据库的方式组织数据，使用SQL DML来管理数据。 一般来说应用中的格式化的文本类数据可以存放在数据库中，尤其是类似聊天记录、Timeline等这些具有条件查询和排序需求的数据。每一个数据库的句柄都会在内存中都会被分配一段缓存，用于提高查询效率。另一个方面，由于查询缓存，当产生大量句柄或数据量较大时，会出现缓存过大，造成内存浪费。SQLite的使用起来要比NSUserDefaults复杂的多，因此建议开发者使用SQLite要搭配一个操作控件使用，可以简化操作。笔者开发的SQLight是一款对SQLite操作的封装，把相对复杂的SQLite命令封装成对象和方法，可以供大家参考。大家可以在Github上获取这个工程的代码进一步了解。</p>
<h4 id="用CoreData规划应用中对象"><a href="#用CoreData规划应用中对象" class="headerlink" title="用CoreData规划应用中对象"></a>用CoreData规划应用中对象</h4><p>官方给出的定义是，一个支持持久化的，对象图和生命周期的自动化管理方案。严格意义上说CoreData是一个管理方案，他的持久化可以通过SQLite、XML或二进制文件储存。如官方定义所说，CoreData的作用远远不止储存数据这么简单，它可以把整个应用中的对象建模并进行自动化的管理。<br>MyDocument是一个对象实例，有两个Collection：Employee和Department，存放各自的对象列表。MyDocument、Employee和Department三个对象以及他们之间的关系都通过CoreData建模，并可以通过save方法进行持久化。<br>从归档文件还原模型时CoreData并不是一次性把整个模型中的所有数据都载入内存，而是根据运行时状态，把被调用到的对象实例载入内存。框架会自动控制这个过程，从而达到控制内存消耗，避免浪费。<br>无论从设计原理还是使用方法上看，CoreData都比较复杂。因此，如果仅仅是考虑缓存数据这个需求，CoreData绝对不是一个优选方案。CoreData的使用场景在于：整个应用使用CoreData规划，把应用内的数据通过CoreData建模，完全基于CoreData架构应用。<br>之前提到的NSUserDefaults和SQLite适合存储基础类型的小数据，而CoreData则不适合存储单一的数据</p>
<h2 id="Ios四种储存方案的使用"><a href="#Ios四种储存方案的使用" class="headerlink" title="Ios四种储存方案的使用"></a>Ios四种储存方案的使用</h2><h3 id="保存文件的额目录"><a href="#保存文件的额目录" class="headerlink" title="保存文件的额目录"></a>保存文件的额目录</h3><ul>
<li>持久化<br>所谓的持久化，就是将数据保存到硬盘中，使得在应用程序或机器重启后可以继续访问之前保存的数据。</li>
<li><p>沙盒<br>在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p>
</li>
<li><p>结构<br>沙盒的目录结构如下</p>
</li>
</ul>
<p>“应用程序包”<br>Documents<br>Library<br>Caches<br>Preferences<br>tmp</p>
<ul>
<li>目录特性<br>虽然沙盒中有这么多文件夹，但是没有文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</li>
</ul>
<p>** 应用程序包<br>// 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] bundlePath];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure></p>
<p>** Documents<br>//最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure></p>
<p>** Library/Caches<br>// iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure>
<p>** Library/Preferences<br>// iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</p>
<p>** tmp<br>iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSTemporaryDirectory</span>();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure>
<h3 id="plist文件"><a href="#plist文件" class="headerlink" title="plist文件"></a>plist文件</h3><p>plist文件是将某些特定的类，通过XML文件的方式保存在目录中。<br>可以被序列化的类型只有如下几种：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span>;</div><div class="line"><span class="built_in">NSMutableArray</span>;</div><div class="line"><span class="built_in">NSDictionary</span>;</div><div class="line"><span class="built_in">NSMutableDictionary</span>;</div><div class="line"><span class="built_in">NSData</span>;</div><div class="line"><span class="built_in">NSMutableData</span>;</div><div class="line"><span class="built_in">NSString</span>;</div><div class="line"><span class="built_in">NSMutableString</span>;</div><div class="line"><span class="built_in">NSNumber</span>;</div><div class="line"><span class="built_in">NSDate</span>;</div></pre></td></tr></table></figure>
<h4 id="1-获得文件路径"><a href="#1-获得文件路径" class="headerlink" title="1.获得文件路径"></a>1.获得文件路径</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</div><div class="line"><span class="built_in">NSString</span> *fileName = [path stringByAppendingPathComponent:<span class="string">@"123.plist"</span>];</div></pre></td></tr></table></figure>
<h4 id="2-存储"><a href="#2-存储" class="headerlink" title="2.存储"></a>2.存储</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"123"</span>, <span class="string">@"456"</span>, <span class="string">@"789"</span>];</div><div class="line">[array writeToFile:fileName atomically:<span class="literal">YES</span>];</div></pre></td></tr></table></figure>
<h4 id="3-读取"><a href="#3-读取" class="headerlink" title="3.读取"></a>3.读取</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *result = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:fileName];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result);</div></pre></td></tr></table></figure>
<h4 id="4-注意"><a href="#4-注意" class="headerlink" title="4.注意"></a>4.注意</h4><p>只有以上列出的类型才能使用plist文件存储。存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。读取时使用arrayWithContentsOfFile:方法。</p>
<h3 id="Preference"><a href="#Preference" class="headerlink" title="Preference"></a>Preference</h3><h4 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1.使用方法"></a>1.使用方法</h4><p>//1.获得NSUserDefaults文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div></pre></td></tr></table></figure></p>
<p>//2.向文件中写入内容<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[userDefaults setObject:<span class="string">@"AAA"</span> forKey:<span class="string">@"a"</span>];</div><div class="line">[userDefaults setBool:<span class="literal">YES</span> forKey:<span class="string">@"sex"</span>];</div><div class="line">[userDefaults setInteger:<span class="number">21</span> forKey:<span class="string">@"age"</span>];</div></pre></td></tr></table></figure></p>
<p>//2.1立即同步<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[userDefaults synchronize];</div></pre></td></tr></table></figure></p>
<p>//3.读取文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *name = [userDefaults objectForKey:<span class="string">@"a"</span>];</div><div class="line"><span class="built_in">BOOL</span> sex = [userDefaults boolForKey:<span class="string">@"sex"</span>];</div><div class="line"><span class="built_in">NSInteger</span> age = [userDefaults integerForKey:<span class="string">@"age"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@, %d, %ld"</span>, name, sex, age);</div></pre></td></tr></table></figure></p>
<h4 id="2-注意"><a href="#2-注意" class="headerlink" title="2.注意"></a>2.注意</h4><p>偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</p>
<h3 id="NSKeyedArchiver"><a href="#NSKeyedArchiver" class="headerlink" title="NSKeyedArchiver"></a>NSKeyedArchiver</h3><p>归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。</p>
<h4 id="1-遵循NSCoding协议"><a href="#1-遵循NSCoding协议" class="headerlink" title="1.遵循NSCoding协议"></a>1.遵循NSCoding协议</h4><p>NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p>
<ul>
<li><p>遵循协议和设置属性</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//1.遵循NSCoding协议 </span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//2.设置属性</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIImage</span> *avatar;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>实现协议方法</p>
</li>
</ul>
<p>//解档<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="keyword">self</span>.avatar = [aDecoder decodeObjectForKey:<span class="string">@"avatar"</span>];</div><div class="line">        <span class="keyword">self</span>.name = [aDecoder decodeObjectForKey:<span class="string">@"name"</span>];</div><div class="line">        <span class="keyword">self</span>.age = [aDecoder decodeIntegerForKey:<span class="string">@"age"</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//归档<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.avatar forKey:<span class="string">@"avatar"</span>];</div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.name forKey:<span class="string">@"name"</span>];</div><div class="line">    [aCoder encodeInteger:<span class="keyword">self</span>.age forKey:<span class="string">@"age"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>特别注意<br>如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder] 方法;</li>
</ul>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><ul>
<li>需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *file = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.data"</span>];</div><div class="line">Person *person = [[Person alloc] init];</div><div class="line">person.avatar = <span class="keyword">self</span>.avatarView.image;</div><div class="line">person.name = <span class="keyword">self</span>.nameField.text;</div><div class="line">person.age = [<span class="keyword">self</span>.ageField.text integerValue];</div><div class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:person toFile:file];</div></pre></td></tr></table></figure>
<ul>
<li>需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法unarchiveObjectWithFile: 即可<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *file = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.data"</span>];</div><div class="line"></div><div class="line">Person *person = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:file];</div><div class="line"><span class="keyword">if</span> (person) &#123;</div><div class="line">    <span class="keyword">self</span>.avatarView.image = person.avatar;</div><div class="line">    <span class="keyword">self</span>.nameField.text = person.name;</div><div class="line">    <span class="keyword">self</span>.ageField.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, person.age];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h4><p>1.必须遵循并实现NSCoding协议<br>2.保存文件的扩展名可以任意指定<br>3.继承时必须先调用父类的归档解档方法</p>
<h2 id="SQLite3"><a href="#SQLite3" class="headerlink" title="SQLite3"></a>SQLite3</h2><p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p>
<h4 id="1-字段类型"><a href="#1-字段类型" class="headerlink" title="1.字段类型"></a>1.字段类型</h4><p>表面上SQLite将数据分为以下几种类型：</p>
<ul>
<li>integer : 整数</li>
<li>real : 实数（浮点数）</li>
<li>text : 文本字符串</li>
<li>blob : 二进制数据，比如文件，图片之类的<br>实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！主键必须设置成integer</li>
</ul>
<h4 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h4><p>准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。</p>
<h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h4><ul>
<li>创建数据库并打开<br>操作数据库之前必须先指定数据库文件和要操作的表，所以使用SQLite3，首先要打开数据库文件，然后指定或创建一张表。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*  打开数据库并创建一个表</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)openDatabase &#123;</div><div class="line"></div><div class="line"><span class="comment">//1.设置文件名</span></div><div class="line"><span class="built_in">NSString</span> *filename = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.db"</span>];</div><div class="line"></div><div class="line"><span class="comment">//2.打开数据库文件，如果没有会自动创建一个文件</span></div><div class="line"><span class="built_in">NSInteger</span> result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);</div><div class="line"><span class="keyword">if</span> (result == SQLITE_OK) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"打开数据库成功！"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//3.创建一个数据库表</span></div><div class="line">    <span class="keyword">char</span> *errmsg = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    sqlite3_exec(_sqlite3, <span class="string">"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg);</div><div class="line">    <span class="keyword">if</span> (errmsg) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"错误：%s"</span>, errmsg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创表成功！"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"打开数据库失败！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行指令<br>使用 sqlite3_exec() 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*  往表中插入1000条数据</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)insertData &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *nameStr;</div><div class="line">    <span class="built_in">NSInteger</span> age;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">        nameStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Bourne-%d"</span>, arc4random_uniform(<span class="number">10000</span>)];</div><div class="line">        age = arc4random_uniform(<span class="number">80</span>) + <span class="number">20</span>;</div><div class="line"></div><div class="line">        <span class="built_in">NSString</span> *sql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"INSERT INTO t_person (name, age) VALUES('%@', '%ld')"</span>, nameStr, age];</div><div class="line"></div><div class="line">        <span class="keyword">char</span> *errmsg = <span class="literal">NULL</span>;</div><div class="line">        sqlite3_exec(_sqlite3, sql.UTF8String, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg);</div><div class="line">        <span class="keyword">if</span> (errmsg) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"错误：%s"</span>, errmsg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"插入完毕！"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>查询指令<br>前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：<br>sqlite3_prepare_v2() : 检查sql的合法性<br>sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录<br>sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。<br>sqlite3_finalize() : 释放stmt</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*  从表中读取数据到数组中</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)readData &#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> *mArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1000</span>];</div><div class="line">    <span class="keyword">char</span> *sql = <span class="string">"select name, age from t_person;"</span>;</div><div class="line">    sqlite3_stmt *stmt;</div><div class="line"></div><div class="line">    <span class="built_in">NSInteger</span> result = sqlite3_prepare_v2(_sqlite3, sql, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (result == SQLITE_OK) &#123;</div><div class="line">        <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">char</span> *name = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">0</span>);</div><div class="line">            <span class="built_in">NSInteger</span> age = sqlite3_column_int(stmt, <span class="number">1</span>);</div><div class="line"></div><div class="line">            <span class="comment">//创建对象</span></div><div class="line">            Person *person = [Person personWithName:[<span class="built_in">NSString</span> stringWithUTF8String:name] Age:age];</div><div class="line">            [mArray addObject:person];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">self</span>.dataList = mArray;</div><div class="line">    &#125;</div><div class="line">    sqlite3_finalize(stmt);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 FMDB，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。</p>
<h2 id="FMDB"><a href="#FMDB" class="headerlink" title="FMDB"></a>FMDB</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:</p>
<ul>
<li>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</li>
<li>对比苹果自带的Core Data框架，更加轻量级和灵活</li>
<li>提供了多线程安全的数据库操作方法，有效地防止数据混乱</li>
</ul>
<h3 id="2-核心类"><a href="#2-核心类" class="headerlink" title="2.核心类"></a>2.核心类</h3><p>FMDB有三个主要的类:</p>
<ul>
<li><p>FMDatabase<br>一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</p>
</li>
<li><p>FMResultSet<br>使用FMDatabase执行查询后的结果集</p>
</li>
<li><p>FMDatabaseQueue<br>用于在多线程中执行多个查询或更新，它是线程安全的</p>
</li>
</ul>
<h3 id="3-打开数据库"><a href="#3-打开数据库" class="headerlink" title="3.打开数据库"></a>3.打开数据库</h3><p>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSString</span> *path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.db"</span>];</div><div class="line"></div><div class="line">FMDatabase *database = [FMDatabase databaseWithPath:path];    </div><div class="line"><span class="keyword">if</span> (![database open]) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"数据库打开失败！"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="值得注意的是，Path的值可以传入以下三种情况："><a href="#值得注意的是，Path的值可以传入以下三种情况：" class="headerlink" title="值得注意的是，Path的值可以传入以下三种情况："></a>值得注意的是，Path的值可以传入以下三种情况：</h4><ul>
<li>具体文件路径，如果不存在会自动创建</li>
<li>空字符串@””，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除</li>
<li>nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</li>
</ul>
<h3 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h3><p>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//常用方法有以下3种：   </span></div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdate:(<span class="built_in">NSString</span>*)sql, ...</div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdateWithFormat:(<span class="built_in">NSString</span>*)format, ...</div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdate:(<span class="built_in">NSString</span>*)sql withArgumentsInArray:(<span class="built_in">NSArray</span> *)arguments</div><div class="line"></div><div class="line"><span class="comment">//示例</span></div><div class="line">[database executeUpdate:<span class="string">@"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)"</span>];   </div><div class="line"><span class="comment">//或者  </span></div><div class="line">[database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES(?, ?)"</span>, <span class="string">@"Bourne"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">42</span>]];</div></pre></td></tr></table></figure>
<h3 id="5-查询"><a href="#5-查询" class="headerlink" title="5.查询"></a>5.查询</h3><p>查询方法也有3种，使用起来相当简单：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (FMResultSet *)executeQuery:(<span class="built_in">NSString</span>*)sql, ...</div><div class="line">- (FMResultSet *)executeQueryWithFormat:(<span class="built_in">NSString</span>*)format, ...</div><div class="line">- (FMResultSet *)executeQuery:(<span class="built_in">NSString</span> *)sql withArgumentsInArray:(<span class="built_in">NSArray</span> *)arguments</div></pre></td></tr></table></figure>
<p>查询示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//1.执行查询</span></div><div class="line">FMResultSet *result = [database executeQuery:<span class="string">@"SELECT * FROM t_person"</span>];</div><div class="line"><span class="comment">//2.遍历结果集</span></div><div class="line"><span class="keyword">while</span> ([result next]) &#123;</div><div class="line"><span class="built_in">NSString</span> *name = [result stringForColumn:<span class="string">@"name"</span>];</div><div class="line">    <span class="keyword">int</span> age = [result intForColumn:<span class="string">@"age"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-线程安全"><a href="#6-线程安全" class="headerlink" title="6.线程安全"></a>6.线程安全</h3><p>在多个线程中同时使用一个FMDatabase实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法：</p>
<ul>
<li>创建队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</div></pre></td></tr></table></figure>
<ul>
<li>使用队列<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[queue inDatabase:^(FMDatabase *database) &#123;    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_1"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]];    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_2"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>]];    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_3"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>]];      </div><div class="line">    FMResultSet *result = [database executeQuery:<span class="string">@"select * from t_person"</span>];    </div><div class="line">    <span class="keyword">while</span>([result next]) &#123;   </div><div class="line"></div><div class="line">    &#125;    </div><div class="line">&#125;];</div><div class="line">而且可以轻松地把简单任务包装到事务里：</div><div class="line"></div><div class="line">[queue inTransaction:^(FMDatabase *database, <span class="built_in">BOOL</span> *rollback) &#123;    </div><div class="line">[database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_1"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]];    </div><div class="line">[database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_2"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>]];    </div><div class="line">[database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_3"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>]];      </div><div class="line">FMResultSet *result = [database executeQuery:<span class="string">@"select * from t_person"</span>];    </div><div class="line"><span class="keyword">while</span>([result next]) &#123;   </div><div class="line">&#125;   </div><div class="line"></div><div class="line"><span class="comment">// 回滚</span></div><div class="line">*rollback = <span class="literal">YES</span>;  </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>FMDatabaseQueue 后台会建立系列化的G-C-D队列，并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GDC也会按它接收的块的顺序来执行。</p>
<h2 id="一-CoreData的基本使用"><a href="#一-CoreData的基本使用" class="headerlink" title="一,CoreData的基本使用"></a>一,CoreData的基本使用</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>创建数据库<br>新建文件，选择CoreData -&gt; DataModel<br>添加实体（表），Add Entity<br>给表中添加属性，点击Attributes下方的‘+’号</li>
<li>创建模型文件<br>新建文件，选择CoreData -&gt; NSManaged Object subclass<br>根据提示，选择实体<br>*通过代码，关联数据库和实体</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">/*</span></div><div class="line">    * 关联的时候，如果本地没有数据库文件，Ｃoreadata自己会创建</div><div class="line">    */</div><div class="line"></div><div class="line">    <span class="comment">// 1. 上下文</span></div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 上下文关连数据库</span></div><div class="line"></div><div class="line">    <span class="comment">// 2.1 model模型文件</span></div><div class="line">    <span class="built_in">NSManagedObjectModel</span> *model = [<span class="built_in">NSManagedObjectModel</span> mergedModelFromBundles:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 持久化存储调度器</span></div><div class="line">    <span class="comment">// 持久化，把数据保存到一个文件，而不是内存</span></div><div class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *store = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 设置CoreData数据库的名字和路径</span></div><div class="line">    <span class="built_in">NSString</span> *doc = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="built_in">NSString</span> *sqlitePath = [doc stringByAppendingPathComponent:<span class="string">@"company.sqlite"</span>];</div><div class="line"></div><div class="line">    [store addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:sqlitePath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    context.persistentStoreCoordinator = store;</div><div class="line">    _context = context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CoreData的基本操作（CURD）"><a href="#CoreData的基本操作（CURD）" class="headerlink" title="CoreData的基本操作（CURD）"></a>CoreData的基本操作（CURD）</h3><ul>
<li>添加元素 - Create</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)addEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个员工对象 </span></div><div class="line">    <span class="comment">//Employee *emp = [[Employee alloc] init]; 不能用此方法创建</span></div><div class="line">    Employee *emp = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_context];</div><div class="line">    emp.name = <span class="string">@"wangwu"</span>;</div><div class="line">    emp.height = @<span class="number">1.80</span>;</div><div class="line">    emp.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">// 直接保存数据库</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>读取数据 - Read</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)readEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 1.FetchRequest 获取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.设置过滤条件</span></div><div class="line">    <span class="comment">// 查找zhangsan</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>,</div><div class="line">    <span class="string">@"zhangsan"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 3.设置排序</span></div><div class="line">    <span class="comment">// 身高的升序排序</span></div><div class="line">    <span class="built_in">NSSortDescriptor</span> *heigtSort = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"height"</span> ascending:<span class="literal">NO</span>];</div><div class="line">    request.sortDescriptors = @[heigtSort];</div><div class="line"></div><div class="line">    <span class="comment">// 4.执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//NSLog(@"%@",emps);</span></div><div class="line"></div><div class="line">    <span class="comment">//遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 身高 %@ 生日 %@"</span>,emp.name,emp.height,emp.birthday);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>修改数据 - Update</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)updateEmployee&#123;</div><div class="line">    <span class="comment">// 改变zhangsan的身高为2m</span></div><div class="line"></div><div class="line">    <span class="comment">// 1.查找到zhangsan</span></div><div class="line">    <span class="comment">// 1.1FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 1.2设置过滤条件</span></div><div class="line">    <span class="comment">// 查找zhangsan</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>, <span class="string">@"zhangsan"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 1.3执行请求</span></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.更新身高</span></div><div class="line">    <span class="keyword">for</span> (Employee *e <span class="keyword">in</span> emps) &#123;</div><div class="line">        e.height = @<span class="number">2.0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 3.保存</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>删除数据 - Delete<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)deleteEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 删除 lisi</span></div><div class="line"></div><div class="line">    <span class="comment">// 1.查找lisi</span></div><div class="line">    <span class="comment">// 1.1FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 1.2设置过滤条件</span></div><div class="line">    <span class="comment">// 查找zhangsan</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>,</div><div class="line">    <span class="string">@"lisi"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 1.3执行请求</span></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.删除</span></div><div class="line">    <span class="keyword">for</span> (Employee *e <span class="keyword">in</span> emps) &#123;</div><div class="line">    [_context deleteObject:e];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 3.保存</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、CoreData的表关联"><a href="#二、CoreData的表关联" class="headerlink" title="二、CoreData的表关联"></a>二、CoreData的表关联</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>创建数据库<br>新建文件，选择CoreData -&gt; DataModel<br>添加实体（表），Add Entity ， 注意：这里根据关联添加多个实体<br>给表中添加属性，点击Attributes下方的‘+’号</li>
<li>创建模型文件<br>新建文件，选择CoreData -&gt; NSManaged Object subclass<br>根据提示，选择实体，注意：这里先选择被关联的实体，最后添加最上层的实体</li>
<li>通过代码，关联数据库和实体</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">/*</span></div><div class="line">    * 关联的时候，如果本地没有数据库文件，Ｃoreadata自己会创建</div><div class="line">    */</div><div class="line"></div><div class="line">    <span class="comment">// 1. 上下文</span></div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 上下文关连数据库</span></div><div class="line"></div><div class="line">    <span class="comment">// 2.1 model模型文件</span></div><div class="line">    <span class="built_in">NSManagedObjectModel</span> *model = [<span class="built_in">NSManagedObjectModel</span> mergedModelFromBundles:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 持久化存储调度器</span></div><div class="line">    <span class="comment">// 持久化，把数据保存到一个文件，而不是内存</span></div><div class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *store = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 设置CoreData数据库的名字和路径</span></div><div class="line">    <span class="built_in">NSString</span> *doc = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="built_in">NSString</span> *sqlitePath = [doc stringByAppendingPathComponent:<span class="string">@"company.sqlite"</span>];</div><div class="line"></div><div class="line">    [store addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:sqlitePath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    context.persistentStoreCoordinator = store;</div><div class="line">    _context = context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>添加元素 - Create</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)addEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 1. 创建两个部门 ios android</span></div><div class="line">    <span class="comment">//1.1 iOS部门</span></div><div class="line">    Department *iosDepart = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Department"</span> inManagedObjectContext:_context];</div><div class="line">    iosDepart.name = <span class="string">@"ios"</span>;</div><div class="line">    iosDepart.departNo = <span class="string">@"0001"</span>;</div><div class="line">    iosDepart.createDate = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">//1.2 Android部门</span></div><div class="line">    Department *andrDepart = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Department"</span> inManagedObjectContext:_context];</div><div class="line">    andrDepart.name = <span class="string">@"android"</span>;</div><div class="line">    andrDepart.departNo = <span class="string">@"0002"</span>;</div><div class="line">    andrDepart.createDate = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">//2. 创建两个员工对象 zhangsan属于ios部门 lisi属于android部门</span></div><div class="line">    <span class="comment">//2.1 zhangsan</span></div><div class="line">    Employee *zhangsan = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_context];</div><div class="line">    zhangsan.name = <span class="string">@"zhangsan"</span>;</div><div class="line">    zhangsan.height = @(<span class="number">1.90</span>);</div><div class="line">    zhangsan.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line">    zhangsan.depart = iosDepart;</div><div class="line"></div><div class="line">    <span class="comment">//2.2 lisi</span></div><div class="line">    Employee *lisi = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_context];</div><div class="line">    lisi.name = <span class="string">@"lisi"</span>;</div><div class="line">    lisi.height = @<span class="number">2.0</span>;</div><div class="line">    lisi.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line">    lisi.depart = andrDepart;</div><div class="line"></div><div class="line">    <span class="comment">//3. 保存数据库</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>读取信息 - Read<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)readEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 读取ios部门的员工</span></div><div class="line"></div><div class="line">    <span class="comment">// 1.FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.设置过滤条件</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"depart.name = %@"</span>,<span class="string">@"android"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 4.执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 部门 %@"</span>,emp.name,emp.depart.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、CoreData的模糊查询"><a href="#三、CoreData的模糊查询" class="headerlink" title="三、CoreData的模糊查询"></a>三、CoreData的模糊查询</h2><ul>
<li><p>模糊查询</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)readEmployee&#123;</div><div class="line">    <span class="comment">// 1.FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.设置排序</span></div><div class="line">    <span class="comment">// 按照身高的升序排序</span></div><div class="line">    <span class="built_in">NSSortDescriptor</span> *heigtSort = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"height"</span> ascending:<span class="literal">NO</span>];</div><div class="line">    request.sortDescriptors = @[heigtSort];</div><div class="line"></div><div class="line">    <span class="comment">// 3.模糊查询</span></div><div class="line">    <span class="comment">// 3.1 名字以"wang"开头</span></div><div class="line">    <span class="comment">//    NSPredicate *pre = [NSPredicate predicateWithFormat:@"name BEGINSWITH %@",@"wangwu1"];</span></div><div class="line">    <span class="comment">//    request.predicate = pre;</span></div><div class="line"></div><div class="line">    <span class="comment">// 名字以"1"结尾</span></div><div class="line">    <span class="comment">//    NSPredicate *pre = [NSPredicate predicateWithFormat:@"name ENDSWITH %@",@"1"];</span></div><div class="line">    <span class="comment">//    request.predicate = pre;</span></div><div class="line"></div><div class="line">    <span class="comment">// 名字包含"wu1"</span></div><div class="line">    <span class="comment">//    NSPredicate *pre = [NSPredicate predicateWithFormat:@"name CONTAINS %@",@"wu1"];</span></div><div class="line">    <span class="comment">//    request.predicate = pre;</span></div><div class="line"></div><div class="line">    <span class="comment">// like 匹配</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name like %@"</span>,<span class="string">@"*wu12"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 4.执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 身高 %@ 生日 %@"</span>,emp.name,emp.height,emp.birthday);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>分页查询</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">void</span>)pageSeacher&#123;</div><div class="line">    <span class="comment">// 1. FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 设置排序</span></div><div class="line">    <span class="comment">// 身高的升序排序</span></div><div class="line">    <span class="built_in">NSSortDescriptor</span> *heigtSort = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"height"</span> ascending:<span class="literal">NO</span>];</div><div class="line">    request.sortDescriptors = @[heigtSort];</div><div class="line"></div><div class="line">    <span class="comment">// 3. 分页查询</span></div><div class="line">    <span class="comment">// 总有共有15数据</span></div><div class="line">    <span class="comment">// 每次获取6条数据</span></div><div class="line">    <span class="comment">// 第一页 0,6</span></div><div class="line">    <span class="comment">// 第二页 6,6</span></div><div class="line">    <span class="comment">// 第三页 12,6 3条数据</span></div><div class="line"></div><div class="line">    <span class="comment">// 3.1 分页的起始索引</span></div><div class="line">    request.fetchOffset = <span class="number">12</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 3.2 分页的条数</span></div><div class="line">    request.fetchLimit = <span class="number">6</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 4. 执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 5. 遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 身高 %@ 生日 %@"</span>,emp.name,emp.height,emp.birthday);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四、多个数据库的使用"><a href="#四、多个数据库的使用" class="headerlink" title="四、多个数据库的使用"></a>四、多个数据库的使用</h2><p>创建多个数据库，即创建多个DataModel,一个数据库对应一个上下文,需要根据bundle名创建上下文。添加或读取信息，需要根据不同的上下文，访问不同的实体。</p>
<ul>
<li>关联数据库和实体</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 一个数据库对应一个上下文</span></div><div class="line">    _companyContext = [<span class="keyword">self</span> setupContextWithModelName:<span class="string">@"Company"</span>];</div><div class="line">    _weiboContext = [<span class="keyword">self</span> setupContextWithModelName:<span class="string">@"Weibo"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*  根据模型文件，返回一个上下文</div><div class="line">*/</div><div class="line">-(<span class="built_in">NSManagedObjectContext</span> *)setupContextWithModelName:(<span class="built_in">NSString</span> *)modelName&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 1. 上下文</span></div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 上下文关连数据库</span></div><div class="line">    <span class="comment">// 2.1 model模型文件</span></div><div class="line"></div><div class="line">    <span class="comment">// 注意：如果使用下面的方法，如果 bundles为nil 会把bundles里面的所有模型文件的表放在一个数据库</span></div><div class="line">    <span class="comment">//NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:nil];</span></div><div class="line"></div><div class="line">    <span class="comment">// 改为以下的方法获取：</span></div><div class="line">    <span class="built_in">NSURL</span> *companyURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:modelName withExtension:<span class="string">@"momd"</span>];</div><div class="line">    <span class="built_in">NSManagedObjectModel</span> *model = [[<span class="built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:companyURL];</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 持久化存储调度器</span></div><div class="line">    <span class="comment">// 持久化，把数据保存到一个文件，而不是内存</span></div><div class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *store = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 告诉Coredata数据库的名字和路径</span></div><div class="line">    <span class="built_in">NSString</span> *doc = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="built_in">NSString</span> *sqliteName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.sqlite"</span>,modelName];</div><div class="line">    <span class="built_in">NSString</span> *sqlitePath = [doc stringByAppendingPathComponent:sqliteName];</div><div class="line"></div><div class="line">    [store addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:sqlitePath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    context.persistentStoreCoordinator = store;</div><div class="line"></div><div class="line">    <span class="comment">// 3. 返回上下文</span></div><div class="line">    <span class="keyword">return</span> context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>添加元素<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)addEmployee&#123;</div><div class="line">    <span class="comment">// 1. 添加员工</span></div><div class="line">    Employee *emp = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_companyContext];</div><div class="line">    emp.name = <span class="string">@"zhagsan"</span>;</div><div class="line">    emp.height = @<span class="number">2.3</span>;</div><div class="line">    emp.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">// 直接保存数据库</span></div><div class="line">    [_companyContext save:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 发微博</span></div><div class="line">    Status *status =[<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Status"</span> inManagedObjectContext:_weiboContext];</div><div class="line"></div><div class="line">    status.text = <span class="string">@"发了一条微博！"</span>;</div><div class="line">    status.createDate = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    [_weiboContext save:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[高精度NSDecimalNumber]]></title>
      <url>http://yoursite.com/2014/08/25/2014/%E7%B2%BE%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>NSDecimalNumber Ios精度计算</p>
<p>.m文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Iimport &lt;Foundation/Foundation.h&gt;</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HighPrecision</span> : <span class="title">NSObject</span> </span></div><div class="line">+ (<span class="built_in">NSString</span> *)plusWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 加法</span></div><div class="line">+ (<span class="built_in">NSString</span> *)minuWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 减法</span></div><div class="line">+ (<span class="built_in">NSString</span> *)multiplyWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 乘法</span></div><div class="line">+ (<span class="built_in">NSString</span> *)devideWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 除法</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>.h文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HighPrecision</span></span></div><div class="line">+ (<span class="built_in">NSString</span> *)plusWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *b = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:B];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *h = [a decimalNumberByAdding: b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line">    <span class="built_in">NSString</span> *result = [h stringValue];</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSString</span> *)minuWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line"> 	<span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line"> 	<span class="built_in">NSDecimalNumber</span> *c = [a decimalNumberBySubtracting:b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line"> 	<span class="built_in">NSString</span> *result = [c stringValue];</div><div class="line"> 	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSString</span> *)multiplyWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line">   <span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line">   <span class="built_in">NSDecimalNumber</span> *b = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:B];</div><div class="line">   <span class="built_in">NSDecimalNumber</span> *j = [a decimalNumberByMultiplyingBy:b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line">   <span class="built_in">NSString</span> *result = [j stringValue];</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSString</span> *)devideWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *b = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:B];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *s = [a decimalNumberByDividingBy:b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line">    <span class="built_in">NSString</span> *result = [s stringValue];</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSDecimalNumberHandler</span> *)format</div><div class="line">&#123;</div><div class="line">   <span class="comment">// NSRoundPlain 貌似取整</span></div><div class="line">   <span class="comment">// NSRoundDown 只舍不入</span></div><div class="line">   <span class="comment">// NSRoundUp 只入不舍</span></div><div class="line">   <span class="comment">// NSRoundBankers 貌似四舍五入</span></div><div class="line">    </div><div class="line">   <span class="built_in">NSDecimalNumberHandler</span> *roundUp = [<span class="built_in">NSDecimalNumberHandler</span></div><div class="line">        decimalNumberHandlerWithRoundingMode:<span class="built_in">NSRoundBankers</span></div><div class="line">                                       scale:<span class="number">2</span></div><div class="line">                                       raiseOnExactness:<span class="literal">NO</span></div><div class="line">                                       raiseOnOverflow:<span class="literal">NO</span></div><div class="line">                                       raiseOnUnderflow:<span class="literal">NO</span></div><div class="line">                                       raiseOnDivideByZero:<span class="literal">YES</span>];</div><div class="line">    <span class="keyword">return</span> roundUp;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[copy修饰NSString的原因]]></title>
      <url>http://yoursite.com/2014/08/03/2014/NSString%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8copy%E4%BF%AE%E9%A5%B0/</url>
      <content type="html"><![CDATA[<h4 id="关于OC对象属性中的NSString类型为什么用copy修饰"><a href="#关于OC对象属性中的NSString类型为什么用copy修饰" class="headerlink" title="关于OC对象属性中的NSString类型为什么用copy修饰"></a>关于OC对象属性中的NSString类型为什么用copy修饰</h4><p>用copy修饰的区别，发生在用NSMutableString类型给NSString类型赋值时，为了防止赋值的属性内容被无意中修改，所以用copy修饰</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span>  </span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CopyStr</span> : <span class="title">NSObject</span>  </span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *strCopy;  </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *strStrong;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)testStr;  </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"CopyStr.h"</span>  </span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CopyStr</span>  </span></div><div class="line">- (<span class="keyword">void</span>)testStr  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">NSMutableString</span> *mString = [<span class="built_in">NSMutableString</span> string];  </div><div class="line">    [mString setString:<span class="string">@"original"</span>];  </div><div class="line">    <span class="keyword">self</span>.strCopy = mString;  </div><div class="line">    <span class="keyword">self</span>.strStrong = mString;  </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strCopy = %@"</span>, <span class="keyword">self</span>.strCopy); <span class="comment">// strCopy = original  </span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strStrong = %@"</span>, <span class="keyword">self</span>.strStrong); <span class="comment">// strCopy = original  </span></div><div class="line">    [mString setString:<span class="string">@"changed"</span>];  </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strCopy = %@"</span>, <span class="keyword">self</span>.strCopy); <span class="comment">// strCopy = original  </span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strStrong = %@"</span>, <span class="keyword">self</span>.strStrong); <span class="comment">// strCopy = changed  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span> </span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"CopyStr.h"</span>  </span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> charchar * argv[]) &#123;  </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;  </div><div class="line">        CopyStr *str = [[CopyStr alloc] init];  </div><div class="line">        [str testStr];  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，当用NSMutableString类型mString的对象给NSString类型str的对象赋值时，在mString改变后，用copy修饰的NSString对象strCopy的值不变，而用strong修饰的NSString对象strStrong的值变化了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIViewController的生命周期和属性]]></title>
      <url>http://yoursite.com/2014/06/01/2014/UIViewController%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<h4 id="一、UIViewController的生命周期和属性"><a href="#一、UIViewController的生命周期和属性" class="headerlink" title="一、UIViewController的生命周期和属性"></a>一、UIViewController的生命周期和属性</h4><p> 要了解UIViewController，先要弄清楚其生命周期。在面向对象的语言中，是对象，就一定要有生命周期，UIViewController也不例外，生命周期管理Controller的作用范围和时间，也管理其内对象的作用范围和时间。首先，UIViewController中与其生命周期有关的几个函数如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类的初始化方法  </span></div><div class="line">+ (<span class="keyword">void</span>)initialize;  </div><div class="line"><span class="comment">//对象初始化方法  </span></div><div class="line">- (<span class="keyword">instancetype</span>)init;  </div><div class="line"><span class="comment">//从归档初始化  </span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder;  </div><div class="line"><span class="comment">//加载视图  </span></div><div class="line">-(<span class="keyword">void</span>)loadView;  </div><div class="line"><span class="comment">//将要加载视图  </span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad;  </div><div class="line"><span class="comment">//将要布局子视图  </span></div><div class="line">-(<span class="keyword">void</span>)viewWillLayoutSubviews;  </div><div class="line"><span class="comment">//已经布局子视图  </span></div><div class="line">-(<span class="keyword">void</span>)viewDidLayoutSubviews;  </div><div class="line"><span class="comment">//内存警告  </span></div><div class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning;  </div><div class="line"><span class="comment">//已经展示  </span></div><div class="line">-(<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//将要展示  </span></div><div class="line">-(<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//将要消失  </span></div><div class="line">-(<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//已经消失  </span></div><div class="line">-(<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//被释放  </span></div><div class="line">-(<span class="keyword">void</span>)dealloc;</div></pre></td></tr></table></figure></p>
<p>上面这么多的函数，乍一看什么复杂，其实关系什么明朗，除了initialize,init和initWithCoder不是存在所有对象的声明周期中，其他函数都会在UIViewController的声明周期中有序的被调用。那么具体的调用顺序是怎样的呢，最好的办法是实践一下，通过编号打印，结果如下：<br>这是一个ViewController完整的声明周期，其实里面还有好多地方需要我们注意一下：</p>
<p>1：initialize函数并不会每次创建对象都调用，只有在这个类第一次创建对象时才会调用，做一些类的准备工作，再次创建这个类的对象，initalize方法将不会被调用，对于这个类的子类，如果实现了initialize方法，在这个子类第一次创建对象时会调用自己的initalize方法，之后不会调用，如果没有实现，那么它的父类将替它再次调用一下自己的initialize方法，以后创建也都不会再调用。因此，如果我们有一些和这个相关的全局变量，可以在这里进行初始化。<br>2：init方法和initCoder方法相似，只是被调用的环境不一样，如果用代码进行初始化，会调用init，从nib文件或者归档进行初始化，会调用initCoder。<br>3：loadView方法是开始加载视图的起始方法，除非手动调用，否则在ViewController的生命周期中没特殊情况只会被调用一次。<br>4：viewDidLoad方法是我们最常用的方法的，类中成员对象和变量的初始化我们都会放在这个方法中，在类创建后，无论视图的展现或消失，这个方法也是只会在将要布局时调用一次。<br>5：viewWillAppare：视图将要展现时会调用。<br>6：viewWillLayoutSubviews：在viewWillAppare后调用，将要对子视图进行布局。<br>7：viewDidLayoutSubviews：已经布局完成子视图。<br>8：viewDidAppare：视图完成显示时调用。<br>9：viewWillDisappare：视图将要消失时调用。<br>10：viewDidDisappare：视图已经消失时调用。<br>11：dealloc：controller被释放时调用。</p>
<p>注意：经过测试，从nib文件加载的controller，只要不释放，在每次viewWillAppare时都会调用layoutSubviews方法，有时甚至会在viewDidAppare后在调用一次layoutSubviews，而重点是从代码加载的则只会在开始调用一次，之后都不会，所以注意，在layoutSubviews中写相关的布局代码十分危险。</p>
<h4 id="二、从storyBoard加载UIViewController实例的传值陷阱"><a href="#二、从storyBoard加载UIViewController实例的传值陷阱" class="headerlink" title="二、从storyBoard加载UIViewController实例的传值陷阱"></a>二、从storyBoard加载UIViewController实例的传值陷阱</h4><p>我们知道，当我们从StoryBoard中加载ViewController时，我们在Controller中拖拽的视图是可以被初始化的，这里面有一点需要我们注意，如果我们需要向controller中视图进行传值设置，通过以下方法得到的Controller中，视图还没有被初始化创建出来：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ViewController2 * viewController2 = [[<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:[<span class="built_in">NSBundle</span> mainBundle]] instantiateViewControllerWithIdentifier:<span class="string">@"ViewController2"</span>];</div></pre></td></tr></table></figure></p>
<p>我们可以在ViewController2的storyBoard中拉一个label，然后关联到头文件中，如下打印，会发现我们得到controller时，里面的视图对象并没有进行创建:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ViewController2 * viewController2 = [[<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:[<span class="built_in">NSBundle</span> mainBundle]] instantiateViewControllerWithIdentifier:<span class="string">@"ViewController2"</span>];  </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,viewController2.label);  </div><div class="line">[<span class="keyword">self</span> presentViewController:viewController2 animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></p>
<p>可以想象，如果我们这时候需要对label进行一些属性设置，必然失败。有人提出可以在创建后，手动调以下loadView方法，我们试一下，结果如下：<br>可以看到，手动调用loadView后，label是被创建了出来，但是暴漏了一个更严重的问题，系统不在调用ViewDidLoad方法，这是十分有风险的，因为我们大部分的初始化代码都会放在这个方法里，所以手动调用loadView是一种错误的方法，apple文档声明对于loadView方法，我们从来都不要手动直接调用，那么我们如何实现创建后对成员对象进行传值设置呢，iOS9中增加了这样一个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadViewIfNeeded <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</div></pre></td></tr></table></figure></p>
<p>这个方法十分有用，调用这个方法，会将视图创建出来，并且不会忽略viewDidLoad的调用。<br>在iOS9中，UIViewController还增加了下面一个布尔值的属性，可以同来判断controller的view是否已经加载完成<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *viewIfLoaded <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</div></pre></td></tr></table></figure></p>
<h4 id="三、UIViewController与StroyBoard的相关相互方法"><a href="#三、UIViewController与StroyBoard的相关相互方法" class="headerlink" title="三、UIViewController与StroyBoard的相关相互方法"></a>三、UIViewController与StroyBoard的相关相互方法</h4><p>对于ViewConroller，我们一般有两种方式创建，一种是用纯代码的方式，一种是与StoryBoard关联，在UIViewController中，有许多方法方便我们与StoryBoard进行交互联系。</p>
<ul>
<li>ViewController直接在StoryBoard中进行跳转的传值<br>在StoryBoard中进行界面跳转是十分方便的，我们在StoryBoard中拉入两个ViewController，在一个上面添加一个按钮，点住按钮按住control，将鼠标拉到第二个controller上，会出现如下的跳转选项：<br>我们选择一个后，就会在两个controller之间建立一个跳转连接。当我们运行点击按钮后，会自动从第一个controller跳转到第二个controller。在UIViewController中有如下方法可以对是否跳转进行控制：<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)shouldPerformSegueWithIdentifier:(<span class="built_in">NSString</span> *)identifier sender:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个方法如果返回NO，自动跳转将不能进行，会被拒绝，需要注意的是，这个方法只会在自动的跳转时被调用，我们手动使用代码跳转StoryBoard中的连接关系时是不会被调用的，我们后面讨论。<br>在执行过上述方法后，如果返回YES，系统还会在执行如下一个方法，作为跳转前的准备，我们可以在这个方法中进行一些传值操作，这个方法无论使我们手动进行跳转还是storyboard中自动跳转，都会被执行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure></p>
<p>sugur对象中封装了相关的ViewController，可以使用segue.destinationViewController获取。<br>segue在StoryBoard中除了用来自动正向跳转外，我们还可以进行反向的跳转，类似pop和dismiss方法，这种segue被称为unwind sugue。例如，我们有一个controller1和一个controllert2，要使用unwind segue从2返回1，我们需要在2中实现如下格式的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)unwindSegueToViewController:(<span class="built_in">UIStoryboardSegue</span> *)segue &#123;  </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"unwindSegueToViewController"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法中的返回值必须为IBAction，参数必须是UIStoryboardSegue，方法名我们可以自己定义，之后在StoryBoard中的ViewController1中的Exit选项中，我们会发现多了一个这样的方法：<br>这样，当我们点击viewController2中的按钮时，就会返回到我们第一个ViewController1中了。<br>当然，在使用unwind segue方法时，也是会有一些回调帮助我们进行跳转前的设置和传值，UIViewController如下方法会在跳转前调用，返回NO，则不能进行跳转：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)canPerformUnwindSegueAction:(SEL)action fromViewController:(<span class="built_in">UIViewController</span> *)fromViewController withSender:(<span class="keyword">id</span>)sender&#123;  </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"canPerformUnwindSegueAction"</span>);  </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后会执行我们自定义的unwindSegue方法，这个方法中我们可以什么都不写，模式是会进行跳转的。</p>
<ul>
<li>使用代码跳转Storyboard中的controller<br>我们除了在Storyboard中拉拉扯扯可以进行控制器的跳转外，我们也可以使用代码来跳转Storyboard中segue连接关系。<br>在Storyboard中两个控制器间建立一个segue联系，我们可以取一个名字：在触发跳转的方法中，使用如下方法进行跳转，这里面的参数id就是我们取得segue的id：</li>
</ul>
<ul>
<li>(void)performSegueWithIdentifier:(NSString <em>)identifier sender:(nullable id)sender NS_AVAILABLE_IOS(5_0);<br>下面三个属性我们可以获取controller的nib文件名，其storyBoard和其Bundle:<br>@property(nullable, nonatomic, readonly, copy) NSString </em>nibName;<br>@property(nullable, nonatomic, readonly, strong) NSBundle <em>nibBundle;<br>@property(nullable, nonatomic, readonly, strong) UIStoryboard </em>storyboard NS_AVAILABLE_IOS(5_0);<h4 id="UIViewController之间的一些从属关系"><a href="#UIViewController之间的一些从属关系" class="headerlink" title="UIViewController之间的一些从属关系"></a>UIViewController之间的一些从属关系</h4>这部分的内容和方法可能我们接触用到的并不多，但是在某些情况下，使用这些方法可以大大的方便某些逻辑。</li>
</ul>
<ul>
<li><p>parentViewController<br>UIViewController里面封装了一个数组，可以存放其子ViewController，系统中使用的例子就是导航和tabBar这类的控制器，我们使用如下方法可以直接访问这些父的controller：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>,<span class="keyword">readonly</span>) <span class="built_in">UIViewController</span> *parentViewController;</div></pre></td></tr></table></figure>
</li>
<li><p>模态跳转中Controller的从属<br>在我们进行控制器的跳转时，只要控制器没有被释放，我们都可以顺藤摸瓜的找到它，使用如下两个方法：<br>//其所present的contller，比如，A和B两个controller，A跳转到B，那么A的presentedViewController就是B<br>@property(nullable, nonatomic,readonly) UIViewController <em>presentedViewController  NS_AVAILABLE_IOS(5_0);<br>//和上面的方法刚好相反，比如，A和B两个controller，A跳转到B，那么B的presentingViewController就是A<br>@property(nullable, nonatomic,readonly) UIViewController </em>presentingViewController NS_AVAILABLE_IOS(5_0);<br>了解了上面方法我们可以知道，对于反向传值这样的问题，我们根本不需要代理，block，通知等这样的复杂手段，只需要获取跳转到它的Controller，直接设置即可。举个例子，我们需要在第二个界面消失后，改变第一个界面的颜色，在第二个controller中只需要下面的代码即可实现 ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.presentingViewController.view.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:arc4random()%<span class="number">255</span>/<span class="number">255.0</span> green:arc4random()%<span class="number">255</span>/<span class="number">255.0</span> blue:arc4random()%<span class="number">255</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];  </div><div class="line">[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>UIViewController的模态跳转及动画特效<br>单纯的UIViewController中，我们使用最多的是如下的两个方法，一个向前跳转，一个向后返回:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)presentViewController:(<span class="built_in">UIViewController</span> *)viewControllerToPresent animated: (<span class="built_in">BOOL</span>)flag completion:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="keyword">void</span>))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);  </div><div class="line">- (<span class="keyword">void</span>)dismissViewControllerAnimated: (<span class="built_in">BOOL</span>)flag completion: (<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="keyword">void</span>))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从方法中，我们可以看到，有animated这个参数，来选择是否有动画特效，默认的动画特效是像抽屉一样从手机屏幕的下方向上弹起，当然，这个效果我们可以进行设置，UIViewController有如下一个属性来设置动画特效：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">UIModalTransitionStyle</span> modalTransitionStyle <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</div></pre></td></tr></table></figure></p>
<p>注意，这个要设置的是将要跳转到的controller，枚举如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIModalTransitionStyle</span>) &#123;  </div><div class="line">    <span class="built_in">UIModalTransitionStyleCoverVertical</span> = <span class="number">0</span>,<span class="comment">// 默认的，从下向上覆盖  </span></div><div class="line">    <span class="built_in">UIModalTransitionStyleFlipHorizontal</span> ,  <span class="comment">// 水平翻转  </span></div><div class="line">    <span class="built_in">UIModalTransitionStyleCrossDissolve</span>,    <span class="comment">// 溶解  </span></div><div class="line">    <span class="built_in">UIModalTransitionStylePartialCurl</span> ,     <span class="comment">// 从下向上翻页  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>除了跳转的效果，还有一个属性可以设置弹出的controler的填充效果，但是这个属性只在pad上有效，在iphone上无效，都是填充到整个屏幕：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">UIModalPresentationStyle</span> modalPresentationStyle <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2);  </div><div class="line"><span class="comment">// 枚举如下  </span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIModalPresentationStyle</span>) &#123;  </div><div class="line">    <span class="built_in">UIModalPresentationFullScreen</span> = <span class="number">0</span>,                   <span class="comment">// 填充整个屏幕  </span></div><div class="line">    <span class="built_in">UIModalPresentationPageSheet</span>,                        <span class="comment">// 留下状态栏  </span></div><div class="line">    <span class="built_in">UIModalPresentationFormSheet</span>,                        <span class="comment">// 四周留下变暗的空白  </span></div><div class="line">    <span class="built_in">UIModalPresentationCurrentContext</span>,                   <span class="comment">// 和跳转到它的控制器保持一致  </span></div><div class="line">    <span class="built_in">UIModalPresentationCustom</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0),<span class="comment">// 自定义  </span></div><div class="line">    <span class="built_in">UIModalPresentationOverFullScreen</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),  </div><div class="line">    <span class="built_in">UIModalPresentationOverCurrentContext</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),  </div><div class="line">    <span class="built_in">UIModalPresentationPopover</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0) __TVOS_PROHIBITED,  </div><div class="line">    <span class="built_in">UIModalPresentationNone</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0) = <span class="number">-1</span>,           </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用的三种种枚举]]></title>
      <url>http://yoursite.com/2014/05/21/2014/Enum/</url>
      <content type="html"><![CDATA[<p>Ios中常用的枚举的几种写法</p>
<p>###1.普通的枚举<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</div><div class="line">    XMtop,</div><div class="line">    XMbottom,</div><div class="line">&#125;XM;</div></pre></td></tr></table></figure></p>
<p>###2.自定义类型枚举<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, KSType) &#123;</div><div class="line">    KSTypeTop,</div><div class="line">    KSTypeBottom,</div><div class="line">    KSTypeRight,</div><div class="line">    KSTypeLeft,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>###3.移位枚举:一个参数可以传递多个值<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, SType) &#123;</div><div class="line">    STypeTop        = <span class="number">1</span>&lt;&lt;<span class="number">0</span>,</div><div class="line">    STypeBottom     = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,</div><div class="line">    STypeRight      = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,</div><div class="line">    STypeLeft       = <span class="number">1</span>&lt;&lt;<span class="number">3</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关键字const、static、extern]]></title>
      <url>http://yoursite.com/2014/05/20/2014/const-static-extern%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="const、static、extern简介"><a href="#const、static、extern简介" class="headerlink" title="const、static、extern简介"></a>const、static、extern简介</h3><h3 id="一、const与宏的区别（面试题）"><a href="#一、const与宏的区别（面试题）" class="headerlink" title="一、const与宏的区别（面试题）:"></a>一、const与宏的区别（面试题）:</h3><ul>
<li><code>const简介</code>:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。</li>
<li><code>编译时刻</code>:宏是预编译（编译之前处理），const是编译阶段。</li>
<li><code>编译检查</code>:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>
<li><code>宏的好处</code>:宏能定义一些函数，方法。 const不能。</li>
<li><code>宏的坏处</code>:使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>
</ul>
<p>注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。<br><img src="/Users/yuanzheng/Desktop/项目准备/课堂笔记/Const/Snip20151014_1.png" alt=""></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常见的常量：抽成宏</span></div><div class="line"><span class="meta">#define XMGAccount @<span class="meta-string">"account"</span></span></div><div class="line"></div><div class="line"><span class="meta">#define XMGUserDefault [NSUserDefaults standardUserDefaults]</span></div><div class="line"></div><div class="line"><span class="comment">// 字符串常量</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> account = <span class="string">@"account"</span>;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line"><span class="comment">// 偏好设置存储</span></div><div class="line"><span class="comment">// 使用宏</span></div><div class="line">[XMGUserDefault setValue:<span class="string">@"123"</span> forKey:XMGAccount];</div><div class="line"></div><div class="line"><span class="comment">// 使用const常量</span></div><div class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setValue:<span class="string">@"123"</span> forKey:account];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、const作用：限制类型"><a href="#二、const作用：限制类型" class="headerlink" title="二、const作用：限制类型"></a>二、const作用：限制类型</h3><ul>
<li>1.const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）</li>
<li><p>2.被const修饰的变量是只读的。</p>
</li>
<li><p><code>const基本使用</code></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line"><span class="comment">// 定义变量</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// 允许修改值</span></div><div class="line">a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// const两种用法</span></div><div class="line"><span class="comment">// const:修饰基本变量p</span></div><div class="line"><span class="comment">// 这两种写法是一样的，const只修饰右边的基本变量b</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></div><div class="line"></div><div class="line"><span class="comment">// 不允许修改值</span></div><div class="line">b = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// const:修饰指针变量*p，带*的变量，就是指针变量.</span></div><div class="line"><span class="comment">// 定义一个指向int类型的指针变量，指向a的地址</span></div><div class="line"><span class="keyword">int</span> *p = &amp;a;</div><div class="line"></div><div class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</div><div class="line"></div><div class="line">p = &amp;c;</div><div class="line"></div><div class="line"><span class="comment">// 允许修改p指向的地址，</span></div><div class="line"><span class="comment">// 允许修改p访问内存空间的值</span></div><div class="line">*p = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// const修饰指针变量访问的内存空间，修饰的是右边*p1，</span></div><div class="line"><span class="comment">// 两种方式一样</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1; <span class="comment">// *p1：常量 p1:变量</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1; <span class="comment">// *p1：常量 p1:变量</span></div><div class="line"></div><div class="line"><span class="comment">// const修饰指针变量p1</span></div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1:变量 p1:常量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 第一个const修饰*p1 第二个const修饰 p1</span></div><div class="line"><span class="comment">// 两种方式一样</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1：常量 p1：常量</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p1;  <span class="comment">// *p1：常量 p1：常量</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三、const开发中使用场景"><a href="#三、const开发中使用场景" class="headerlink" title="三、const开发中使用场景:"></a>三、const开发中使用场景:</h3><ul>
<li>1.当一个方法参数只读</li>
<li>2.定义只读全局变量</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"><span class="comment">// 定义只读全局常量</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> str  = <span class="string">@"123"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 当一个方法的参数，只读.</span></div><div class="line">- (<span class="keyword">void</span>)test:(<span class="built_in">NSString</span> * <span class="keyword">const</span>)name</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 指针只读,不能通过指针修改值</span></div><div class="line">- (<span class="keyword">void</span>)test1:(<span class="keyword">int</span> <span class="keyword">const</span> *)a&#123;</div><div class="line"></div><div class="line"><span class="comment">//    *a = 10;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 基本数据类型只读</span></div><div class="line">- (<span class="keyword">void</span>)test2:(<span class="keyword">int</span> <span class="keyword">const</span>)a&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="四、static和extern简单使用-要使用一个东西，先了解其作用"><a href="#四、static和extern简单使用-要使用一个东西，先了解其作用" class="headerlink" title="四、static和extern简单使用(要使用一个东西，先了解其作用)"></a>四、static和extern简单使用(要使用一个东西，先了解其作用)</h3><ul>
<li><code>static作用</code>:</li>
<li>修饰局部变量：</li>
</ul>
<p>1.延长局部变量的生命周期,程序结束才会销毁。</p>
<p>2.局部变量只会生成一份内存,只会初始化一次。</p>
<ul>
<li>修饰全局变量</li>
</ul>
<p>1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改</p>
<ul>
<li><code>extern作用</code>:</li>
<li>只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</li>
<li><code>extern工作原理</code>:</li>
<li>先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量：只有一份内存，所有文件共享，与extern联合使用。</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// static修饰全局变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)test</div><div class="line">&#123;</div><div class="line"><span class="comment">// static修饰局部变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">0</span>;</div><div class="line">age++;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line"></div><div class="line"></div><div class="line">    [<span class="keyword">self</span> test];</div><div class="line">    [<span class="keyword">self</span> test];</div><div class="line"></div><div class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,age);</div><div class="line">&#125;</div><div class="line">I</div></pre></td></tr></table></figure>
<h3 id="五、static与const联合使用"><a href="#五、static与const联合使用" class="headerlink" title="五、static与const联合使用"></a>五、static与const联合使用</h3><ul>
<li>static与const作用:声明一个只读的静态变量</li>
<li>开发使用场景:在<code>一个文件中</code>经常使用的字符串常量，可以使用static与const组合</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开发中常用static修饰全局变量,只改变作用域</span></div><div class="line"></div><div class="line"><span class="comment">// 为什么要改变全局变量作用域，防止重复声明全局变量。</span></div><div class="line"></div><div class="line"><span class="comment">// 开发中声明的全局变量，有些不希望外界改动，只允许读取。</span></div><div class="line"></div><div class="line"><span class="comment">// 比如一个基本数据类型不希望别人改动</span></div><div class="line"></div><div class="line"><span class="comment">// 声明一个静态的全局只读常量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// staic和const联合的作用:声明一个静态的全局只读常量</span></div><div class="line"></div><div class="line"><span class="comment">// iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量.</span></div><div class="line"></div><div class="line"><span class="comment">// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。</span></div><div class="line"><span class="keyword">static</span>  <span class="built_in">NSString</span> * <span class="keyword">const</span> key = <span class="string">@"name"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。</span></div><div class="line"></div><div class="line"><span class="keyword">static</span>  <span class="built_in">NSString</span> <span class="keyword">const</span> *key1 = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure>
<h3 id="六、extern与const联合使用"><a href="#六、extern与const联合使用" class="headerlink" title="六、extern与const联合使用"></a>六、extern与const联合使用</h3><ul>
<li>开发中使用场景:在<code>多个文件中</code>经常使用的同一个字符串常量，可以使用extern与const组合。</li>
<li>原因:</li>
<li>static与const组合：在每个文件都需要定义一份静态全局变量。</li>
<li>extern与const组合:只需要定义一份全局变量，多个文件共享。</li>
<li>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</li>
</ul>
<ul>
<li>GlobeConst.h</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> nameKey = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>GlobeConst.m</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> nameKey = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[静态库的制作ARM细节]]></title>
      <url>http://yoursite.com/2014/04/11/2014/%E9%9D%99%E6%80%81%E5%BA%93.a%E5%88%B6%E4%BD%9CARM%E7%BB%86%E8%8A%82/</url>
      <content type="html"><![CDATA[<h4 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h4><p>平时项目开发中，可能使用第三方提供的静态库.a，如果.a提供方技术不成熟，使用的时候就会出现问题，例如：<br>在真机上编译报错：No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=i386).<br>在模拟器上编译报错：No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 armv6).<br>要解决以上问题，就要了解一下Apple移动设备处理器指令集相关的一些细节知识。</p>
<h4 id="二、几个重要概念"><a href="#二、几个重要概念" class="headerlink" title="二、几个重要概念"></a>二、几个重要概念</h4><h5 id="1、ARM"><a href="#1、ARM" class="headerlink" title="1、ARM"></a>1、ARM</h5><p>ARM处理器，特点是体积小、低功耗、低成本、高性能，所以几乎所有手机处理器都基于ARM，在嵌入式系统中应用广泛。</p>
<h5 id="2、ARM处理器指令集"><a href="#2、ARM处理器指令集" class="headerlink" title="2、ARM处理器指令集"></a>2、ARM处理器指令集</h5><p>armv6｜armv7｜armv7s｜arm64都是ARM处理器的指令集，这些指令集都是向下兼容的，例如armv7指令集兼容armv6，只是使用armv6的时候无法发挥出其性能，无法使用armv7的新特性，从而会导致程序执行效率没那么高。<br>还有两个我们也很熟悉的指令集：i386｜x86_64 是Mac处理器的指令集，i386是针对intel通用微处理器32架构的。x86_64是针对x86架构的64位处理器。所以当使用iOS模拟器的时候会遇到i386｜x86_64，iOS模拟器没有arm指令集。</p>
<h5 id="3、目前iOS移动设备指令集"><a href="#3、目前iOS移动设备指令集" class="headerlink" title="3、目前iOS移动设备指令集"></a>3、目前iOS移动设备指令集</h5><p>arm64：iPhone5S｜ iPad Air｜ iPad mini2(iPad mini with Retina Display)<br>armv7s：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)<br>armv7：iPhone3GS｜iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4<br>armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch（一般不需要去支持）</p>
<h5 id="4、Xcode中指令集相关选项（Build-Setting中）"><a href="#4、Xcode中指令集相关选项（Build-Setting中）" class="headerlink" title="4、Xcode中指令集相关选项（Build Setting中）"></a>4、Xcode中指令集相关选项（Build Setting中）</h5><p>（1）Architectures<br>Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures.<br>指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。<br>（2）Valid Architectures<br>Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary.<br>限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定，例如：<br>比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。<br>再比如：将Architectures支持arm指令集设置为：armv7,armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s,arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s</p>
<p>在Xcode6.1.1里的 Valid Architectures  设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改。</p>
<ul>
<li>原因解释如下：<br>使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。<br>这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。<br>而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。<br>所以总结如下：  </li>
</ul>
<p>要发挥iPhone5s的64位性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。<br>（3）Build Active Architecture Only<br>指定是否只对当前连接设备所支持的指令集编译<br>当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如你设置此值为yes，用iphone4编译出来的是armv7版本的，iphone5也可以运行，但是armv6的设备就不能运行。  所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。<br>1）<br>Architectures:  armv7, armv7s, arm64<br>ValidArchitectures:  armv6, armv7s, arm64<br>生成二进制包支持的指令集： arm64<br>2）<br>Architectures: armv6, armv7, armv7s<br>Valid Architectures:  armv6, armv7s, arm64<br>生成二进制包支持的指令集： armv7s<br>3）<br>Architectures: armv7, armv7s, arm64<br>Valid Architectures: armv7，armv7s<br>这种情况是报错的，因为允许使用指令集中没有arm64。<br>注：如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。</p>
<h5 id="三、制作静态库-a是指令集选择"><a href="#三、制作静态库-a是指令集选择" class="headerlink" title="三、制作静态库.a是指令集选择"></a>三、制作静态库.a是指令集选择</h5><p>现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。<br>ValidArchitectures设置为：armv7｜armv7s｜arm64｜i386｜x86_64<br>Architectures设置不变（或根据你需要）:  armv7｜arm64<br>然后分别选择iOS设备和模拟器进行编译，最后找到相关的.a进行合包，使用lipo -create 真机库.a的路径 模拟器库.a的的路径 －output 合成库的名字.a（详情可以参考<a href="http://blog.csdn.net/lizhongfu2013/article/details/12648633）" target="_blank" rel="external">http://blog.csdn.net/lizhongfu2013/article/details/12648633）</a><br>这样就制作了一个通用的静态库.a</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UITableView优化]]></title>
      <url>http://yoursite.com/2014/03/30/2014/UITabView%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="IOS之UITableView优化-可重用机制"><a href="#IOS之UITableView优化-可重用机制" class="headerlink" title="IOS之UITableView优化-可重用机制"></a>IOS之UITableView优化-可重用机制</h2><p>目的：为了做到显示和数据分离， 通过重用单元格来达到节省内存的目的</p>
<h4 id="1-使用可重用机制创建cell（系统）"><a href="#1-使用可重用机制创建cell（系统）" class="headerlink" title="1.使用可重用机制创建cell（系统）"></a>1.使用可重用机制创建cell（系统）</h4><p>（1）定义可重用标识<br>（2）从可重用队列中取出cell<br>（3）若队列中无可用cell，利用alloc，init新建cell</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *reuseIndentifier = <span class="string">@"MyCell"</span>;  </div><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:reuseIndentifier];  </div><div class="line"><span class="keyword">if</span> (!cell) &#123;  </div><div class="line">    cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:reuseIndentifier];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h4><p>在UITableView的头文件中有visibleCells，存放当前显示的的cells<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>)<span class="built_in">NSArray</span>&lt;__kindofUITableViewCell *&gt; *visibleCells;</div></pre></td></tr></table></figure></p>
<p>当需要更新显示数据时，dequeueReusableCellWithIdentifier会先在可重用cell队列 reusable-cell queue中返回一个cell对象，若不存在，则返回nil；</p>
<h4 id="3-举例"><a href="#3-举例" class="headerlink" title="3.举例"></a>3.举例</h4><p>若一共有50条数据，屏幕最多显示10个cell。</p>
<p>(1）由于初始时 reusable-cell queue为空，所以用 [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 创建10次cell，并给cell指定同样的重用标识，并且10个cell全部都加入到 visiableCells数组。<br>(2）向下拖动tableView，当cell1完全移出屏 幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。 cell11加入到visiableCells，cell1移出visiableCells，cell1加入到 reusable-cell queue。<br>(3). 接着向下拖动tableView，因为 reusable-cell queue中已经有可用cell对象，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用的时候，tableView dequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。 cell1加入到visiableCells，cell1移出 reusable-cell queue；cell2移出 visiableCells，cell2加入到 reusable-cell queue。</p>
<h4 id="4-存在的问题"><a href="#4-存在的问题" class="headerlink" title="4.存在的问题"></a>4.存在的问题</h4><p>重取出来的cell是有可能已经捆绑过数据或者加过子视图的，造成视图叠加混乱的现象<br>解决：<br>(1）删除已有数据或子视图<br>(2）放弃了重用机制，每次根据indexPath获取对应的cell返回。<br>将方法:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:reuseIndentifier];</div></pre></td></tr></table></figure></p>
<p>替换为:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView cellForRowAtIndexPath:indexPath];</div></pre></td></tr></table></figure></p>
<h4 id="5-自定义cell的可重用机制使用"><a href="#5-自定义cell的可重用机制使用" class="headerlink" title="5.自定义cell的可重用机制使用"></a>5.自定义cell的可重用机制使用</h4><p>(1）在nib中加载MyCell这个类<br>(2）注册自定义的cell 的可重用标识<br>[objc] view plain copy 在CODE上查看代码片派生到我的代码片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"MyCell"</span> bundle:<span class="literal">nil</span>];   </div><div class="line">[tableView registerNib:nib forCellReuseIdentifier:reuseIdentity];</div></pre></td></tr></table></figure></p>
<p>用标识，并加入缓存池<br>(3)同上系统cell的使用</p>
<h2 id="IOS的tabViewCell的卡顿的解决方案"><a href="#IOS的tabViewCell的卡顿的解决方案" class="headerlink" title="IOS的tabViewCell的卡顿的解决方案"></a>IOS的tabViewCell的卡顿的解决方案</h2><ul>
<li>当你下滑时候是否发现有那么一点点的卡顿现成，特别是网络不好。可以利用UIScrollViewDelegate代理很好的解决这问题<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate</div><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以识别tableview禁止或者减速滑动结束的时候进行异步加载图片</p>
<ul>
<li>tabViewCell上面的图片透明度和圆角问题也会造成卡顿的情况</li>
<li>​使用不透明视图：没有其他渲染效果，可以提高页面渲染速度;</li>
<li>不要重复创建不必要的cell：​当新cell需要被显示时，就会调用tableView:cellForRowAtIndexPath:方法获取或创建一个cell；而不可视时，它又会被释放。由此可见，同一时间只需要存在一屏幕的cell即可，不需要为每一行创建一个cell;</li>
<li>​使用自定义的cell：默认的UITableViewCell包含了textLabel、detailTextLabel和imageView等view，然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。但是使用自定义的view，而非预定义的会明显快一些;</li>
<li>不要阻塞主线程：显然，主线程就只加载视图，把网络请求等耗时函数放到子线程;</li>
<li>​自动载入更新数据：例如每次载入50条信息，那就可以在滚动到倒数第10条以内时，加载更多信息;</li>
<li>不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的opaque属性设为YES（默认值）;</li>
<li>其中的特例包括背景色，它的alpha值应该为1（例如不要使用clearColor）；图像的alpha值也应该为1，或者在画图时设为不透明;</li>
<li>值得一提的是，cell被重用时，它内部绘制的内容并不会被自动清除，因此你可能需要调用setNeedsDisplayInRect:或setNeedsDisplay方法。<br>此外，在添加table cell的时候，如果不需要动画效果，最好不要使用insertRowsAtIndexPaths:withRowAnimation:方法，而是直接调用reloadData方法。因为前者会对所有indexPaths调用tableView:cellForRowAtIndexPath:方法，即便该 cell并不需要显示（不知道是不是bug），这就可能创建大量多余的cell。勘误：只是在模拟器上测试如此，真机调试时没有这种bug。</li>
<li>UITableViewCell包含了textLabel、detailTextLabel和imageView等view，而你还可以自定义一些视图放在它的contentView里。然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。<br>如果你的table cell包含图片，且数目较多，使用默认的UITableViewCell会非常影响性能。奇怪的是，使用自定义的view，而非预定义的view，明显会快些。当然，最佳的解决办法还是继承UITableViewCell，并在其drawRect:中自行绘制：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect </div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span>(image) &#123; </div><div class="line">        [image drawAtPoint:imagePoint]; </div><div class="line">        <span class="keyword">self</span>.image = <span class="literal">nil</span>; </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [placeHolder drawAtPoint:imagePoint]; </div><div class="line">    &#125; </div><div class="line">    [text drawInRect:textRect withFont:fontlineBreakMode:<span class="built_in">UILineBreakModeTailTruncation</span>]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>不过这样一来，你会发现选中一行后，这个cell就变蓝了，其中的内容就被挡住了。最简单的方法就是将cell的selectionStyle属性设为UITableViewCellSelectionStyleNone，这样就不会被高亮了。<br>此外还可以创建CALayer，将内容绘制到layer上，然后对cell的contentView.layer调用addSublayer:方法。这个例子中，layer并不会显著影响性能，但如果layer透明，或者有圆角、变形等效果，就会影响到绘制速度了。解决办法可参见后面的预渲染图像。</p>
</li>
<li><p>不要做多余的绘制工作<br>在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。<br>例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。</p>
</li>
<li><p>预渲染图像。<br>你会发现即使做到了上述几点，当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕，详细做法可见。<br><a href="http://www.keakon.net/2011/07/26/利用预渲染加速iOS设备的图像显示" target="_blank" rel="external">《利用预渲染加速iOS设备的图像显示》</a></p>
</li>
<li><p>不要阻塞主线程<br>做到前几点后，你的table view滚动时应该足够流畅了，不过你仍可能让用户感到不爽。常见的现象就是在更新数据时，整个界面卡住不动，完全不响应用户请求。<br>出现这种现象的原因就是主线程执行了耗时很长的函数或方法，在其执行完毕前，无法绘制屏幕和响应用户请求。其中最常见的就是网络请求了，它通常都需要花费数秒的时间，而你不应该让用户等待那么久。<br>解决办法就是使用多线程，让子线程去执行这些函数或方法。这里面还有一个学问，当下载线程数超过2时，会显著影响主线程的性能。因此在使用ASIHTTPRequest时，可以用一个NSOperationQueue来维护下载请求，并将其maxConcurrentOperationCount设为2。而NSURLRequest则可以配合GCD来实现，或者使用NSURLConnection的setDelegateQueue:方法。<br>当然，在不需要响应用户请求时，也可以增加下载线程数，以加快下载速度：</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span>*)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate &#123; <span class="keyword">if</span> (!decelerate) &#123;queue.maxConcurrentOperationCount = <span class="number">5</span>; &#125; &#125; -(<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView &#123;queue.maxConcurrentOperationCount = <span class="number">5</span>; &#125; -(<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;queue.maxConcurrentOperationCount = <span class="number">2</span>; &#125;</div></pre></td></tr></table></figure>
<p>此外，自动载入更新数据对用户来说也很友好，这减少了用户等待下载的时间。例如每次载入50条信息，那就可以在滚动到倒数第10条以内时，加载更多信息：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span>*)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cellforRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath </div><div class="line">&#123; </div><div class="line">    <span class="comment">// update方法获取到结果后，设置updating为NO</span></div><div class="line">    <span class="keyword">if</span> (count - indexPath.row &lt; <span class="number">10</span>&amp;&amp; !updating) &#123; </div><div class="line">        updating = <span class="literal">YES</span>; [<span class="keyword">self</span> update]; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一点要注意的就是当图片下载完成后，如果cell是可见的，还需要更新图像：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *indexPaths = [<span class="keyword">self</span>.tableViewindexPathsForVisibleRows];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSIndexPath</span> *visibleIndexPath <span class="keyword">in</span> indexPaths) &#123;</div><div class="line">    <span class="comment">// 也可不遍历，直接与头尾相比较，看是否在中间即可。</span></div><div class="line">    <span class="keyword">if</span> (indexPath == visibleIndexPath) &#123;</div><div class="line">        MyTableViewCell *cell = (MyTableViewCell*)[<span class="keyword">self</span>.tableView cellForRowAtIndexPath:indexPath]; </div><div class="line">        cell.image = image;</div><div class="line">        [cellsetNeedsDisplayInRect:imageRect]; </div><div class="line">        <span class="keyword">break</span>; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后还是前面所说过的insertRowsAtIndexPaths:withRowAnimation:方法，插入新行需要在主线程执行，而一次插入很多行的话（例如50行），会长时间阻塞主线程。而换成reloadData方法的话，瞬间就处理完了。</p>
<ul>
<li>如果只是更新某组的话，使用reloadSection进行局部更新</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[setNeedsDisplay & setNeedsLayout]]></title>
      <url>http://yoursite.com/2014/02/27/2014/setNeedsDisplay%20&%20setNeedsLayout/</url>
      <content type="html"><![CDATA[<h4 id="UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout"><a href="#UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout" class="headerlink" title="UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout"></a>UIView常用的一些方法小记之setNeedsDisplay和setNeedsLayout</h4><p>1,UIView的setNeedsDisplay和setNeedsLayout方法<br>首先两个方法都是异步执行的。而setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到  UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，<br>就可以  处理子视图中的一些数据。<br>综上所诉，setNeedsDisplay方便绘图，而layoutSubViews方便出来数据。<br>layoutSubviews在以下情况下会被调用：<br>1、init初始化不会触发layoutSubviews。<br>2、addSubview会触发layoutSubviews。<br>3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。<br>4、滚动一个UIScrollView会触发layoutSubviews。<br>5、旋转Screen会触发父UIView上的layoutSubviews事件。<br>6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。<br>7、直接调用setLayoutSubviews。</p>
<p>drawRect在以下情况下会被调用：<br>1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).<br>2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。<br>3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。<br>4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。<br>以上1,2推荐；而3,4不提倡</p>
<p>drawRect方法使用注意点：<br>1、若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。<br>2、若使用calayer绘图，只能在drawInContext: 中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法<br>3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios编程词汇大全]]></title>
      <url>http://yoursite.com/2014/02/24/2014/words/</url>
      <content type="html"><![CDATA[<p>A2A integration [,inti’ɡreiʃən]        A2A整合<br>abstract [‘æbstrækt, æb’strækt]  抽象的<br>abstract base [beis] class (ABC)抽象基类<br>abstract class 抽象类<br>abstraction [æb’strækʃən] 抽象、抽象物、抽象性<br>access [‘ækses, ‘æksəs, æk’ses]存取、访问<br>access level[‘levəl]访问级别<br>access function [‘fʌŋkʃən]访问函数<br>account [ə’kaunt]账户<br>action [‘ækʃən]动作<br>activate [‘æktiveit] 激活<br>active [‘æktiv]活动的<br>actual parameter [‘æktʃuəl] [pə’ræmitə] 实参<br>adapter [ə’dæptə]适配器<br>add-in 插件<br>address [ə’dres]地址<br>address space     地址空间<br>address-of operator [‘ɔpəreitə]取地址操作符<br>ADL (argument-dependent lookup) [‘ɑ:ɡjumənt] [di’pendənt]<br>ADO(ActiveX Data Object)ActiveX数据对象<br>advanced [əd’vænst]高级的<br>aggregation [,æɡri’ɡeiʃən] 聚合、聚集                         1<br>algorithm [‘ælgə’rɪðəm] 算法<br>alias [ˈeɪli:əs] 别名<br>align [ə’lain]排列、对齐<br>allocate [ˈæləkeit] 分配、配置<br>allocator[‘æləukeitə]分配器、配置器<br>angle bracket [‘æŋɡl] [‘brækit]尖括号<br>annotation [,ænəu’teiʃən]注解、评注<br>API (Application Programming Interface) 应用(程序)编程接口<br>app domain (application domain) [æp] [do’men]应用域<br>application [,æpli’keiʃən]应用、应用程序<br>application framework [‘freimwə:k] 应用程序框架<br>appearance [ə’piərəns]外观<br>append [ə’pend]附加<br>architecture [‘ɑ:kitektʃə]架构、体系结构<br>archive file [‘ɑ:kaiv] [‘fail] 归档文件、存档文件<br>argument[‘ɑ:ɡjumənt]引数(传给函式的值)。参见parameter [pə’ræmitə]<br>array [ə’rei]数组<br>arrow operator [‘ærəu] [‘ɔpəreitə]箭头操作符<br>ASP(Active Server [‘sɝvɚ] Page)活动服务器页面<br>ASP.NET worker process [‘prəuses, ‘prɔ-] ASP.NET工作者进程<br>assembly [ə’sembli] 装配件、配件<br>assembly language   汇编语言                                   2<br>assembly manifest [‘mænifest]装配件清单<br>assert(ion) [ə’sə:t] assertion [ə’sɝʃən] 断言<br>assign [ə’sain] 赋值<br>assignment [ə’sainmənt]赋值、分配<br>assignment operator 赋值操作符=<br>associated [ə’səuʃi,eitid] 相关的、相关联的<br>associative container [ə’səuʃjətiv] [kən’teinə]关联式容器(对应sequential container [si’kwenʃəl])<br>asynchronous [eɪˈsɪŋkrənəs] 异步的<br>atomic [ə’tɔmik]原子的<br>atomic operation   原子操作<br>attribute[ ‘ætribju:t]  特性、属性<br>authentication [ɔːˌθentɪˈkeɪʃn]service 验证服务<br>authorization [,ɔ:θərai’zeiʃən, -ri’z-]授权<br>audio [‘ɔ:diəu]  音频<br>A.I.    人工智能artificial intelligence [,ɑ:ti’fiʃəl] [in’telidʒəns]<br>B2B integration [,inti’ɡreiʃən] B2B整合、B2B集成(business-to-business integration)<br>background   背景、后台(进程)<br>backward compatible [kəm’pætəbl] 向后兼容、向下兼容<br>backup   备份<br>backup device[di’vais]备份设备                                       3<br>backup file 备份文件<br>bandwidth [‘bændwidθ] 带宽<br>base class 基类<br>base type 基类型<br>batch [bætʃ]批处理<br>BCL (base class library)基类库<br>binary [‘bainəri]二进制<br>binary search 二分查找<br>binary tree 二叉树<br>binary function 双参函数<br>binary large object二进制大对象<br>binary operator 二元操作符<br>binding [‘baindiŋ] 绑定<br>bit 位<br>bitmap [‘bit,mæp]位图<br>bitwise 按位…<br>bitwise copy       为单元进行复制；位元逐一复制,按位拷<br>bitwise operation 按位运算<br>block 块、区块、语句块<br>bookkeeping [‘buk,ki:piŋ]簿记<br>boolean [‘bu:liən]布林值(真假值，true或false)<br>border [‘bɔ:də]边框                                               4<br>bounds checking [baʊndz] [‘tʃekiŋ]边界检查<br>boxing 装箱、装箱转换<br>brace [breis]大括号 curly [‘kə:li] brace花括号<br>bracket [‘brækit] (square [skwεə] brakcet) 中括号、方括号<br>breakpoint [‘breikpɔint]断点<br>browser applications [‘brauzə] [æpli’keiʃəns]浏览器应用(程序)<br>browser-accessible [ək’sesəbl] application 可经由浏览器访问的应用程序<br>build 编连(专指编译和连接<br>built-in [,bɪlt ‘ɪn]内建、内置<br>bus 总线<br>business 业务、商务(看场合)<br>business Logic [‘lɔdʒik]业务逻辑<br>business rules 业务规则<br>buttons 按钮<br>bug 臭虫<br>by/through 通过<br>byte 位元组(由8 bits组成)<br>cache [kæʃ] 高速缓存<br>calendar [‘kælində]日历<br>call 调用<br>callback [‘kɔ:lbæk] 回调<br>call-level interface (CLI)调用级接口(CLI)                            5<br>call operator 调用操作符<br>candidate key [‘kændideit] 候选键 (for database)<br>cascading delete [kæ’skeidiŋ] 级联删除 (for database)<br>cascading update 级联更新 (for database)<br>casting [‘kɑ:stiŋ]  转型、造型转换<br>catalog [‘kætəlɔɡ]  目录<br>chain [tʃein] 链(function calls)<br>character [‘kærəktə] 字符<br>character format [ˈfɔ:mæt]  字符格式<br>character set     字符集<br>CHECK constraints [kən’streint]    CHECK约束 (for database)<br>checkpoint [‘tʃekpɔint] 检查点 (for database)<br>check box 复选框<br>check button 复选按钮<br>child class 子类<br>CIL (common intermediate [,intə’mi:djət, -dieit] language)通用中间语言、通用中介语言<br>class    类<br>class declaration [,deklə’reiʃən] 类声明<br>class definition [,defi’niʃən]  类定义<br>class derivation [,deri’veiʃən] list 类继承列表<br>class factory    类厂                                        6<br>class hierarchy [‘haiə,rɑ:ki]类层次结构<br>class library    类库<br>class loader     类装载器<br>class template [‘templit]类模板<br>class template partial [‘pɑ:ʃəl] specializations [,spɛʃəlɪ’zeʃən] 类模板部分特化<br>class template specializations         类模板特化<br>classification [ˌklæsifiˈkeiʃən] 分类<br>clause [klɔ:z]子句<br>client [‘klaiənt] application 客户端应用程序<br>client cursor [‘kə:sə] 客户端游标 (for database)<br>code page 代码页<br>cleanup   清理、清除<br>CLI (Common Language Infrastructure [‘infrə,strʌktʃə])   通用语言基础设施<br>client [‘klaiənt]客户、客户端<br>client area 客户区<br>client-server 客户机/服务器、客户端/服务器<br>clipboard [‘klipbɔ:d]剪贴板<br>clone [kləun]克隆<br>CLS (common language specification [,spesifi’keiʃən]) 通用语言规范<br>code access security 代码访问安全<br>COFF (Common Object File Format)    通用对象文件格式             7<br>collection [kə’lekʃən]集合<br>COM (Component [kəm’pəunənt] Object Model) 组件对象模型<br>combo [‘kɔmbəu] box 组合框<br>command [kə’mɑ:nd] line 命令行<br>comment[ˈkɔment] 注释<br>commit [kə’mit]提交 (for database)<br>communication [kə,mju:ni’keiʃən]通讯<br>compatible [kəm’pætəbl]兼容<br>compiler [kəm’pail]编译器<br>compile time 编译期、编译时<br>component[kəm’pəunənt]组件<br>composite [‘kɔmpəzit] index 复合索引、组合索引 (for database)<br>composite key 复合键、组合键 (for database)<br>composition [,kɔmpə’ziʃən]复合、组合<br>concept [‘kɔnsept]概念<br>concrete[kən’kri:t, ‘kɔnkri:t]具体的<br>concrete class 具体类<br>concurrency [kən’kʌrənsi]并发、并发机制<br>constraint [kən’streint]约束 (for database)<br>configuration [kən,fiɡju’reiʃən]配置、组态<br>connection [kə’nekʃən] 连接 (for database)<br>connection pooling 连接池                                        8<br>console [kən’səul] 控制台<br>constant [‘kɔnstənt]常量<br>construct [kən’strʌkt]构件、成分、概念、构造（for language）<br>constructor (ctor) [kɔn’strʌktə]构造函数、构造器<br>container [kən’teinə] 容器<br>containment[kən’teinmənt]包容<br>context [‘kɔntekst]环境、上下文<br>control [kən’trəul]控件<br>cookie [‘kuki] (不译)<br>copy    拷贝<br>CORBA   通用对象请求中介架构<br>(Common Object Request[ri’kwest] Broker Architecture)<br>cover   覆盖、涵盖<br>create/creation [kri:’eiʃən]创建、生成<br>crosstab query [‘kwiəri]交叉表查询 (for database)<br>CRTP<br>(curiously recurring [rɪ’kɝɪŋ] template [‘templit] pattern [‘pætən])<br>CTS (common type system)通用类型系统<br>cube [kju:b]多维数据集 (for database)<br>cursor [‘kə:sə] 光标<br>cursor 游标 (for database)<br>custom [‘kʌstəm] 定制、自定义                            9<br>data   数据<br>data connection   数据连接 (for database)<br>Data Control Language (DCL) 数据控制语言(DCL) (for database)<br>Data Definition [,defi’niʃən] Language (DDL) 数据定义语言(DDL) (for database)<br>data dictionary [‘dikʃənəri]数据字典 (for database)<br>data dictionary view 数据字典视图 (for database)<br>data file 数据文件 (for database)<br>data integrity [inˈteɡriti] 数据完整性 (for database)<br>data manipulation [mə,nipju’leiʃən] language (DML)数据操作语言(DML) (for database)<br>data mart 数据集市 (for database)<br>data pump [pʌmp]数据抽取 (for database)<br>data scrubbing [skrʌbliŋ]数据清理 (for database)<br>data source [sɔ:s]数据源 (for database)<br>Data source name (DSN) 数据源名称(DSN) (for database)<br>data warehouse [‘wεəhaus, ‘wεəhauz, -haus]数据仓库 (for database)<br>dataset   数据集 (for database)<br>database 数据库 (for database)<br>database catalog 数据库目录 (for database)<br>database diagram [‘daiəɡræm] 数据关系图 (for database)<br>database file     数据库文件 (for database)                        10<br>database object   数据库对象 (for database)<br>database owner    数据库所有者 (for database)<br>database project [‘prɔdʒekt]数据库工程 (for database)<br>database role     数据库角色 (for database)<br>database schema [‘ski:mə]数据库模式、数据库架构 (for database)<br>database script [skript]数据库脚本 (for database)<br>data-bound       数据绑定 (for database)<br>data-aware control数据感知控件 (for database)<br>data member   数据成员、成员变量<br>dataset       数据集 (for database)<br>data source   数据源 (for database)<br>data structure[‘strʌktʃə]数据结构<br>data table    数据表 (for database)<br>datagram [‘deitəɡræm]数据报文<br>DBMS (database management system)数据库管理系统 (for database)<br>DCOM (distributed [di’stribjutid] COM)分布式COM<br>dead lock 死锁 (for database)<br>Deallocate [de’elkeit]归还<br>debug      调试<br>debugger    调试器<br>decay [di’kei]退化<br>decision [di’siʒən] support [sə’pɔ:t] 决策支持                11<br>declaration [,deklə’reiʃən]声明<br>Declarative[dɪˈklærətɪv]referential [,refə’renʃəl] integrity [in’teɡrəti] (DRI)声明引用完整性(DRI) (for database)<br>deduction [di’dʌkʃən]推导<br>Deafault [di’fɔ:lt] constraint默认约束 (for database)<br>default database 默认数据库 (for database)<br>default instance [‘instəns]默认实例 (for database)<br>default result set 默认结果集 (for database)<br>default     缺省、默认值<br>defer       推迟<br>definition [,defi’niʃən]定义<br>delegate [‘deliɡeit]委托<br>delegation 委托<br>dependent name<br>deploy [di:’plɔi]部署<br>dereference [di’refərəns]解引用<br>dereference operator (提领)运算子<br>derived class 派生类<br>design by contract 契约式设计<br>design pattern [‘pætən]设计模式<br>destroy [di’strɔi]销毁<br>destructor(dtor) [di’strʌktə]析构函数、析构器                12<br>device [di’vais]设备<br>DHTML<br>(dynamic [dai’næmik]HyperText [‘haipətekst] Markup Language)动态超文本标记语言<br>dialog [‘daiəlɔɡ]对话框<br>digest[daiˈdʒest]摘要<br>digital 数字的<br>DIME<br>(Direct Internet Message Encapsulation [in,-kæpsə’leiʃən])<br>直接Internet消息封装<br>directive [di’rektiv, dai-] (编译)指示符<br>directory [di’rektəri, dai-]目录<br>dirty pages脏页 (for database)<br>dirty read 脏读 (for database)<br>disassembler [,disə’semblə]反汇编器<br>DISCO (Discovery of Web Services)Web Services的查找<br>disk 盘<br>dispatch [dis’pætʃ]调度、分派、派发（我喜欢“调度”）<br>DISPID (Dispatch[dis’pætʃ] Identifier [ai’dentifaiə])分派标识符<br>distributed [di’stribjutid] computing [kəm’pju:tiŋ]分布式计算<br>distributed query分布式查询 (for database)<br>DNA (Distributed interNet Application)                            13<br>分布式网间应用程序<br>document [‘dɔkjumənt, ‘dɔkjument]文档<br>DOM (Document Object Model)文档对象模型<br>dot operator [‘ɔpəreitə] (圆)点操作符<br>driver 驱动(程序)<br>DTD (document type definition [,defi’niʃən]) 文档类型定义<br>double-byte character set (DBCS)双字节字符集(DBCS)<br>dump [dʌmp] 转储<br>dump file 转储文件<br>dynamic [dai’næmik] cursor [‘kə:sə]动态游标 (for database)<br>dynamic filter [filtə]动态筛选 (for database)<br>dynamic locking   动态锁定 (for database)<br>dynamic recovery [ri’kʌvəri] 动态恢复 (for database)<br>dynamic snapshot [‘snæpʃɔt] 动态快照 (for database)<br>dynamic SQL statements [‘steitmənt]动态SQL语句 (for database)<br>dynamic assembly 动态装配件、动态配件<br>dynamic binding 动态绑定<br>EAI (enterprise[ˈentəpraɪz] application integration [,inti’ɡreiʃən])企业应用程序集成(整合)<br>EBCO (empty base class optimization [,ɔptimai’zeiʃən, -mi’z-])空基类优化（机制）<br>e-business   电子商务                                  14<br>EDI (Electronic [,ilek’trɔnik] Data Interchange [,intə’tʃeindʒ, ‘intətʃeindʒ])电子数据交换<br>efficiency [i’fiʃənsi]效率<br>efficient [i’fiʃənt]高效<br>end-to-end authentication [ɔː,θentɪ’keɪʃən] 端对端身份验证<br>end user 最终用户<br>engine   引擎<br>entity [‘entəti] 实体<br>encapsulation [in,-kæpsə’leiʃən]封装<br>enclosing [ɪn’kləʊziŋ] class 外围类别(与巢状类别 nested class有关)<br>enum (enumeration [i,nju:mə’reiʃən]) 枚举<br>enumerators [i’nju:mə,reitəz] 枚举成员、枚举器<br>equal [‘i:kwəl]相等<br>equality[i:’kwɔləti]相等性<br>equality operator 等号操作符<br>error[‘erə] log错误日志 (for database)<br>escape code 转义码<br>escape character 转义符、转义字符<br>exclusive [ik’sklu:siv] lock   排它锁 (for database)<br>explicit [ik’splisit] transaction [træn’zækʃən] 显式事务 (for database)<br>evaluate [i’væljueit]评估<br>event    事件                                          15<br>event driven 事件驱动的<br>event handler [‘hændlə]事件处理器<br>evidence [‘evidəns]证据<br>exception [ik’sepʃən] 异常<br>exception declaration [,deklə’reiʃən]异常声明<br>exception handling [‘hændliŋ]异常处理、异常处理机制<br>exception-safe 异常安全的<br>exception specification [,spesifi’keiʃən]异常规范<br>exit     退出<br>explicit [ik’splisit] 显式<br>explicit specialization [,speʃəlai’zeiʃən] 显式特化<br>export [ik’spɔ:t]导出<br>expression [ik’spreʃən]表达式<br>facility [fə’siliti] 设施、设备<br>fat client 胖客户端<br>feature [‘fi:tʃə]特性、特征<br>fetch [fetʃ]提取<br>field 字段(java)<br>field 字段 (for database)<br>field length 字段长度 (for database)<br>file   文件<br>filter [filtə]筛选 (for database)                                16<br>finalization [ˌfaɪnl’aɪzeʃən] 终结<br>firewall [‘faiəwɔ:l] 防火墙<br>finalizer [‘faɪnəlaɪzə] 终结器<br>firmware [‘fə:mwεə]固件<br>flag     标记<br>flash memory 闪存<br>flush [flʌʃ] 刷新<br>font 字体<br>foreign key (FK) 外键(FK) (for database)<br>form   窗体<br>formal parameter [pə’ræmitə] 形参<br>forward declaration 前置声明<br>forward-only 只向前的<br>forward-only cursor 只向前游标 (for database)<br>fragmentation [,fræɡmen’teiʃən] 碎片 (for database)<br>framework [‘freimwə:k] 框架<br>full specialization 完全特化<br>function 函数<br>function call operator (即operator ()) 函数调用操作符<br>function object 函数对象<br>function overloaded [‘əuvə’ləudid] resolution[,rezə’lu:ʃən]函数重载决议<br>functionality [,fʌŋkʃə’næliti]功能                                 17<br>function template函数模板<br>functor [‘fʌŋktə]仿函数<br>GAC (global assembly cache [kæʃ])<br>全局装配件缓存、全局配件缓存<br>GC (Garbage collection)<br>垃圾回收(机制)、垃圾收集(机制)<br>game游戏<br>generate [‘dʒenəreit]生成<br>generic [dʒi’nerik]泛化的、一般化的、通用的<br>generic algorithm[‘ælɡəriðəm]通用算法<br>genericity [‘dʒenerisity] 泛型<br>getter (相对于 setter)取值函数<br>global [‘ɡləubəl]全局的<br>global object 全局对象<br>global scope [skəup] resolution operator 全局范围解析操作符<br>grant [ɡrɑ:nt, ɡrænt]授权 (for database)<br>granularity[ˌɡrænjuˈlæriti] 粒度<br>group       组、群<br>group box   分组框<br>GUI   图形界面<br>GUID (Globally Unique [ju:’ni:k] Identifier [ai’dentifaiə]) 全球唯一标识符<br>hand shaking   握手                                       18<br>handle     句柄<br>handler    处理器<br>hard-coded 硬编码的<br>hard-copy 截屏图<br>hard disk 硬盘<br>hardware   硬件<br>hash table 散列表、哈希表<br>header file头文件<br>heap [hi:p]堆<br>help file 帮助文件<br>hierarchy [‘haiə,rɑ:ki]层次结构、继承体系<br>hierarchical [,haiə’rɑ:kikəl] data 阶层式数据、层次式数据<br>hook[huk]钩子<br>Host (application)宿主(应用程序)<br>hot key   热键<br>hyperlink [‘haipəliŋk]超链接<br>HTML (HyperText [‘haipətekst] Markup Language) 超文本标记语言<br>HTTP pipeline [‘paip,lain]    HTTP管道<br>HTTP (HyperText Transfer Protocol) 超文本传输协议<br>icon   图标<br>IDE (Integrated Development Environment)集成开发环境<br>IDL (Interface Definition Language)    接口定义语言               19<br>identifier [ai’dentifaiə]标识符<br>idle [‘aidl] time 空闲时间<br>if and only if当且仅当<br>IL (Intermediate Language) 中间语言、中介语言<br>image 图象<br>IME   输入法<br>immediate [i’mi:diət] base      直接基类<br>immediate derived [di’raivd]   直接派生类<br>immediate updating 即时更新 (for database)<br>implicit [im’plisit] transaction [træn’zækʃən]隐式事务 (for database)<br>incremental[ˌɪŋkrəˈmentl] update 增量更新 (for database)<br>index          索引 (for database)<br>implement [‘implimənt, ‘impliment]实现<br>implementation [,implimen’teiʃən] 实现、实现品<br>implicit [im’plisit]隐式<br>import         导入<br>increment [‘inkrimənt] operator 增加操作符<br>infinite [‘infinət] loop       无限循环<br>infinite recursive [ri’kə:siv] 无限递归<br>information      信息<br>infrastructure [‘infrə,strʌktʃə]基础设施<br>inheritance [in’heritəns]继承、继承机制                        20<br>inline [‘in,lain]内联<br>inline expansion 内联展开<br>initialization [i,niʃəlai’zeiʃən]初始化<br>initialization list 初始化列表、初始值列表<br>initialize [ɪ’nɪʃəlaɪz]初始化<br>inner [‘inə] join      内联接 (for database)<br>in-place active 现场激活<br>instance [‘instəns]实例<br>instantiated [ɪns’tænʃɪetid]    具现化、实体化(常应用于template)<br>instantiation[inˌstænʃiˈeiʃən]具现体、具现化实体(常应用于template)<br>integrate [ˈɪntɪgreɪt]       集成、整合<br>integrity [ɪnˈtegrəti]      完整性、一致性<br>integrity constraint完整性约束 (for database)<br>interprocess communication (IPC)进程间通讯(IPC)<br>interacts [,intə’rækts]交互<br>interface 接口<br>for GUI 界面<br>interoperability[ˈintərˌɔpərəˈbiləti]<br>互操作性、互操作能力<br>interpreter [in’tə:pritə]解释器<br>introspection [,intrəu’spekʃən]自省<br>invariants [in’vεəriənts]不变性                                  21<br>invoke [in’vəuk]调用<br>isolation [ˌaɪsəˈleɪʃn] level 隔离级别 (for database)<br>iterate [‘itəreit]迭代<br>iterative [‘itərətiv]反复的、迭代的<br>iterator [ɪtə’retɚ]迭代器<br>iteration [,itə’reiʃən] 迭代(回圈每次轮回称为一个iteration)<br>item      项、条款、项目<br>JIT compilation [ˌkɔmpəˈleɪʃən] JIT编译 即时编译<br>key          键 (for database)<br>key column   键列 (for database)<br>laser        激光<br>late binding 迟绑定<br>left outer join 左向外联接 (for database)<br>level      阶、层例<br>high level 高阶、高层<br>library    库<br>lifetime   生命期、寿命<br>link       连接、链接<br>linkage [‘liŋkidʒ]连接、链接<br>linker     连接器、链接器<br>literal [‘litərəl] constant 字面常数<br>list   列表、表、链表                                       22<br>list box 列表框<br>livelock 活锁 (for database)<br>load   装载、加载<br>load balancing [‘bælənsiŋ] 负载平衡<br>loader 装载器、载入器<br>local 局部的<br>local object    局部对象<br>lock 锁<br>log   日志<br>login 登录<br>login security mode登录安全模式 (for database)<br>lookup table   查找表 (for database)<br>loop [lu:p]循环<br>loose coupling [‘kʌpliŋ] 松散耦合<br>lvalue         左值<br>machine code   机器码、机器代码<br>macro [‘mækrəu]宏<br>maintain [mein’tein]维护<br>managed code 受控代码、托管代码<br>Managed Extensions [ik’stenʃəns] 受控扩充件、托管扩展<br>managed object 受控对象、托管对象<br>mangled [‘mæŋg(ə)l] name                                       23<br>manifest [‘mænifest]清单<br>manipulator [mə’nipjuleitə]操纵器(iostream预先定义的一种东西)<br>many-to-many relationship 多对多关系 (for database)<br>many-to-one relationship 多对一关系 (for database)<br>marshal [‘mɑ:ʃəl]列集<br>member   成员<br>member access operator    成员取用运算子(有dot和arrow两种)<br>member function           成员函数<br>member initialization list成员初始值列表<br>memberwise 以member为单元…、members 逐一…<br>memberwise copy<br>memory      内存<br>memory leak 内存泄漏<br>menu     菜单<br>message 消息<br>message based 基于消息的<br>message loop   消息环<br>message queuing[kjuiŋ]消息队列<br>metadata [‘metədeɪtə] 元数据<br>metaprogramming[mɛtə’prəuɡræmiŋ]元编程<br>method [‘meθəd]方法<br>micro 微                                                 24<br>middleware 中间件<br>middle tier中间层<br>modeling [‘mɔdəliŋ]建模<br>modeling language 建模语言<br>modifier [‘mɔdifaiə]修饰字、修饰符<br>modem[ˈməudem]调制解调器<br>module [‘mɔdju:l]模块<br>most derived [di’raivd] class最底层的派生类<br>mouse   鼠标<br>mutable [‘mju:təbl]可变的<br>mutex[‘mjutex]   互斥元、互斥体<br>multidimensional [ˌmʌltidiˈmenʃənl] OLAP (MOLAP)    多维OLAP(MOLAP) (for database)<br>multithreaded[ˌmʌltidiθ’redid] server application 多线程服务器应用程序<br>multiuser [,mʌlti’ju:zə]多用户<br>multi-tasking   多任务<br>multi-thread    多线程<br>multicast [‘mʌltikɑ:st] delegate [‘deliɡət] 组播委托、多点委托<br>named parameter    命名参数<br>named pipe 命名管道<br>namespace   名字空间、命名空间<br>native      原生的、本地的                           25<br>native code 本地码、本机码<br>Native Image Generator [‘dʒenəreitə] (NGEN)本地映像生成器<br>nested [‘nestid] class 嵌套类<br>nested query 嵌套查询 (for database)<br>nested table 嵌套表 (for database)<br>network       网络<br>network card 网卡<br>nondependent name<br>object        对象<br>object based 基于对象的<br>object file   目标文件<br>object model 对象模型<br>object oriented 面向对象的<br>object pooling 对象池化<br>ODBC data source         ODBC数据源 (for database)<br>ODBC driver      ODBC驱动程序 (for database)<br>ODR (one-definition rule)<br>OLE Automation [,ɔ:tə’meiʃən] objects<br>OLE自动化对象 (for database)<br>OLE Automation [ˌɔ:təˈmeiʃən] server<br>OLE(Object Linking and Embedding [im’bediŋ])<br>自动化服务器 (for database)                                 26<br>OLE DB consumer [kən’sju:mə]<br>OLE DB使用者 (for database)<br>OLE DB for OLAP 用于OLAP的OLE DB (for database)<br>OLE DB provider OLE         DB提供者 (for database)<br>one-to-many relationship 一对多关系 (for database)<br>one-to-one relationship 一对一关系 (for database)<br>online analytical [ˌænəˈlɪtɪkl] processing (OLAP)    联机分析处理(OLAP) (for database)<br>online redo[ri:ˈdu:] log     联机重做日志 (for database)<br>online transaction processing (OLTP)   联机事务处理(OLTP) (for database)<br>Open Data Services (ODS)   开放式数据服务(ODS) (for database)<br>Open Database Connectivity [,kɔnek’tivəti] (ODBC) 开放式数据库连接(ODBC) (for database)<br>operand [‘ɔpərænd] 操作数<br>operating system (OS) 操作系统<br>operation 操作<br>operator   操作符、运算符<br>option [‘ɔpʃən]选项<br>optimizer [‘ɔptimaizə]优化器<br>outer join 外联接 (for database)<br>overflow [,əuvə’fləu]上限溢位(相对于underflow)<br>overhead   额外开销                                         27<br>overload   重载<br>overload resolution   重载决议<br>overloaded function   重载的函数<br>overloaded operator 被重载的操作符<br>override [,əuvə’raid]覆写、重载、重新定义<br>package [‘pækidʒ]包<br>packaging 打包<br>palette [‘pælit]调色板<br>parallel [‘pærəlel]并行<br>parameter [pə’ræmitə]参数、形式参数、形参<br>parameter list 参数列表<br>parameterize [pə’ræmitəraiz]参数化<br>parent class   父类<br>parentheses[pəˈrenθɪsɪsiz]    圆括弧、圆括号<br>parse [pɑ:z]解析<br>parser [‘pɑ:sə]解析器<br>part     零件、部件<br>partial specialization 局部特化<br>pass by address   传址(函式引数的传递方式)(非正式用语)<br>pass by reference 传地址、按引用传递<br>pass by value 按值传递<br>pattern [‘pætən] 模式                                          28<br>PDA (personal digital [‘didʒitəl] assistant)个人数字助理<br>PE (Portable Executable[ˈeksikju:təbl]) file   可移植可执行文件<br>performance [pə’fɔ:məns]性能<br>persistence [pə’sistəns]持久性<br>PInvoke (platform invoke service) 平台调用服务<br>pixel [‘piksəl]像素<br>placement [‘pleismənt] delete<br>placement new<br>placeholder [‘pleis,həuldə]占位符<br>platform [‘plætfɔ:m]平台<br>POD (plain old data (type)) 简单旧数据类型<br>POI (point of instantiation [in,stænʃieiʃən])<br>pointer 指针<br>poll [pəul]轮询<br>pooling 池化<br>polymorphism [,pɒlɪ’mɔːfɪz(ə)m]多态<br>pop up     弹出式<br>port [pɔ:t, pəut]端口<br>postfix [‘pəustfiks]后缀<br>precedence [‘presidəns, pri’si:-]优先序(通常用于运算子的优先执行次序)<br>prefix [,pri:’fiks, ‘pri:fiks]前缀<br>preprocessor [,priː’prəʊsesə]预处理器                           29<br>primary key (PK)主键(PK) (for database)<br>primary table   主表 (for database)<br>primary template原始模板<br>primitive [‘primitiv] type 原始类型<br>print      打印<br>printer    打印机<br>procedure [prə’si:dʒə]过程<br>procedural [prə’si:dʒərəl] 过程式的、过程化的<br>process    进程<br>profile [‘prəufail]评测<br>profiler [‘prəufailə]效能(性能)评测器<br>program    程序<br>programmer 程序员<br>programming编程、程序设计<br>progress bar 进度指示器<br>project    项目、工程<br>property   属性<br>protocol [‘prəutəkɔl]协议<br>pseudo [‘psju:dəu] code伪码<br>qualified [‘kwɔlifaid] 经过资格修饰(例如加上scope运算子)<br>qualified name<br>qualifier [‘kwɔlifaiə]修饰符                                      30<br>quality   质量<br>queue [kju:]队列<br>race condition 竞争条件（多线程环境常用语）<br>radian [‘reidiən]弧度<br>radio button   单选按钮<br>raise [reiz]引发(常用来表示发出一个exception)<br>random number 随机数<br>range   范围、区间<br>rank    等级<br>raw [rɔ:]未经处理的<br>readOnly只读<br>record 记录 (for database)<br>recordset [‘rekɔdset] 记录集 (for database)<br>recursive [ri’kə:siv]递归<br>re-direction 重定向<br>refactoring [ri’fæktəriŋ]   重构<br>refer     引用、参考<br>reference 引用、参考<br>reference counting引用计数<br>referential [,refə’renʃəl] integrity [in’teɡrəti] (RI)引用完整性(RI) (for database)<br>register [‘redʒistə]寄存器<br>reflection   反射                                       31<br>refresh data 刷新数据 (for database)<br>regular expression 正则表达式<br>relational database 关系数据库<br>remote         远程<br>remote request 远程请求<br>represent      表述，表现<br>resolve        解析、决议<br>resolution [,rezə’lu:ʃən]解析过程<br>result set     结果集 (for database)<br>retrieve [ri’tri:v] data 检索数据<br>return         返回<br>return type    返回类型<br>return value   返回值<br>right outer join 右向外联接 (for database)<br>revoke [ri’vəuk]撤销<br>robust [rəu’bʌst]健壮<br>robustness [rəʊ’bʌstnɪs]健壮性<br>roll back    回滚 (for database)<br>roll forward 前滚 (for database)<br>routine [ru:’ti:n]例程<br>row          行 (for database)<br>row lock     行锁 (for database)                                32<br>rowset       行集 (for database)<br>RPC (remote [ri’məut] procedure call)RPC(远程过程调用)<br>runtime 执行期、运行期、执行时、运行时<br>rvalue 右值<br>save    保存<br>savepoint 保存点 (for database)<br>SAX (Simple API for XML)<br>scalable [‘skeiləbl]可伸缩的、可扩展的<br>schedule [‘ʃədju:əl] 调度<br>scheduler [‘ʃedju:ələ] 调度程序<br>schema [‘ski:mə]模式、纲目结构<br>scroll bar滚动条<br>scope [skəup]作用域、生存空间<br>scope operator 生存空间操作符<br>scope resolution [,rezə’lu:ʃən] operator 生存空间解析操作符<br>screen   屏幕<br>SDK (Software Development Kit)软件开发包<br>sealed [si:ld] class 密封类<br>search [sə:tʃ]查找<br>semantics [si’mæntiks]语义<br>semaphore [ˈseməˌfɔ:,信号量<br>sequential [si’kwenʃəl]  container序列式容器                  33<br>server    服务器、服务端<br>serial [‘siəriəl]串行<br>serialization [,siəriəlai’zeiʃən ]/serialize 序列化<br>server cursor服务端游标、服务器游标 (for database)<br>session      会话 (for database)<br>setter [‘setə]设值函数<br>shared lock 共享锁 (for database)<br>sibling [‘sibliŋ]同级<br>side effect 副作用<br>signature [‘signətʃə]签名<br>single-threaded 单线程<br>slider[‘slaidə]滑块<br>slot [slɔt] 槽<br>smart pointer [‘pɔintə] 智能指针<br>SMTP (Simple Mail Transfer Protocol)   简单邮件传输协议<br>snapshot [‘snæpʃɔt]截屏图<br>snapshot       快照 (for database)<br>specialization [,speʃəlai’zeiʃən] 特化<br>specification [,spesifi’keiʃən]规范、规格<br>splitter       切分窗口<br>SOAP (simple object access protocol [‘prəutəkɔl])   简单对象访问协议<br>software      软件                                         34<br>source code   源码、源代码<br>SQL (Structured [‘strʌktʃəd] Query Language) 结构化查询语言 (for database)<br>stack [stæk]栈、堆栈<br>stack unwinding [ʌn’waindiʃ]叠辗转开解(此词用于exception主题)<br>standard library 标准库<br>standard template library 标准模板库<br>stateless [‘steɪtlɪs]无状态的<br>statement [‘steitmənt]语句、声明<br>static cursor 静态游标 (for database)<br>static SQL statements 静态SQL语句 (for database)<br>stored [stɔ:d]  procedure 存储过程 (for database)<br>status [‘steitəs]  bar 状态条<br>stream [stri:m]流<br>string   字符串<br>stub     存根<br>subobject[‘sʌb’ɔbdʒikt]子对象<br>subquery 子查询 (for database)<br>subroutine [‘sʌbruːtiːn]子例程<br>subscript operator 下标操作符<br>subset   子集<br>subtype 子类型<br>support 支持                                               35<br>suspend [sə’spend]挂起<br>symbol   记号<br>syntax [‘sintæks]语法<br>system databases   系统数据库 (for database)<br>system tables      系统表 (for database)<br>table       表 (for database)<br>table lock 表锁 (for database)<br>table-level constraint 表级约束 (for database)<br>tape backup 磁带备份 (for database)<br>target 标的,目标<br>task switch 工作切换<br>TCP (Transport Control Protocol [‘prəutəkɔl])传输控制协议<br>template [‘templit]模板<br>template-id<br>template argument deduction [di’dʌkʃən]模板参数推导<br>template explicit [ik’splisit] specialization 模板显式特化<br>template parameter   模板参数<br>template template parameter<br>temporary [‘tempərəri] object 临时对象<br>temporary table 临时表 (for database)<br>text 文本<br>text file   文本文件                                        36<br>thin client 瘦客户端<br>third-party 第三方<br>thread      线程<br>thread-safe 线程安全的<br>throw 抛出、引发(常指发出一个exception)<br>token 符号、标记、令牌（看场合）<br>trace 跟踪<br>transaction [træn’zækʃən] 事务 (for database)<br>transaction log 事务日志 (for database)<br>transaction rollback [‘rəulbæk]事务回滚 (for database)<br>transactional replication [,repli’keiʃən]事务复制 (for database)<br>translation unit 翻译单元<br>traverse [‘trævəs, -və:s, trə’və:s, træ-]遍历<br>trigger [‘triɡə]触发器 (for database)<br>two-phase [feiz] commit 两阶段提交 (for database)<br>tuple [‘tʌpl] n. 元组，重数<br>two-phase [feiz] lookup 两阶段查找<br>type 类型<br>UDDI(Universary [feiz] Description, Discovery and Integration [,inti’ɡreiʃən])统一描述、查询与集成<br>UML (unified [‘ju:nifaid] modeling language)统一建模语言<br>unary [‘ju:nəri] function 单参函数                                  37<br>unary operator 一元操作符<br>unboxing [,ʌn’bɔks ɪŋ]箱、拆箱转换<br>underflow      下限溢位(相对于overflow)<br>Union [‘ju:niən] query    联合查询 (for database)<br>UNIQUE [ju:’ni:k] constraints UNIQUE约束 (for database)<br>unique index   唯一索引 (for database)<br>unmanaged code 非受控代码、非托管代码<br>unmarshal[[ʌn ‘mɑrʃəl]]      散集<br>unqualified [,ʌn’kwɔlifaid]未经限定的、未经修饰的<br>URI (Uniform Resource identifier [ai’dentifaiə]) 统一资源标识符<br>URL (Uniform Resource Locator)    统一资源定位器<br>user            用户<br>user interface 用户界面<br>value types 值类型<br>variable [‘vεəriəbl]变量<br>vector [‘vektə]向量(一种容器，有点类似array)<br>viable [‘vaiəbl]可行的<br>video    视频<br>view     视图<br>VEE (Virtual Execution Engine)虚拟执行引擎<br>vendor [‘vendɔ:]厂商<br>view    视图 (for database)                                    38<br>virtual function 虚函数<br>virtual machine   虚拟机<br>virtual memory    虚拟内存<br>vowel [‘vauəl] 元音字母<br>Web Services   web服务<br>WHERE clause   WHERE子句 (for database)<br>wildcard [‘waildka:d]  characters 通配符字符 (for database)<br>wildcard search     通配符搜索 (for database)<br>window              窗口<br>window function     窗口函数<br>window procedure    窗口过程<br>Windows authentication [ɔː,θentɪ’keɪʃən] Windows身份验证<br>wizard [‘wizəd]向导<br>word    单词<br>word processor 字处理器<br>wrapper [‘ræpə]包装、包装器<br>write enable[iˈneibl] 写启用 (for database)<br>write-ahead log 预写日志 (for database)<br>write-only只写<br>WSDL (Web Service Description Language)Web Service描述语言<br>XML(eXtensible [ik’stensəbl] Message Interface (XMI)<br>XML消息接口-                                               39<br>XML (extensible Markup Language) 可扩展标记语言<br>XSD (XML Schema [‘ski:mə] Definition) XML模式定义语言<br>XSL (extensible Stylesheet Language) 可扩展样式表语言<br>XSLT (extensible Stylesheet Language Transformation)可扩展样式表语言转换<br>xxx based     基于xxx的<br>xxx oriented 面向xxx<br>网址：(<a href="http://www.ryedu.net/syy/hyyy/200912/15824_2.html" target="_blank" rel="external">http://www.ryedu.net/syy/hyyy/200912/15824_2.html</a>)</p>
<p>application [ˌæplɪ’keɪʃ(ə)n]应用程式 应用、应用程序<br>application framework[‘freɪmwɜːk] 应用程式框架、应用框架 应用程序框架<br>architecture[‘ɑːkɪtektʃə] 架构、系统架构 体系结构<br>argument [‘ɑːgjʊm(ə)nt]引数（传给函式的值）<br>parameter 叁数、实质叁数、实叁、自变量<br>array [ə’reɪ] 阵列 数组<br>arrow [‘ærəʊ] 箭头<br>operator [‘ɔpəreitə] arrow运算子 箭头操作符<br>assembly [ə’semblɪ]装配件<br>assembly language [‘læŋgwɪdʒ]组合语言 汇编语言<br>assert(ion) [ə’sɜːt] [ə’sɜːʃ(ə)n]断言<br>assign [ə’saɪn]指派、指定、设值、赋值 赋值<br>assignment [ə’saɪnm(ə)nt]指派、指定 赋值、分配<br>assignment operator [‘ɒpəreɪtə]指派（赋值）运算子 = 赋值操作符<br>associated [ə’soʃɪetɪd]相应的、相关的 相关的、关联、相应的<br>associative [ə’səʊʃɪətɪv] container [kən’teɪnə]关联式容器<br>sequential container 关联式容器<br>atomic [ə’tɔmik]不可分割的 原子的<br>attribute [ə’trɪbjuːt] 属性、特性<br>audio [‘ɔːdɪəʊ]音讯 音频<br>A.I. 人工智慧 人工智能（artificial [ɑ:ti’fiʃəl] intelligence [ɪn’telɪdʒ(ə)ns]）<br>background [‘bækgraʊnd]背景 背景（用於图形着色）<br>backward [‘bækwəd] compatible [kəm’pætɪb(ə)l]回溯相容 向下兼容<br>bandwidth [‘bændwidθ]频宽 带宽<br>base [beis] class [klɑːs]基础类别 基类<br>base type [taip]基础型别 (等同於 base class)<br>batch [bætʃ]批次（意思是整批作业） 批处理<br>benefit [‘benɪfɪt]利益 收益<br>best [best] viable [‘vaiəbl] function [‘fʌŋ(k)ʃ(ə)n]最佳可行函式<br>binary [‘baɪnərɪ] search [sɜːtʃ]二分搜寻法 二分查找<br>binary tree [triː]二元树 二叉树<br>binary function 二元函式 双叁函数<br>binary operator [‘ɒpəreɪtə]二元操作符<br>binding [‘baɪndɪŋ]系结 绑定<br>bit <a href="发音为beit">bɪt</a>位元 位<br>bit field [fiːld]位元栏 位域<br>bitmap [‘bɪtmæp]位元图 位图<br>bitwise 以 bit 为单元逐一┅<br>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝<br>block [英][blɔk]&nbsp;[美][blɑk]&nbsp;区块,区段 块、区块、语句块<br>boolean [‘bu:li:ən]布林值（真假值，true 或 false） 布尔值<br>border [‘bɔ:də]边框、框线 边框<br>curly [‘kə:li] brace [breis]大括弧、大括号 花括弧、花括号<br>square [skwεə] bracket [‘brækit]中括弧、中括号 方括弧、方括号<br>breakpoint [‘breikpɔint]中断点 断点<br>build [bild]建造、构筑、建置（MS 用语）<br>build－in 内建 内置<br>bus 汇流排 总线<br>business [‘bɪznɪs]商务,业务 业务<br>buttons [bʌtəns]按钮 按钮<br>byte [bait] 字节   位元组（由 8 bits 组成）<br>cache [kæʃ] 快取 高速缓存<br>call [kɔ:l] 调用 呼叫、叫用<br>callback [‘kɔ:lbæk] 回调 回呼<br>operator [‘ɔpəreitə] call（函式呼叫）运算子调用操作符 （同 function call operator）<br>candidate [‘kændidit] function 候选函式 候选函数 （在函式多载决议程序中出现的候选函式）<br>chain [tʃein]串链（例 chain of function calls）链<br>character [‘kærəktə] 字符 字元<br>check [tʃek] box复选框 核取方块 (i.e. check button)<br>checked [tʃekt] exception [ik’sepʃən]可控式异常 (Java)<br>check button [‘bʌtən] 复选按钮 方钮 (i.e. check box)<br>child [tʃaild] class 子类别（或称为derived [di’raivd] class, subtype [‘sʌbtaip] 图表类型） 子类<br>class [klɑ:s]类别 类<br>class body 类别本体 类体<br>class declaration [,deklə’reiʃən] 类声明 类别宣告、类别宣告式<br>class definition [,defi’niʃən] 类定义 类别定义、类别定义式<br>class derivation [,deri’veiʃən] list类继承列表 类别衍化列<br>class head [hed] 类头 类别表头<br>class hierarchy [‘haiərɑ:ki]类别继承体系, 类别阶层 类层次体系<br>class library [‘laibrəri] 类库 类别程式库、类别库<br>class template [‘templit]类别模板、类别范本 类模板<br>class template partial [‘pɑ:ʃəl] specializations [‘speʃəlaiz]类别模板偏特化 类模板部分特化<br>class template specializations 类别模板特化 类模板特化<br>cleanup [‘kli:nʌp]清理、善後 清理、清除<br>client [‘klaiənt] 客户端、客端、客户 客户<br>client－server [‘sə:və]主从架构 客户/服务器<br>clipboard [‘klipbɔ:d] 剪贴板 剪贴簿<br>clone [kləun]复制 克隆<br>collection [kə’lekʃən] 集合 群集<br>combo [‘kɔmbəu] box [bɔks]复合方块 复合框 组合框<br>command [kə’mɑ:nd] line [lain] 命令行 命令列 (系统文字模式下的整行执行命令)<br>communication [kə,mju:ni’keiʃən]通讯<br>compatible [kəm’pætəbl] 兼容 相容<br>compile [kəm’pail]time 编译期 编译期、编译时<br>compiler [kəm’pailə]编译器 编译器<br>component [kəm’pəunənt]组件 组件<br>composition[,kɔmpə’ziʃən]  复合、合成、组合 组合<br>computer [kəm’pju:tə]电脑、计算机 计算机、电脑<br>concept [‘kɔnsept]概念 概念<br>concrete [kən’kri:t]具象的 实在的<br>concurrent [kən’kʌrənt]并行 并发<br>configuration [kən,fiɡju’reiʃən] 配置 组态<br>connection [kə’nekʃən]连接，连线（网络,资料库） 连接<br>constraint[kən’streint]  约束（条件）<br>construct [kən’strʌkt]构件 构件<br>container [kən’teinə]容器 容器 （存放资料的某种结构如 list, vector…）<br>containment [kən’teinmənt]内含 包容<br>context[‘kɔntekst] 背景关系、周遭环境、上下脉络 环境、上下文<br>control [kən’trəul]控制元件、控件 控件<br>console [kən’səul]主控台 控制台<br>const [‘kɔnstənt]常数（constant 的缩写，C++ 关键字）<br>constant[‘kɔnstənt]  常数（相对於 variable） 常量<br>constructor[kɔn’strʌktə]（ctor） 建构式 构造函数 （与class 同名的一种 member functions）<br>copy[‘kɔpi] (v) 复制、拷贝 拷贝<br>copy (n) 复件, 副本<br>cover [‘kʌvə] 涵盖 覆盖<br>create [kri’eit]创建、建立、产生、生成 创建<br>creation [kri:’eiʃən]产生、生成 创建<br>cursor [‘kə:sə]游标 光标<br>custom [‘kʌstəm] 订制、自定 定制<br>data [‘deitə]资料 数据<br>database [‘deitəbeis]资料库 数据库<br>database schema [‘ski:mə] 数据库结构纲目<br>data member [‘membə] 资料成员、成员变数 数据成员、成员变量<br>data structure [‘strʌktʃə]资料结构 数据结构<br>datagram [‘deitəɡræm]资料元 数据报文<br>dead [ded] lock [lɔk]死结 死锁<br>debug [di:’bʌɡ]除错 调试<br>debugger [di:’bʌɡə]除错器 调试器<br>declaration [,deklə’reiʃən]宣告、宣告式 声明<br>deduction [di’dʌkʃən]推导（例：template argument deduction） 推导、推断<br>default [di’fɔ:lt]预设 缺省、默认<br>defer [di’fə:] 延缓 推迟<br>define [di’fain]定义 预定义<br>definition [,defi’niʃən]定义、定义区、定义式 定义<br>delegate [‘deliɡeit]委派、委托、委任 委托<br>delegation [,deli’ɡeiʃən] （同上）<br>demarshal 反编列 散集<br>dereference [di’refərəns]提领（取出指标所指物体的内容） 解叁考<br>operator dereference（提领）运算子 * 解叁考操作符<br>derived [di’raivd] class 衍生类别 派生类<br>design [di’zain] by contract [kən’trækt]契约式设计<br>design [di’zain] pattern [‘pætən] 设计范式、设计样式 设计模式<br>※ 最近我比较喜欢「设计范式」一词<br>destroy [di’strɔi] 摧毁、销毁<br>destructor [di’strʌktə] 解构式 析构函数<br>device [di’vais] 装置、设备 设备<br>dialog [‘daiəlɔɡ]对话窗、对话盒 对话框<br>directive [di’rektiv] 指令（例：using directive） (编译)指示符<br>directory [di’rektəri] 目录 目录<br>disk [disk] 碟 盘<br>dispatch [dis’pætʃ] 分派 分派<br>distributed [di’stribjutid] computing [kəm’pju:tiŋ] 分布式计算 (分布式电算) 分布式计算<br>分散式计算 (分散式电算)<br>document [‘dɔkjumənt]文件 文档<br>dot [dɔt] operator [‘ɔpəreitə] dot（句点）运算子 . (圆)点操作符<br>driver [draivə]驱动程式 驱动（程序）<br>dynamic [dai’næmik] binding [‘baindiŋ] 动态系结 动态绑定<br>efficiency [i’fiʃənsi] 效率 效率<br>efficient [i’fiʃənt]高效 高效<br>end [end] user [‘ju:zə]终端用户<br>entity [‘entəti] 物体 实体、物体<br>encapsulation [in,-kæpsə’leiʃən] 封装 封装<br>enclosing [in’kləuz] class 外围类别（与巢状类别 nested <a href="嵌套的">‘nestid</a> class 有关）外围类<br>enum (enumeration [i,nju:mə’reiʃən]) 枚举 列举（一种 C++ 资料型别）枚举<br>enumerators [i’nju:məreitə]列举元（enum 型别中的成员） 枚举成员、枚举器<br>equal [‘i:kwəl] 相等 相等<br>equality [i:’kwɔləti]相等性 相等性<br>operator [‘ɔpəreitə] equality（等号）运算子 == 等号操作符<br>equivalence [i’kwivələns] 等价性、等同性、对等性 等价性<br>equivalent [i’kwivələnt]等价、等同、对等 等价<br>escape [i’skeip] code 转义码 转义码<br>evaluate [i’væljueit] 评估、求值、核定 评估 </p>
<p>application 应用程式 应用、应用程序﻿<br>application framework 应用程式框架、应用框架 应用程序框架﻿<br>architecture 架构、系统架构 体系结构﻿<br>argument 参数（传给函式的值）。﻿<br>array 阵列 数组﻿<br>arrow operator arrow（箭头）运算子 箭头操作符﻿<br>assembly 装配件﻿<br>assembly language 组合语言 汇编语言﻿<br>assert(ion) 断言﻿<br>assign 指派、指定、设值、赋值 赋值﻿<br>assignment 指派、指定 赋值、分配﻿<br>assignment operator 指派（赋值）运算子 = 赋值操作符﻿<br>associated 相应的、相关的 相关的、关联、相应的﻿<br>associative container 关联式容器（对应 sequential container）关联式容器﻿<br>atomic不可分割的 原子的﻿<br>attribute 属性 属性、特性﻿<br>audio 音讯 音频﻿<br>A.I. 人工智慧 人工智能﻿<br>background 背景 背景（用於图形着色）後台（用於行程）﻿<br>backward compatible 回溯相容 向下兼容﻿<br>bandwidth 频宽 带宽﻿<br>base class 基础类别 基类﻿<br>base type 基础型别 (等同於﻿<br>base class) batch 批次（意思是整批作业） 批处理﻿<br>benefit 利益 收益﻿<br>best viable function 最佳可行函式 最佳可行函式﻿<br>binary search 二分搜寻法 二分查找﻿<br>binary tree 二元树 二叉树﻿<br>binary function 二元函式 双叁函数﻿<br>binary operator 二元运算子 二元操作符﻿<br>binding 系结 绑定﻿<br>bit 位元 位﻿<br>bit field 位元栏 位域﻿<br>bitmap 位元图 位图﻿<br>bitwise 以 bit 为单元逐一﻿<br>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝﻿<br>block 区块,区段 块、区块、语句块﻿<br>boolean 布林值（真假值，true 或 false）布尔值<br>border 边框、框线 边框﻿<br>brace(curly brace) 大括弧、大括号 花括弧、花括号﻿<br>bracket(square bracket) 中括弧、中括号 方括弧、方括号﻿<br>breakpoint 中断点 断点﻿<br>build 建造、构筑、建置（MS 用语）﻿<br>build－in 内建 内置﻿<br>bus 汇流排 总线﻿<br>business 商务,业务 业务﻿<br>buttons 按钮 按钮﻿<br>byte 位元组（由 8 bits 组成） 字节﻿<br>cache 快取 高速缓存﻿<br>call 呼叫、叫用 调用﻿<br>callback 回呼 回调﻿<br>call operator call（函式呼叫）运算子调用操作符﻿<br>candidate function 候选函式 候选函数﻿<br>chain 串链（例 chain of function calls） 链﻿<br>character 字元 字符﻿<br>check box 核取方块 (i.e. check button) 复选框﻿<br>checked exception 可控式异常﻿<br>check button 方钮 (i.e. check box) 复选按钮﻿<br>child class 子类别（或称为derived class, subtype） 子类﻿<br>class 类别 类﻿<br>class body 类别本体 类体﻿<br>class declaration 类别宣告、类别宣告式 类声明﻿<br>class definition 类别定义、类别定义式 类定义﻿<br>class derivation list 类别衍化列 类继承列表﻿<br>class head 类别表头 类头﻿<br>class hierarchy 类别继承体系, 类别阶层 类层次体系﻿<br>class library 类别程式库、类别库 类库﻿<br>class template 类别模板、类别范本 类模板﻿<br>class template partial specializations 类别模板偏特化 类模板部分特化﻿<br>class template specializations 类别模板特化 类模板特化﻿<br>cleanup 清理、善後 清理、清除﻿<br>client 客端、客户端、客户 客户﻿<br>client－server 主从架构 客户/服务器﻿<br>clipboard 剪贴簿 剪贴板﻿<br>clone 复制 克隆﻿<br>collection 群集 集合﻿<br>combo box 复合方块、复合框 组合框﻿<br>command line 命令列 命令行(系统文字模式下的整行执行命令)﻿<br>communication 通讯 通讯﻿<br>compatible 相容 兼容﻿<br>compile time 编译期 编译期、编译时﻿<br>compiler 编译器 编译器﻿<br>component 组件 组件﻿<br>composition 复合、合成、组合 组合﻿<br>computer 电脑、计算机 计算机、电脑﻿<br>concept 概念 概念﻿<br>concrete 具象的 实在的﻿<br>concurrent 并行 并发﻿<br>configuration组态 配置﻿<br>connection 连接，连线（网络,资料库） 连接﻿<br>constraint 约束（条件）﻿<br>construct 构件 构件﻿<br>container 容器 容器(存放资料的某种结构如list, vector…）﻿<br>containment 内含 包容﻿<br>context背景关系、周遭环境、上下脉络 环境、上下文﻿<br>control 控制元件、控件 控件﻿<br>console 主控台 控制台﻿<br>const常数（constant 的缩写，C++ 关键字）﻿<br>constant 常数（相对於variable） 常量﻿<br>constructor（ctor） 建构式 构造函数（与class 同名的一种 member functions）﻿<br>copy (v) 复制、拷贝 拷贝﻿<br>copy (n) 复件, 副本﻿<br>cover 涵盖 覆盖﻿<br>create 创建、建立、产生、生成 创建﻿<br>creation 产生、生成 创建﻿<br>cursor 游标 光标custom、订制、自定 定制<br>data 资料 数据﻿<br>database 资料库 数据库﻿<br>database schema 数据库结构纲目﻿<br>data member 资料成员、成员变数 数据成员、成员变量﻿<br>data structure 资料结构 数据结构﻿<br>datagram 资料元 数据报文﻿<br>dead lock 死结 死锁﻿<br>debug 除错 调试﻿<br>debugger 除错器 调试器﻿<br>declaration 宣告、宣告式 声明﻿<br>deduction 推导（例：template argument deduction） 推导、推断﻿<br>default 预设 缺省、默认﻿<br>defer 延缓 推迟﻿<br>define 定义 预定义﻿<br>definition 定义、定义区、定义式 定义﻿<br>delegate 委派、委托、代理﻿<br>delegation （同上）﻿<br>demarshal 反编列 散集﻿<br>dereference 提领（取出指标所指物体的内容） 解叁考﻿<br>dereference operator dereference（提领）运算子 * 解叁考操作符﻿<br>derived class 衍生类别 派生类﻿<br>design by contract 契约式设计﻿<br>design pattern 设计范式、设计样式 设计模式﻿<br>destroy 摧毁、销毁﻿<br>destructor  解构式 析构函数﻿<br>device 装置、设备 设备﻿<br>dialog 对话窗、对话盒 对话框﻿<br>directive 指令（例：using directive） (编译)指示符﻿<br>directory 目录 目录﻿<br>disk 碟 盘﻿<br>dispatch 分派 分派﻿<br>distributed computing 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算)﻿<br>document 文件 文档﻿<br>dot operator dot（句点）运算子 . (圆)点操作符﻿<br>driver 驱动程式 驱动（程序）﻿<br>dynamic binding 动态系结 动态绑定﻿<br>efficiency 效率 效率﻿<br>efficient 高效 高效﻿<br>end user 终端用户﻿<br>entity 物体 实体、物体﻿<br>encapsulation 封装 封装﻿<br>enclosing class外围类别（与巢状类别 nested class有关）外围类﻿<br>enum (enumeration) 列举（一种 C++ 资料型别） 枚举﻿<br>enumerators 列举元（enum 型别中的成员） 枚举成员、枚举器﻿<br>equal 相等 相等﻿<br>equality 相等性 相等性﻿<br>equality operator equality（等号）运算子 == 等号操作符﻿<br>equivalence等价性、等同性、对等性 等价性﻿<br>equivalent 等价、等同、对等 等价﻿<br>escape code 转义码 转义码﻿<br>evaluate 评估、求值、核定 评估﻿<br>event 事件 事件﻿<br>event driven 事件驱动的 事件驱动的﻿<br>exception 异常情况 异常﻿<br>exception declaration 异常宣告（ref. C++ Primer 3/e, 11.3）异常声明﻿<br>exception handling 异常处理、异常处理机制 异常处理、异常处理机制﻿<br>exception specification 异常规格（ref. C++ Primer 3/e, 11.4）异常规范﻿<br>exit 退离（指离开函式时的那一个执行点） 退出﻿<br>explicit 明白的、明显的、显式 显式﻿<br>export 汇出 引出、导出﻿<br>facility 设施、设备 设施、设备﻿<br>feature 特性﻿<br>field 栏位,资料栏（Java） 字段, 值域（Java）﻿<br>file 档案 文件﻿<br>firmware 韧体 固件﻿<br>flag 旗标 标记﻿<br>flash memory 快闪记忆体 闪存﻿<br>flexibility 弹性 灵活性﻿<br>flush 清理、扫清 刷新﻿<br>font 字型 字体﻿<br>form 表单（programming 用语） 窗体﻿<br>formal parameter形式叁数 形式叁数</p>
<p>forward declaration 前置宣告 前置声明﻿<br>forwarding 转呼叫,转发 转发﻿<br>forwarding function 转呼叫函式,转发函式 转发函数﻿<br>fractal 碎形 分形﻿<br>framework 框架 框架﻿<br>full specialization 全特化（ref. partial specialization）﻿<br>function 函式、函数 函数﻿<br>function call operator 同﻿<br>call operator function object 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象﻿<br>function overloaded resolution 函式多载决议程序 函数重载解决（方案）﻿<br>functionality 功能、机能 功能﻿<br>function template 函式模板、函式范本 函数模板﻿<br>functor 仿函式 仿函式、函子<br>game 游戏 游戏﻿<br>generate 生成﻿<br>generic 泛型、一般化的 一般化的、通用的、泛化﻿<br>generic algorithm 泛型演算法 通用算法﻿<br>getter (相对於 setter) 取值函式﻿<br>global 全域的（对应於 local） 全局的﻿<br>global object 全域物件 全局对象﻿<br>global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符﻿<br>group 群组<br>group box 群组方块 分组框<br>guard clause 卫述句 (Refactoring, p250) 卫语句<br>GUI 图形介面 图形界面﻿<br>hand shaking握手协商﻿<br>handle 识别码、识别号、号码牌、权柄 句柄﻿<br>handler 处理常式 处理函数﻿<br>hard－coded 编死的 硬编码的﻿<br>hard－copy 硬拷图 屏幕截图﻿<br>hard disk硬碟 硬盘﻿<br>hardware 硬体 硬件﻿<br>hash table 杂凑表 哈希表、散列表﻿<br>header file 表头档、标头档 头文件﻿<br>heap堆积 堆﻿<br>hierarchy 阶层体系 层次结构（体系）﻿<br>hook 挂钩 钩子﻿<br>hyperlink 超链结 超链接﻿<br>icon 图示、图标 图标﻿<br>IDE 整合开发环境 集成开发环境﻿<br>identifier 识别字、识别符号 标识符﻿<br>if and only if 若且唯若 当且仅当﻿<br>Illinois 伊利诺 伊利诺斯﻿<br>image 影像 图象﻿<br>immediate base 直接的（紧临的）上层 base class。 直接上层基类﻿<br>immediate derived 直接的（紧临的）下层derived class。 直接下层派生类﻿<br>immutability 不变性﻿<br>immutable不可变（的）﻿<br>implement实作、实现 实现﻿<br>implementation实作品、实作体、实作码、实件 实现﻿<br>implicit 隐喻的、暗自的、隐式 隐式﻿<br>import汇入 导入﻿<br>increment operator累加运算子 ++ 增加操作符﻿<br>infinite loop 无穷回圈 无限循环﻿<br>infinite recursive 无穷递回 无限递归﻿<br>information 资讯 信息﻿<br>infrastructure 公共基础建设﻿<br>inheritance继承、继承机制 继承、继承机制﻿<br>inline 行内 内联﻿<br>inline expansion 行内展开 内联展开﻿<br>initialization 初始化（动作） 初始化﻿<br>initialization list 初值列 初始值列表﻿<br>initialize 初始化 初始化﻿<br>inner class 内隐类别 内嵌类﻿<br>instance 实体 实例（根据某种表述而实际产生的「东西」）﻿<br>instantiated 具现化、实体化（常应用於 template） 实例化﻿<br>instantiation 具现体、具现化实体（常应用於 template） 实例﻿<br>integer (integral) 整数（的） 整型（的）﻿<br>integrate 整合 集成﻿<br>interacts 交谈、互动 交互﻿<br>interface 介面 接口﻿<br>interpreter 直译器 解释器﻿<br>invariants 恒常性,约束条件 约束条件﻿<br>invoke 唤起 调用﻿<br>iterate迭代（回圈一个轮回一个轮回地进行） 迭代﻿<br>iterative 反覆的，迭代的﻿<br>iterator 迭代器（一种泛型指标） 迭代器﻿<br>iteration 迭代（回圈每次轮回称为一个 iteration） 迭代﻿<br>item 项目、条款 项、条款、项目﻿<br>laser 雷射 激光﻿<br>level 阶 层 (级) 例high level高阶 高层﻿<br>library 程式库、函式库 库、函数库﻿<br>lifetime生命期、寿命 生命期、寿命﻿<br>link联结、连结 连接,链接﻿<br>linker联结器、连结器 连接器﻿<br>literal constant 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数﻿<br>list串列（linked－list） 列表、表、链表﻿<br>list box 列表方块、列表框 列表框﻿</p>
<p>load 载入 装载﻿<br>loader 载入器 装载器、载入器﻿<br>local 区域的（对应於 global） 局部的﻿<br>local object 区域物件 局部对象﻿<br>lock机锁﻿<br>loop 回圈 循环﻿<br>lvalue左值 左值﻿<br>﻿<br>macro 巨集 宏﻿<br>magic number 魔术数字 魔法数﻿<br>maintain 维护 维护﻿<br>manipulator操纵器（iostream预先定义的一种东西） 操纵器﻿<br>marshal 编列 列集叁考<br>demarshal mechanism 机制 机制﻿<br>member 成员 成员﻿<br>member access operator 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符﻿<br>member function 成员函式 成员函数﻿<br>member initialization list 成员初值列 成员初始值列表﻿<br>member wise 以 member 为单元┅、members 逐一┅ 以成员为单位﻿<br>member wise copy 以 members 为单元逐一复制﻿<br>memory 记忆体 内存﻿<br>menu 表单、选单 菜单﻿<br>message 讯息 消息<br>message based 以讯息为基础的 基於消息的﻿<br>message loop讯息回圈 消息环﻿<br>method 方法、行为、函式 方法﻿<br>meta－ 超－ 元－﻿<br>meta－programming 超编程 元编程﻿<br>micro 微 微﻿<br>middleware 中介层 中间件﻿<br>modeling 模塑﻿<br>modeling language 塑模语言，建模语言﻿<br>modem 数据机 调制解调器﻿<br>module 模组 模块﻿<br>modifier 饰词 修饰符﻿<br>most derived class 最末层衍生类别 最底层的派生类﻿<br>mouse 滑鼠 鼠标﻿<br>mutable可变的 可变的﻿<br>multi－tasking 多工 多任务﻿<br>namespace 命名空间 名字空间、命名空间﻿<br>native 原生的 本地的、固有的﻿<br>nested class 巢状类别 嵌套类﻿<br>network 网路 网络﻿<br>network card网路卡 网卡<br>object 物件 对象﻿<br>object based 以物件为基础的 基於对象的﻿<br>object file 目的档 目标文件﻿<br>object model 物件模型 对象模型﻿<br>object oriented 物件导向的 面向对象的﻿<br>online 线上 在线﻿<br>opaque不透明的﻿<br>operand 运算元 操作数﻿<br>operating system (OS) 作业系统 操作系统﻿<br>operation 操作、操作行为 操作﻿<br>operator 运算子 操作符、运算符﻿<br>option 选项，可选方案 选项﻿<br>ordinary 常规的 常规的﻿<br>overflow 上限溢位（相对於 underflow） 溢出（underflow:下溢）﻿<br>overhead 额外负担、额外开销 额外开销﻿<br>overload 多载化、多载化、重载 重载﻿<br>overloaded function 多载化函式 重载的函数﻿<br>overloaded operator 多载化运算子 被重载的操作符﻿<br>overloaded set 多载集合 重载集合﻿<br>override 改写、覆写 重载、改写、重新定义（在 derived class 中重新定义虚拟函式)<br>package套件 包<br>pair 对组﻿<br>palette 调色盘、组件盘、工具箱﻿<br>pane 窗格 窗格﻿<br>parallel平行 并行﻿<br>parameter 叁数（函式叁数列上的变数） 叁数、形式叁数、形叁﻿<br>parameter list 叁数列 叁数列表﻿<br>parent class 父类别（或称 base class） 父类﻿<br>parentheses 小括弧、小括号 圆括弧、圆括号﻿<br>parse 解析 解析﻿<br>part零件 部件﻿<br>partial specialization 偏特化（ref. C++ Primer 3/e, 16.10）局部特化﻿<br>pass by address 传址（函式引数的传递方式）（非正式用语）传地址﻿<br>pass by reference传址（函式引数的一种传递方式） 传地址, 按引用传递﻿<br>pass by value 传值（函式引数的一种传递方式） 按值传递﻿<br>pattern 范式、样式 模式﻿<br>performance 效率、性能兼而有之 性能﻿<br>persistence 永续性 持久性﻿<br>pixel 图素、像素 像素﻿<br>platform 平台 平台﻿<br>pointer指标 指针址位器（和址叁器 reference 形成对映，满好）﻿<br>poll 轮询 轮询﻿<br>polymorphism多型 多态﻿<br>pop up 冒起式、弹出式 弹出式﻿<br>port 埠 端口﻿<br>postfix 後置式、後序式 後置式﻿<br>precedence 优先序（通常用於运算子的优先执行次序）﻿<br>prefix 前置式、前序式 前置式﻿<br>preprocessor 前处理器 预处理器﻿<br>prime质数 素数﻿<br>primitive type 基本型别 (不同於 base class,基础类别)﻿<br>print 列印 打印﻿<br>printer 印表机 打印机﻿<br>priority优先权 (通常用於执行绪获得 CPU 时间的优先次序）﻿<br>procedure 程序 过程﻿<br>procedural 程序的、程序式的 过程式的、过程化的﻿</p>
<p>process 行程 进程﻿<br>profile 评测 评测﻿<br>profiler 效能（效率）评测器 效能（性能）评测器﻿<br>programmer 程式员 程序员﻿<br>programming 编程、程式设计、程式化 编程﻿<br>progress bar 进度指示器 进度指示器﻿<br>project 专案 项目、工程﻿<br>property 属性﻿<br>protocol协定 协议﻿<br>pseudo code 假码、虚拟码、伪码 伪码﻿<br>﻿<br>qualified 经过资格修饰（例如加上scope 运算子） 限定﻿<br>qualifier 资格修饰词、饰词 限定修饰词﻿<br>quality品质 质量﻿<br>queue 伫列 队列﻿<br>radian 径度 弧度﻿<br>radio button 圆钮 单选按钮﻿<br>raise 引发（常用来表示发出一个 exception） 引起、引发﻿<br>random number 随机数、乱数 随机数﻿<br>range范围、区间（用於 STL 时） 范围、区间﻿<br>rank 等级、分等（ref. C++Primer 3/e 9,15章） 等级﻿<br>raw 生鲜的、未经处理的 未经处理的﻿<br>record记录 记录﻿<br>recordset 记录集 记录集﻿<br>recursive 递回 递归﻿<br>re－direction重导向 重定向﻿<br>refactoring 重构、重整 重构﻿<br>refer 取用 叁考﻿<br>refer to指向、指涉、指代﻿<br>reference 引用、叁考 址叁器,﻿<br>see pointer register暂存器 寄存器﻿<br>reflection 反射 反射、映像﻿<br>relational database 关联式资料库 关系数据库﻿<br>represent 表述，表现 表述，表现﻿<br>resolve 决议（为算式中的符号名称寻找 解析对应之宣告式的过程）﻿<br>resolution 决议程序、决议过程 解析过程﻿<br>resolution 解析度 分辨率﻿<br>restriction 局限﻿<br>return 传回、回返 返回﻿<br>return type 回返型别 返回类型﻿<br>return value 回返值 返回值﻿<br>robust 强固、稳健 健壮﻿<br>robustness强固性、稳健性 健壮性﻿<br>routine常式 例程﻿<br>runtime 执行期 运行期、运行时﻿<br>common language runtime(CLR) 译为「通用语言执行层」﻿<br>rvalue 右值 右值﻿<br>save 保存﻿<br>save point 保存点﻿<br>SAX (Simple API for XML)scalable可伸缩的、可扩展的﻿<br>schedule 调度</p>
<p>scheduler 调度程序﻿<br>schema模式、纲目结构﻿<br>scroll bar 滚动条﻿<br>scope 作用域、生存空间﻿<br>scope operator 生存空间操作符﻿<br>scope resolution operator生存空间解析操作符﻿<br>screen 屏幕﻿<br>SDK (Software Development Kit) 软件开发包﻿<br>sealed class 密封类﻿<br>search 查找﻿<br>semantics 语义﻿<br>semaphore信号量﻿<br>sequential container序列式容器﻿<br>server 服务器、服务端﻿<br>serial 串行﻿<br>serialization/serialize 序列化﻿<br>server cursor服务端游标、服务器游标﻿<br>session 会话﻿<br>setter 设值函数﻿<br>shared lock 共享锁﻿<br>sibling 同级﻿<br>side effect 副作用﻿<br>signature 签名﻿<br>single-threaded 单线程﻿<br>slider滑块﻿<br>slot 槽﻿<br>smart pointer 智能指针﻿<br>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议﻿<br>snapshot 截屏图﻿<br>snapshot 快照﻿<br>specialization 特化﻿<br>specification 规范、规格﻿<br>splitter 切分窗口﻿<br>SOAP (simple object access protocol)简单对象访问协议﻿<br>software 软件﻿<br>source code 源码、源代码﻿<br>SQL (Structured Query Language) 结构化查询语言﻿<br>stack 栈、堆栈﻿<br>stack unwinding 叠辗转开解(此词用于exception主题)﻿<br>standard library 标准库﻿<br>standard template library 标准模板库﻿<br>stateless 无状态的﻿<br>statement 语句、声明﻿<br>static cursor 静态游标﻿<br>static SQL statements 静态SQL语句﻿<br>stored procedure 存储过程﻿<br>status bar 状态条﻿<br>stream 流﻿<br>string 字符串﻿<br>stub 存根﻿<br>subobject子对象﻿<br>subquery 子查询﻿<br>subroutine 子例程﻿<br>subscript operator 下标操作符﻿<br>subset 子集﻿<br>subtype 子类型﻿<br>support 支持﻿<br>suspend挂起﻿<br>symbol记号﻿<br>syntax 语法﻿<br>system databases 系统数据库﻿<br>system tables 系统表﻿<br>tag标签 标记 索引标签,页签﻿<br>target 标的（例target pointer：标的指标） 目标﻿<br>task switch 工作切换 任务切换﻿<br>template 模板、范本 模板﻿<br>template argument deduction 模板引数推导 模板叁数推导﻿<br>template explicit specialization 模板显式特化（版本） 模板显式特化﻿<br>template parameter 模板叁数 模板叁数﻿<br>temporary object 暂时物件 临时对象﻿<br>text文字 文本﻿<br>text file程式本文档（放置程式原始码的档案） 文本文件﻿<br>thread 执行绪 线程﻿<br>thread safe 多绪安全 多线程安全﻿<br>throw丢掷（常指发出一个exception） 丢掷、引发﻿<br>token 语汇单元 符号、标记﻿<br>transaction 交易 事务﻿<br>transaction log 事务日志﻿<br>transaction rollback 事务回滚﻿<br>transactional replication 事务复制﻿<br>translation unit 翻译单元﻿<br>transparent(ly) 透通的(地)﻿<br>traverse 巡访（来回走动） 遍历﻿<br>trigger 触发 触发﻿<br>type型别 类型﻿<br>table 表﻿<br>table lock 表锁﻿<br>table-level constraint表级约束﻿<br>tape backup 磁带备份﻿<br>task switch 工作切换﻿<br>TCP (Transport Control Protocol) 传输控制协议﻿<br>temporary table临时表﻿<br>thin client瘦客户端﻿<br>third-party第三方﻿<br>trace 跟踪﻿<br>traverse 遍历﻿<br>two-phase commit两阶段提交﻿<br>tupletwo-phase lookup 两阶段查找﻿<br>UML unified modeling language统一建模语言﻿<br>unary function 一元函式 单叁函数﻿<br>unary operator一元运算子 一元操作符﻿<br>underflow下限溢位（相对於overflow） 下溢﻿<br>unchecked exception 不可控异常﻿<br>unqualified 未经资格修饰（而直接取用）﻿<br>user 使用者、用户 用户﻿<br>user interface使用者界面、用户界面、人机界面﻿<br>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成﻿<br>unboxing 拆箱、拆箱转换﻿<br>Union query 联合查询﻿<br>UNIQUE constraints UNIQUE约束﻿<br>unique index 唯一索引﻿<br>unmanaged code 非受控代码、非托管代码﻿<br>unmarshal散集﻿<br>unqualified 未经限定的、未经修饰的﻿<br>URI (Uniform Resource identifier) 统一资源标识符﻿<br>URL (Uniform Resource Locator)统一资源定位器﻿<br>variable 变数（相对於常数const） 变量﻿<br>vector 向量（一种容器，有点类似array） 向量、矢量﻿<br>viable可实行的、可行的 可行的﻿<br>viable function可行函式 可行函数﻿<br>video 视讯 视频<br>view (1) 视图﻿<br>(document/view)文档/视图﻿<br>virtual function 虚拟函式 虚函数﻿<br>virtual machine虚拟机器 虚拟机﻿<br>virtual memory虚拟记忆体 虚内存, 虚存﻿<br>volatile 易挥发的、易变的﻿<br>vowel 母音 元音字母﻿<br>window 视窗 窗口﻿<br>window function 视窗函式 窗口函数﻿<br>window procedure 视窗函式 窗口过程﻿<br>word 字 单词﻿<br>word processor文书处理器 字处理器﻿<br>wrapper 外覆、外包 包装﻿<br>Web Services web 服务﻿<br>WHERE clause WHERE子句﻿<br>wildcard characters 通配符字符﻿<br>wildcard search 通配符搜索﻿<br>Windows authentication Windows 身份验证﻿<br>wizard 向导﻿<br>write enable写启用﻿<br>write-ahead log 预写日志﻿<br>write-only 只写﻿<br>WSDL (Web Service Description Language)Web Service 描述语言﻿<br>XML (eXtensible Markup Language)可扩展标记语言﻿<br>XSD (XML Schema Definition)  XML 模式定义语言﻿<br>XSL (eXtensible Stylesheet Language)可扩展样式表语言﻿<br>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换﻿<br>xxx based基于xxx的﻿</p>
<p>xxx oriented面向xxxXML (eXtensible Markup Language) 可扩展标记语言</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[版本管理Git]]></title>
      <url>http://yoursite.com/2014/02/21/2014/Git/</url>
      <content type="html"><![CDATA[<h2 id="GIT简介"><a href="#GIT简介" class="headerlink" title="GIT简介"></a>GIT简介</h2><h4 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git?"></a>什么是git?</h4><ul>
<li>git是一款开源的分布式版本控制工具</li>
<li>在世界上所有的分布式版本控制工具中，git是最快、最简单、最流行的版本管理工具<h4 id="git的起源"><a href="#git的起源" class="headerlink" title="git的起源"></a>git的起源</h4></li>
<li>作者是Linux之父：Linus Benedict Torvalds</li>
<li>当初开发git仅仅是为了辅助Linux内核的开发（管理源代码）<h4 id="git的现状"><a href="#git的现状" class="headerlink" title="git的现状"></a>git的现状</h4></li>
<li>在国外已经非常普及，国内并未普及（在慢慢普及）</li>
<li>越来越多的开源项目已经转移到git<h3 id="其他版本控制工具"><a href="#其他版本控制工具" class="headerlink" title="其他版本控制工具"></a>其他版本控制工具</h3><h4 id="CVS"><a href="#CVS" class="headerlink" title="CVS"></a>CVS</h4></li>
<li>最早的开源、免费的集中式版本控制工具</li>
<li>自身设计有问题，会造成提交文件不完整，版本库莫名其妙损坏的情况</li>
</ul>
<h4 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h4><ul>
<li>修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制工具</li>
</ul>
<h4 id="ClearCase"><a href="#ClearCase" class="headerlink" title="ClearCase"></a>ClearCase</h4><ul>
<li>收费的集中式版本控制工具，安装比Windows还大，运行比蜗牛还慢</li>
<li>能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗或者人傻钱多</li>
</ul>
<h4 id="VSS"><a href="#VSS" class="headerlink" title="VSS"></a>VSS</h4><ul>
<li>微软的集中式版本控制工具，集成在Visual Studio中</li>
<li>由于它反人类的设计，连微软自己都不好意思用了</li>
</ul>
<h3 id="集中式版本控制"><a href="#集中式版本控制" class="headerlink" title="集中式版本控制"></a>集中式版本控制</h3><p><img src="/img/1.png" alt="集中式版本控制"></p>
<h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p><img src="/img/2.png" alt="分布式版本控制"></p>
<h3 id="git和SVN的简单对比"><a href="#git和SVN的简单对比" class="headerlink" title="git和SVN的简单对比"></a>git和SVN的简单对比</h3><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><ul>
<li>在很多情况下，git的速度远远比SVN快</li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li>SVN是集中式管理，git是分布式管理</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>SVN使用分支比较笨拙，git可以轻松拥有无限个分支</li>
<li>SVN必须联网才能正常工作，git支持本地版本控制工作</li>
<li>旧版本的SVN会在每一个目录置放一个.svn，git只会在根目录拥有一个.git</li>
</ul>
<h3 id="SVN的工作流程"><a href="#SVN的工作流程" class="headerlink" title="SVN的工作流程"></a>SVN的工作流程</h3><p><img src="/img/3.png" alt="SVN的工作流程"></p>
<h3 id="git的工作流程"><a href="#git的工作流程" class="headerlink" title="git的工作流程"></a>git的工作流程</h3><ul>
<li>分布式和集中式的最大区别在于：在分布式下开发者可以本地提交每个开发者机器上都有一个服务器的数据库<br><img src="/img/4.png" alt="git的工作流程"></li>
</ul>
<h3 id="使用Git"><a href="#使用Git" class="headerlink" title="使用Git"></a>使用Git</h3><p>跟SVN一样，你可以通过命令行敲指令或者图形界面客户端使用git，在Mac上，比较好用的git图形界面客户端有<br>SourceTree<br>下载地址：（<a href="http://www.sourcetreeapp.com/download/）" target="_blank" rel="external">http://www.sourcetreeapp.com/download/）</a><br>GitHub<br>下载地址：(<a href="https://mac.github.com" target="_blank" rel="external">https://mac.github.com</a>)<br>不过它是专门为GitHub网站而设计的</p>
<h3 id="Git的常用的指令"><a href="#Git的常用的指令" class="headerlink" title="Git的常用的指令"></a>Git的常用的指令</h3><p>git help ：git指令帮助手册</p>
<ul>
<li>查看其他指令的做法：git help 其他指令</li>
</ul>
<p>git config ：git的配置信息相关（修改的是.git/config文件）</p>
<ul>
<li>配置用户名：git config “user.name” 用户名（用于跟踪修改记录）</li>
<li>配置邮箱：git config “user.email” 邮箱（用于多人开发间的沟通）</li>
<li>查看配置信息：git config –l</li>
<li>编辑配置信息：git config –e（用vim编辑，:wq是退出vim编辑器）</li>
<li>设置指令的别名：git config alias.别名 原指令名称</li>
<li>设置带参数指令的别名：git config alias.别名 “原指令名称 参数”</li>
<li>将此设置应用到整个系统中：git config ––gloabal</li>
</ul>
<p>git status ：查文件的状态</p>
<ul>
<li>查看某个文件的状态：git status 文件名</li>
<li>查看当前路径所有文件的状态：git status</li>
</ul>
<p>git log ：查看文件的修改日志</p>
<ul>
<li>查看某个文件的修改日志：git log 文件名</li>
<li>查看当前路径所有文件的修改日志：git log</li>
<li>用一行的方式查看简单的日志信息：git log ––pretty=oneline</li>
<li>查看最近的N次修改：git log –N（N是一个整数）</li>
</ul>
<p>git diff ：查看文件最新改动的地方</p>
<ul>
<li>查看某个文件的最新改动的地方：git diff 文件名</li>
<li>查看当前路径所有文件最新改动的地方：git diff</li>
</ul>
<p>git init ：初始化一个空的本地仓库，生成一个.git目录，用于维护版本信息</p>
<ul>
<li>在当前路径初始化仓库：git init</li>
<li>在其他路径初始化仓库：git init 仓库路径</li>
</ul>
<p>git add ：将工作区的文件保存到暂缓区</p>
<ul>
<li>保存某个文件到暂缓区：git add 文件名</li>
<li>保存当前路径的所有文件到暂缓区：git add .（注意，最后是一个点 . ）</li>
</ul>
<p>git commit ：将暂缓区的文件提交到当前分支</p>
<ul>
<li>提交某个文件到分支：git commit -m ”注释” 文件名</li>
<li>保存当前路径的所有文件到分支：git commit -m ”注释” </li>
</ul>
<p>git reset ：版本回退（建议加上––hard参数，git支持无限次后悔）</p>
<ul>
<li>回退到上一个版本：git reset ––hard HEAD^</li>
<li>回退到上上一个版本：git reset ––hard HEAD^^</li>
<li>回退到上N个版本：git reset ––hard HEAD~N（N是一个整数）</li>
<li>回退到任意一个版本：git reset ––hard 版本号（版本号用7位即可）</li>
</ul>
<p>git reflog ：查看分支引用记录（能够查看所有的版本号）<br>git rm：删除文件（删完之后要进行commit操作，才能同步到版本库）<br>git clone：下载远程仓库到本地</p>
<ul>
<li>下载远程仓库到当前路径：git clone 仓库的URL</li>
<li>下载远程仓库到特定路径：git clone 仓库的URL 存放仓库的路径</li>
</ul>
<p>git pull：下载远程仓库的最新信息到本地仓库<br>git push：将本地的仓库信息推送到远程仓库</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>如果是多人团队开发，最好还是搭建一个远程仓库,搭建远程仓库的途径</p>
<p>自己搭建一个git服务器：费时费力<br>在GitHub上托管项目：公开项目免费、私有项目收费，很多第三方开源项目<br>在oschina上托管项目：完全免费，在国内访问速度快（推荐使用）</p>
<h4 id="搭建GitHub远程仓库-–-配置SSH-Key"><a href="#搭建GitHub远程仓库-–-配置SSH-Key" class="headerlink" title="搭建GitHub远程仓库 – 配置SSH Key"></a>搭建GitHub远程仓库 – 配置SSH Key</h4><p>注册一个GitHub帐号：（<a href="https://github.com" target="_blank" rel="external">https://github.com</a>)<br>打开“Account Settings”<br>点击“SSH keys”<br>配置Mac的SSH Key的公钥（用于限制提交）<br>在Mac上生成SSH Key（在终端输入下面指令）<br>cd ~/.ssh<br>ssh-keygen -t rsa -C “你的邮箱地址”<br>然后一直敲回车<br>然后就会在~/.ssh目录下生成SSK Key的秘钥对<br>id_rsa ：私钥，不可泄露<br>id_rsa.pub ：公钥，可以公开（将这个文件的内容粘贴到GitHub上）<br>利用cat指令可以查看文件的内容<br>cat id_rsa.pub</p>
<h4 id="搭建GitHub远程仓库–-添加仓库"><a href="#搭建GitHub远程仓库–-添加仓库" class="headerlink" title="搭建GitHub远程仓库– 添加仓库"></a>搭建GitHub远程仓库– 添加仓库</h4><p><img src="/img/6.png" alt="添加一个仓库"></p>
<h4 id="拷贝仓库地址，用于下载到本地"><a href="#拷贝仓库地址，用于下载到本地" class="headerlink" title="拷贝仓库地址，用于下载到本地"></a>拷贝仓库地址，用于下载到本地</h4><p><img src="/img/7.png" alt="拷贝仓库地址用于下载到本地"></p>
<h4 id="如果想删除仓库，也很简单"><a href="#如果想删除仓库，也很简单" class="headerlink" title="如果想删除仓库，也很简单"></a>如果想删除仓库，也很简单</h4><p><img src="/img/8.png" alt="删除"></p>
<h2 id="搭建oschina远程仓库-–创建仓库"><a href="#搭建oschina远程仓库-–创建仓库" class="headerlink" title="搭建oschina远程仓库 –创建仓库"></a>搭建oschina远程仓库 –创建仓库</h2><p>注册一个oschina帐号:(<a href="https://git.oschina.net" target="_blank" rel="external">https://git.oschina.net</a>)<br><img src="/img/9.png" alt="创建一个新项目"><br><img src="/img/10.png" alt=""></p>
<h2 id="搭建oschina远程仓库-–仓库地址"><a href="#搭建oschina远程仓库-–仓库地址" class="headerlink" title="搭建oschina远程仓库 –仓库地址"></a>搭建oschina远程仓库 –仓库地址</h2><p><img src="/img/11.png" alt=""></p>
<p><img src="/img/12.png" alt="添加项目组成员"></p>
<h2 id="搭建oschina远程仓库-–-删除仓库"><a href="#搭建oschina远程仓库-–-删除仓库" class="headerlink" title="搭建oschina远程仓库 – 删除仓库"></a>搭建oschina远程仓库 – 删除仓库</h2><p><img src="/img/13.png" alt="添加项目组成员"></p>
<h1 id="二、本地的Git操作"><a href="#二、本地的Git操作" class="headerlink" title="二、本地的Git操作"></a>二、本地的Git操作</h1><hr>
<h2 id="1-GIT命令行帮助"><a href="#1-GIT命令行帮助" class="headerlink" title="1.GIT命令行帮助"></a>1.GIT命令行帮助</h2><p>$ svn help<br>查看svn所有命令的帮助<br>$ svn help 子命令</p>
<ul>
<li>要退出帮助信息，按”q”</li>
<li>翻看下页，按”空格”</li>
<li>翻看上页，按”CTRL+B”</li>
<li>要搜索相关文字，按”/“然后输入”相关文字”</li>
</ul>
<h2 id="2-创建代码库-amp-配置个人信息"><a href="#2-创建代码库-amp-配置个人信息" class="headerlink" title="2.创建代码库 &amp; 配置个人信息"></a>2.创建代码库 &amp; 配置个人信息</h2><h3 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h3><p>$ git init</p>
<h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><p>$ git config user.name lnj<br>$ git config user.email lnj@gmail.com</p>
<ul>
<li>以上两个命令会将用户信息保存在当前代码仓库中,只有配置了用户和邮箱之后，git才能识别出操作的人员信息，通过钩子(hooks)程序可以设置一些动作, 例如单元测试发现问题后，自动给相关人员发送电子邮件</li>
</ul>
<h3 id="如果要一次性配置完成可以使用一下命令"><a href="#如果要一次性配置完成可以使用一下命令" class="headerlink" title="如果要一次性配置完成可以使用一下命令"></a>如果要一次性配置完成可以使用一下命令</h3><p>$ git config –global user.name lnj<br>$ git config –global user.email lnj321@gmail.com</p>
<ul>
<li>以上两个命令会将用户信息保存在用户目录下的 .gitconfig 文件中</li>
</ul>
<h3 id="查看当前所有配置"><a href="#查看当前所有配置" class="headerlink" title="查看当前所有配置"></a>查看当前所有配置</h3><p>$ git config -l</p>
<h2 id="3-实际开发"><a href="#3-实际开发" class="headerlink" title="3.实际开发"></a>3.实际开发</h2><h3 id="创建代码，开始开发"><a href="#创建代码，开始开发" class="headerlink" title="创建代码，开始开发"></a>创建代码，开始开发</h3><p>$ touch main.c<br>$ open main.c</p>
<h3 id="将代码添加到代码库"><a href="#将代码添加到代码库" class="headerlink" title="将代码添加到代码库"></a>将代码添加到代码库</h3><h4 id="查看当前代码库状态"><a href="#查看当前代码库状态" class="headerlink" title="查看当前代码库状态"></a>查看当前代码库状态</h4><p>$ git status</p>
<h4 id="将文件添加到代码库"><a href="#将文件添加到代码库" class="headerlink" title="将文件添加到代码库"></a>将文件添加到代码库</h4><p>$ git add main.c</p>
<h4 id="将修改提交到代码库"><a href="#将修改提交到代码库" class="headerlink" title="将修改提交到代码库"></a>将修改提交到代码库</h4><p>$ git commit -m “添加了main.c”</p>
<p>提示：</p>
<ul>
<li>在此一定要使用 -m 参数指定修改的备注信息</li>
<li>否则会进入 vim 编辑器，如果对vim不熟悉，会是很糟糕的事情</li>
</ul>
<h3 id="将当前文件夹下的所有新建或修改的文件一次性添加到代码库"><a href="#将当前文件夹下的所有新建或修改的文件一次性添加到代码库" class="headerlink" title="将当前文件夹下的所有新建或修改的文件一次性添加到代码库"></a>将当前文件夹下的所有新建或修改的文件一次性添加到代码库</h3><p>$ git add .</p>
<h4 id="添加多个文件"><a href="#添加多个文件" class="headerlink" title="添加多个文件"></a>添加多个文件</h4><p>$ touch Person.h Person.m<br>$ git add .<br>$ git commit -m “添加了Person类”<br>$ open Person.h<br>$ git add .<br>$ git commit -m “增加Person类属性”</p>
<ul>
<li>注意 使用git时，每一次修改都需要添加再提交，这一点是与svn不一样的<h4 id="git-的重要概念及工作原理"><a href="#git-的重要概念及工作原理" class="headerlink" title="git 的重要概念及工作原理"></a>git 的重要概念及工作原理</h4>工作区<br>暂存区(staged)<br>分支(HEAD)</li>
</ul>
<h2 id="3-别名-amp-日志"><a href="#3-别名-amp-日志" class="headerlink" title="3.别名 &amp; 日志"></a>3.别名 &amp; 日志</h2><p>$ git config alias.st status<br>$ git config alias.ci “commit -m”</p>
<ul>
<li>个人建议：除非特殊原因，最好不要设置别名，否则换一台机器就不会用了<h4 id="查看所有版本库日志"><a href="#查看所有版本库日志" class="headerlink" title="查看所有版本库日志"></a>查看所有版本库日志</h4>$ git log<h4 id="查看指定文件的版本库日志"><a href="#查看指定文件的版本库日志" class="headerlink" title="查看指定文件的版本库日志"></a>查看指定文件的版本库日志</h4>$ git log 文件名<h4 id="配置带颜色的log别名"><a href="#配置带颜色的log别名" class="headerlink" title="配置带颜色的log别名"></a>配置带颜色的log别名</h4>$ git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”<br>提示：在git中，版本号是一个由SHA1生成的哈希值</li>
</ul>
<h2 id="4-版本号，让我们在任意版本之间穿梭"><a href="#4-版本号，让我们在任意版本之间穿梭" class="headerlink" title="4.版本号，让我们在任意版本之间穿梭"></a>4.版本号，让我们在任意版本之间穿梭</h2><h3 id="回到当前版本，放弃所有没有提交的修改"><a href="#回到当前版本，放弃所有没有提交的修改" class="headerlink" title="回到当前版本，放弃所有没有提交的修改"></a>回到当前版本，放弃所有没有提交的修改</h3><p>$ git reset –hard HEAD</p>
<h3 id="回到上一个版本"><a href="#回到上一个版本" class="headerlink" title="回到上一个版本"></a>回到上一个版本</h3><p>$ git reset –hard HEAD^</p>
<h3 id="回到之前第3个修订版本"><a href="#回到之前第3个修订版本" class="headerlink" title="回到之前第3个修订版本"></a>回到之前第3个修订版本</h3><p>$ git reset –hard HEAD~(3)</p>
<h3 id="回到指定版本号的版本"><a href="#回到指定版本号的版本" class="headerlink" title="回到指定版本号的版本"></a>回到指定版本号的版本</h3><p>$ git reset e695b67</p>
<h3 id="查看分支引用记录"><a href="#查看分支引用记录" class="headerlink" title="查看分支引用记录"></a>查看分支引用记录</h3><p>$ git reflog</p>
<h2 id="5-单个文件的修改管理"><a href="#5-单个文件的修改管理" class="headerlink" title="5.单个文件的修改管理"></a>5.单个文件的修改管理</h2><h3 id="查看文件变化"><a href="#查看文件变化" class="headerlink" title="查看文件变化"></a>查看文件变化</h3><p>$ git diff</p>
<h3 id="撤销对文件做的修改"><a href="#撤销对文件做的修改" class="headerlink" title="撤销对文件做的修改"></a>撤销对文件做的修改</h3><p>$ git checkout Person.h</p>
<h3 id="从代码库（暂存区中删除文件）"><a href="#从代码库（暂存区中删除文件）" class="headerlink" title="从代码库（暂存区中删除文件）"></a>从代码库（暂存区中删除文件）</h3><h1 id="三、Git团队开发操作"><a href="#三、Git团队开发操作" class="headerlink" title="三、Git团队开发操作"></a>三、Git团队开发操作</h1><hr>
<h2 id="1-建立代码仓库-专门用于团队开发的代码仓库"><a href="#1-建立代码仓库-专门用于团队开发的代码仓库" class="headerlink" title="1.建立代码仓库(专门用于团队开发的代码仓库)"></a>1.建立代码仓库(专门用于团队开发的代码仓库)</h2><h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><p>$ cd /Users/lnj/Desktop/git演练/公司/weibo</p>
<h3 id="建立空白代码库-专门用于团队开发"><a href="#建立空白代码库-专门用于团队开发" class="headerlink" title="建立空白代码库(专门用于团队开发)"></a>建立空白代码库(专门用于团队开发)</h3><p>$ git init –bare</p>
<h2 id="2-项目经理准备项目-前奏"><a href="#2-项目经理准备项目-前奏" class="headerlink" title="2.项目经理准备项目(前奏)"></a>2.项目经理准备项目(前奏)</h2><h3 id="切换目录-1"><a href="#切换目录-1" class="headerlink" title="切换目录"></a>切换目录</h3><p>$ cd /Users/lnj/Desktop/git演练/经理</p>
<h3 id="“克隆”代码库到本地"><a href="#“克隆”代码库到本地" class="headerlink" title="“克隆”代码库到本地"></a>“克隆”代码库到本地</h3><p>$ git clone /Users/lnj/Desktop/git演练/公司/weibo/</p>
<h3 id="个人信息配置-因为要演示一台机器上的多人协作，日常开发可以忽略"><a href="#个人信息配置-因为要演示一台机器上的多人协作，日常开发可以忽略" class="headerlink" title="个人信息配置(因为要演示一台机器上的多人协作，日常开发可以忽略)"></a>个人信息配置(因为要演示一台机器上的多人协作，日常开发可以忽略)</h3><p>$ git config user.name manager<br>$ git config user.email manager@163.com</p>
<p>.gitignore<br>.gitignore可以指定哪些文件不纳入版本库的管理</p>
<p>参考网址:(<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a>)</p>
<h1 id="命令行中进入与-git同级的目录"><a href="#命令行中进入与-git同级的目录" class="headerlink" title="命令行中进入与.git同级的目录"></a>命令行中进入与.git同级的目录</h1><p>$ cd /Users/lnj/Desktop/git演练/经理/weibo</p>
<ul>
<li>将以下命令一次性粘贴到命令行中</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">echo -e "# Xcode</div><div class="line">#</div><div class="line">build/</div><div class="line">*.pbxuser</div><div class="line">*.mode1v3</div><div class="line">*.mode2v3</div><div class="line">*.perspectivev3</div><div class="line">xcuserdata</div><div class="line">*.xccheckout</div><div class="line">*.moved-aside</div><div class="line">DerivedData</div><div class="line">*.hmap</div><div class="line">*.ipa</div><div class="line">*.xcuserstate</div><div class="line"># CocoaPods</div><div class="line">#</div><div class="line"># We recommend against adding the Pods directory to your .gitignore. However</div><div class="line"># you should judge for yourself, the pros and cons are mentioned at:</div><div class="line"># http://guides.cocoapods.org/using/using-cocoapods.html#should-i-ignore-the-pods-directory-in-source-control</div><div class="line">#</div><div class="line"># Pods/" &gt; .gitignore</div></pre></td></tr></table></figure>
<h3 id="将-gitignore添加到代码库"><a href="#将-gitignore添加到代码库" class="headerlink" title="将.gitignore添加到代码库"></a>将.gitignore添加到代码库</h3><p>$ git add .gitignore</p>
<h2 id="3-创建项目"><a href="#3-创建项目" class="headerlink" title="3.创建项目"></a>3.创建项目</h2><ul>
<li>提交同时”push”到远程代码仓库</li>
</ul>
<h2 id="4-新人加入"><a href="#4-新人加入" class="headerlink" title="4.新人加入"></a>4.新人加入</h2><p>…</p>
<h2 id="5-分布式的代码库-仅供参考"><a href="#5-分布式的代码库-仅供参考" class="headerlink" title="5.分布式的代码库 - 仅供参考"></a>5.分布式的代码库 - 仅供参考</h2><ul>
<li>由于git是分布式的，任何一台计算机上都保留有完整的代码库的内容，因此可以把团队开发的代码库放在任何位置</li>
</ul>
<h2 id="6-分支管理-Tag"><a href="#6-分支管理-Tag" class="headerlink" title="6.分支管理 - Tag"></a>6.分支管理 - Tag</h2><h3 id="查看当前标签"><a href="#查看当前标签" class="headerlink" title="查看当前标签"></a>查看当前标签</h3><p>$ git tag</p>
<h3 id="在本地代码库给项目打上一个标签"><a href="#在本地代码库给项目打上一个标签" class="headerlink" title="在本地代码库给项目打上一个标签"></a>在本地代码库给项目打上一个标签</h3><p>$ git tag -a v1.0 -m ‘Version 1.0’</p>
<h3 id="将标签添推送到远程代码库中"><a href="#将标签添推送到远程代码库中" class="headerlink" title="将标签添推送到远程代码库中"></a>将标签添推送到远程代码库中</h3><p>$ git push origin v1.0</p>
<ul>
<li>使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本</li>
</ul>
<h3 id="签出v1-0标签"><a href="#签出v1-0标签" class="headerlink" title="签出v1.0标签"></a>签出v1.0标签</h3><p>$ git checkout v1.0</p>
<h3 id="从签出状态创建v1-0bugfix分支"><a href="#从签出状态创建v1-0bugfix分支" class="headerlink" title="从签出状态创建v1.0bugfix分支"></a>从签出状态创建v1.0bugfix分支</h3><p>$ git checkout -b bugfix1.0</p>
<h3 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h3><p>$ git branch -r</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>$ git branch -r -d origin/bugfix1.0</p>
<h1 id="四、Git分支管理-了解"><a href="#四、Git分支管理-了解" class="headerlink" title="四、Git分支管理(了解)"></a>四、Git分支管理(了解)</h1><hr>
<h2 id="1-分布式的代码库-仅供参考"><a href="#1-分布式的代码库-仅供参考" class="headerlink" title="1.分布式的代码库 - 仅供参考"></a>1.分布式的代码库 - 仅供参考</h2><ul>
<li>由于git是分布式的，任何一台计算机上都保留有完整的代码库的内容，因此可以把团队开发的代码库放在任何位置</li>
<li>多个远程代码库之间的同步演练”提示，此演练仅供了解，具体的使用，需要一定的团队规模之后，才能够体会”</li>
</ul>
<h2 id="2-分支管理-Tag"><a href="#2-分支管理-Tag" class="headerlink" title="2.分支管理 - Tag"></a>2.分支管理 - Tag</h2><h3 id="查看当前标签-1"><a href="#查看当前标签-1" class="headerlink" title="查看当前标签"></a>查看当前标签</h3><p>$ git tag</p>
<h3 id="在本地代码库给项目打上一个标签-1"><a href="#在本地代码库给项目打上一个标签-1" class="headerlink" title="在本地代码库给项目打上一个标签"></a>在本地代码库给项目打上一个标签</h3><p>$ git tag -a v1.0 -m ‘Version 1.0’</p>
<h3 id="将标签添推送到远程代码库中-1"><a href="#将标签添推送到远程代码库中-1" class="headerlink" title="将标签添推送到远程代码库中"></a>将标签添推送到远程代码库中</h3><p>$ git push origin v1.0</p>
<h3 id="使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本"><a href="#使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本" class="headerlink" title="使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本"></a>使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本</h3><h3 id="签出v1-0标签-1"><a href="#签出v1-0标签-1" class="headerlink" title="签出v1.0标签"></a>签出v1.0标签</h3><p>$ git checkout v1.0</p>
<h3 id="从签出状态创建v1-0bugfix分支-1"><a href="#从签出状态创建v1-0bugfix分支-1" class="headerlink" title="从签出状态创建v1.0bugfix分支"></a>从签出状态创建v1.0bugfix分支</h3><p>$ git checkout -b bugfix1.0</p>
<h3 id="查看远程分支-1"><a href="#查看远程分支-1" class="headerlink" title="查看远程分支"></a>查看远程分支</h3><p>$ git branch -r</p>
<h3 id="删除远程分支-1"><a href="#删除远程分支-1" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>$ git branch -r -d origin/bugfix1.0</p>
<h1 id="四、Github使用-amp-如何学习第三方库"><a href="#四、Github使用-amp-如何学习第三方库" class="headerlink" title="四、Github使用&amp;如何学习第三方库"></a>四、Github使用&amp;如何学习第三方库</h1><hr>
<h2 id="如何使用-学习第三方框架-优秀的第三方框架都在-github-com。"><a href="#如何使用-学习第三方框架-优秀的第三方框架都在-github-com。" class="headerlink" title="如何使用/学习第三方框架?优秀的第三方框架都在 github.com。"></a>如何使用/学习第三方框架?优秀的第三方框架都在 github.com。</h2><h3 id="1-搜索"><a href="#1-搜索" class="headerlink" title="1.搜索"></a>1.搜索</h3><h3 id="2-git-clone-获得完整版本"><a href="#2-git-clone-获得完整版本" class="headerlink" title="2.git clone 获得完整版本"></a>2.git clone 获得完整版本</h3><p>$ git clone <a href="https://github.com/AFNetworking/AFNetworking.git" target="_blank" rel="external">https://github.com/AFNetworking/AFNetworking.git</a></p>
<h3 id="3-获取最新版本-git-pull"><a href="#3-获取最新版本-git-pull" class="headerlink" title="3.获取最新版本 git pull"></a>3.获取最新版本 git pull</h3><ul>
<li>进入clone的本地文件夹<br>$ git pull<h3 id="4-看github上的文档-优秀的第三方框架都有好的文档"><a href="#4-看github上的文档-优秀的第三方框架都有好的文档" class="headerlink" title="4.看github上的文档,优秀的第三方框架都有好的文档"></a>4.看github上的文档,优秀的第三方框架都有好的文档</h3><h3 id="5-编写测试程序-看运行结果"><a href="#5-编写测试程序-看运行结果" class="headerlink" title="5.编写测试程序,看运行结果"></a>5.编写测试程序,看运行结果</h3><h3 id="6-针对感兴趣的部分-看源代码"><a href="#6-针对感兴趣的部分-看源代码" class="headerlink" title="6.针对感兴趣的部分,看源代码"></a>6.针对感兴趣的部分,看源代码</h3><h3 id="7-有问题去-http-stackoverflow-com"><a href="#7-有问题去-http-stackoverflow-com" class="headerlink" title="7.有问题去(http://stackoverflow.com)"></a>7.有问题去(<a href="http://stackoverflow.com" target="_blank" rel="external">http://stackoverflow.com</a>)</h3></li>
</ul>
<h1 id="五、练习笔记"><a href="#五、练习笔记" class="headerlink" title="五、练习笔记"></a>五、练习笔记</h1><hr>
<p>1.新建一个“本地仓库”<br>$ git init</p>
<p>2.配置仓库<br>》告诉git你是谁<br>git config user.name lnj<br>》告诉git怎么联系你<br>git config user.email lnj@itcast.cn</p>
<p>》上面一种配置方式是一次性的配置， 会配置到被管理文件的。git文件夹下<br>》下面一种配置方式是一劳永逸的方式:<br>git config –global user.name lmj<br>git config –global user.email lmj@itcast.cn</p>
<p>》如何学习git指令</p>
<blockquote>
<p>学习git指令和SVN指令的学习其实是一样的， 只不过展现的方式不太一样， git是通过使用指南的方式告诉我们某一个指令如何使用<br>这个指南其实是一个不可编辑的vim<br>Q退出指南<br>按空格下一页<br>control + B 上一页<br>/需要搜索的内容 可以进行搜索</p>
</blockquote>
<p>git常规指令<br>》git status 查看文件状态<br>》git add 添加文件到“暂存区”<br>》git commit 文件名称   添加文件到”本地仓库“<br>注意：如果没有在commit后面加上 -m说明修改了什么， 会自动进入vim界面， 要求我们输入修改信息<br>按键盘上的 i 代表开始输入内容<br>输入完毕之后按 esc 然后按 ：wq<br>所以： 如果以后在终端中提交最好在后面加上-m<br>》注意： git中的add和SVN中的add不太一样， SVN中只需要add一次， 而git中每次新建或者修改之后都需要重新add</p>
<p>》1.为添加之前的颜色<br>红色 代表在”工作区“<br>》2.添加到暂存区之后的颜色<br>绿色 代码在”暂存区“</p>
<p>》注意： git默认没有简写指令<br>》注意： 一般情况下不建议自定义简写指令<br>》git中的简写称之为起别名</p>
<blockquote>
<p>查看log<br>》git log 文件名<br>》注意： GIt中的版本号是一个”40位“的哈希值， 而SVN中的版本号是一个递增的整数<br>》已经提交<br>git reset —hard HEAD^ 返回上一个版本<br>其中—hard代表强制重置<br>git reset —hard 版本号（只需要写前7位）<br>》未提交<br>git checkout 文件名 回退到上一次提交的版本<br>git reset —hard HEAD  回退到上一次提交的版, 注意HEAD后面没有尖号^</p>
</blockquote>
<p>c9ad690 HEAD@{0}: commit: main.c</p>
<p>7026f99 HEAD@{1}: commit: 输出结果</p>
<p>e950c89 HEAD@{2}: commit: 新增输入</p>
<p>c7bf91c HEAD@{3}: commit: 添加变量</p>
<p>cbd9e52 HEAD@{4}: commit: 删除print函数</p>
<p>45ea44d HEAD@{5}: commit: 添加了printf函数</p>
<p>0da06d8 HEAD@{6}: commit (initial): i</p>
<blockquote>
<p>git reflog  查看所有修改信息（所有版本）</p>
</blockquote>
<p>》查看文件被修改的什么地方<br>】    》git diff 文件名<br>》如果显示绿色代表新增<br>》如果显示红色代表删除</p>
<p>远程仓库<br>SVN需要一个单独的服务器<br>Git不需要： 文件中、U盘中、云上、github、OSChina…</p>
<p>1.新建git远程仓库<br>》git init —bare<br>注意： 这个仓库仅仅是用于管理代码， 不参与开发</p>
<p>2.项目经理初始化项目<br>》2.1先克隆一份空得仓库到本地<br>git clone /Users/apple/Desktop/working/公司远程仓库</p>
<p>》2.2忽略不需要加入版本控制器的文件以及文件夹<br>.gitignore<br>注意： 配置忽略文件只需要到github上搜索.gitignore拷贝别人写好的代码即可<br>配置.gitignore一定要在和.git隐藏文件夹同一级的目录下<br>》2.3生成好.gitignore文件之后， 还需要将.gitignore文件添加到版本控制<br>git add  .gitignore<br>git commit .gitignore -m””</p>
<p>》2.4新建项目<br>》 source conrol—&gt;commit  将代码提交到本地仓库<br>》source conrol—&gt;push 将代码提交到远程仓库</p>
<p>git中默认就会创建一个分支， 这个分支叫做origin/master， 相当于svn中的trunk</p>
<p>专业人员只需要在git仓库的hooks文件夹中写一些指令， 就可以完成自动测试（压力测试、自动测试、集成测试、冒烟测试、。。。）</p>
<p>》 和SVN一样， 如果服务器仓库的代码被修改了， 我们再提交代码也会报错。<br>fetch first == out of data</p>
<p>总结：<br>git和svn最大的区别<br>》1.git每次修改新增都需要add<br>》2.git每台电脑都有一个仓库<br>》3.git是先提交到本地仓库， 再提交到远程仓库</p>
<p>新人服务器搭建<br>1.新建一个新人服务器<br>2.初始化仓库<br>git init –bare<br>3.添加一个新的远程仓库<br>source control —&gt; master —&gt;config —&gt;remotes —&gt;add —&gt; add remote<br>4.将经理最新的代码提交到新人服务器<br>5.经理分配新人服务器的地址给新人</p>
<p>GIT的分支管理<br>》在本地代码库给项目打上一个标签<br>git tag -a v1.0 -m ‘Version 1.0’<br>》查看当前标签<br>git tag<br>注意： 此时此刻打上的这个标签仅仅是一个本地标签。（和服务器没有关系）<br>》将标签添推送到远程代码库中<br>git push origin v1.0</p>
<p>1.开发<br>2.发布<br>3.保存稳定版本<br>4.继续开发<br>5.出现bug<br>6.分配员工到分支上修复bug</p>
<blockquote>
<p>员工从服务器下载最新代码<br>》员工利用git checkout v1.0指令快速切换到1.0版本<br>》根据提示：开启一个新的分支开始修复代码<br>git checkout -b 1.0bug_fix</p>
</blockquote>
<p>7.合并修复后的代码到主线<br>8.备份稳定版本</p>
<p>通过Xcode将代码提交到github上， 把仓库放在github上</p>
<p>》1.注册一个github账号<br>》2.配置SSH Keys， 只要配置了SSH Keys就可以和github无缝衔接</p>
<p>》点击昵称来到个人主页<br>》点击主页中的设置（setting）<br>》点击SSH Keys<br>》点击 generating SSH keys</p>
<p>》1.检查本地的ssh keys<br>在“用户目录”下 ls -al ~/.ssh</p>
<p>2.如果文件夹不存在需要手动创建一个<br>mkdir .ssh</p>
<p>3.根据github的提示2生成ssh keys<br>在.ssh目录下执行 ssh-keygen -t rsa -C “your_email@example.com”<br>输入完成之后连续按下回车， 知道出现牛逼的图形位置</p>
<p>4.生成完公钥和私钥之后输入<br>ls -la查看是否生成成功   id_rsa（私钥） id_rsa.pub(公钥)</p>
<p>5.根据提示3获得公钥<br>pbcopy &lt; ~/.ssh/id_rsa.pub</p>
<p>6.点击 setting —》 ssh key —&gt;add ssh key<br>将刚才获取到得公钥添加进去</p>
<p>7.更具github第4步提示， 验证公钥<br>验证成功网页上的灰色圆点会变成绿色</p>
<p>8.拷贝到公钥之后打开github主页<br>》点击仓库（Repositories）<br>》再点击new来到github创建仓库界面</p>
<p>9.通过github提供的地址下载一个空得仓库到本地<br>》创建一个新的项目到本地仓库文件夹中<br>》利用Xcode提交代码到github<br>》注意： 要求输入用户名密码时候， 输入的是github上显示的昵称而不是登录账号</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios之ReactiveCocoa的使用]]></title>
      <url>http://yoursite.com/2014/02/19/2014/ReactiveCocoa/</url>
      <content type="html"><![CDATA[<h3 id="1-ReactiveCocoa简介"><a href="#1-ReactiveCocoa简介" class="headerlink" title="1.ReactiveCocoa简介"></a>1.ReactiveCocoa简介</h3><p>ReactiveCocoa（简称为<code>RAC</code>）,是由<code>Github</code>开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。</p>
<h3 id="2-ReactiveCocoa作用"><a href="#2-ReactiveCocoa作用" class="headerlink" title="2.ReactiveCocoa作用"></a>2.ReactiveCocoa作用</h3><ul>
<li>在我们iOS开发过程中，当某些事件响应的时候，需要处理某些业务逻辑,这些事件都用不同的方式来处理。</li>
<li>比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO等系统提供的方式。</li>
<li>其实这些事件，都可以通过RAC处理</li>
<li>ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中<code>高聚合，低耦合</code>的思想。</li>
</ul>
<h3 id="3-编程思想"><a href="#3-编程思想" class="headerlink" title="3.编程思想"></a>3.编程思想</h3><p>在开发中我们也不能太依赖于某个框架，否则这个框架不更新了，导致项目后期没办法维护，比如之前Facebook提供的<code>Three20框架</code>，在当时也是神器，但是后来不更新了，也就没什么人用了。因此我感觉学习一个框架，还是有必要了解它的<code>编程思想</code>。</p>
<p><code>编程思想的由来</code>：在开发中我们会遇见各种各样的需求，经常会思考如何快速的完成这些需求，这样就会慢慢形成快速完成这些需求的思想。</p>
<p>先简单介绍下目前咱们已知的<code>编程思想</code>。</p>
<p>3.1 <code>面向过程</code>：处理事情以过程为核心，一步一步的实现。</p>
<p>3.2 <code>面向对象</code>：万物皆对象</p>
<p>3.3 <code>链式编程思想</code>：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3)</p>
<ul>
<li><p><code>链式编程特点</code>：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）</p>
</li>
<li><p><code>代表</code>：masonry框架。</p>
</li>
<li><p><code>练习一</code>:模仿masonry，写一个加法计算器，练习链式编程思想。</p>
</li>
</ul>
<p>3.4 <code>响应式编程思想</code>：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。</p>
<ul>
<li><p><code>代表</code>：KVO运用。</p>
</li>
<li><p><code>练习二</code>:KVO底层实现。</p>
</li>
</ul>
<p>3.5 <code>函数式编程思想</code>：是把操作尽量写成一系列嵌套的函数或者方法调用。</p>
<ul>
<li><code>函数式编程本质</code>:就是往方法中传入Block,方法中嵌套Block调用，把代码聚合起来管理</li>
<li><p><code>函数式编程特点</code>：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）</p>
</li>
<li><p><code>代表</code>：ReactiveCocoa。</p>
</li>
<li><p><code>练习三</code>:用函数式编程实现，写一个加法计算器,并且加法计算器自带判断是否等于某个值.</p>
</li>
</ul>
<h3 id="4-ReactiveCocoa编程思想"><a href="#4-ReactiveCocoa编程思想" class="headerlink" title="4.ReactiveCocoa编程思想"></a>4.ReactiveCocoa编程思想</h3><p>ReactiveCocoa结合了几种编程风格：</p>
<p><code>函数式编程（Functional Programming）</code></p>
<p><code>响应式编程（Reactive Programming）</code></p>
<p>所以，你可能听说过ReactiveCocoa被描述为函数响应式编程（FRP）框架。</p>
<p>以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。</p>
<h3 id="5-如何导入ReactiveCocoa框架"><a href="#5-如何导入ReactiveCocoa框架" class="headerlink" title="5.如何导入ReactiveCocoa框架"></a>5.如何导入ReactiveCocoa框架</h3><p>通常都会使用CocoaPods（用于管理第三方框架的插件）帮助我们导入。</p>
<p>CocoaPods教程（<a href="http://code4app.com/article/cocoapods-install-usage）" target="_blank" rel="external">http://code4app.com/article/cocoapods-install-usage）</a></p>
<p><code>练习四</code>:创建一个新的工程，演示下，框架的导入。</p>
<p><code>注意</code>：</p>
<ul>
<li>podfile如果只描述pod ‘ReactiveCocoa’, ‘~&gt; 4.0.2-alpha-1’，会导入不成功<br><img src="Snip20150926_1.png" alt=""></li>
<li>报错信息<br><img src="Snip20150926_2.png" alt=""></li>
<li>需要在podfile加上use_frameworks，重新pod install 才能导入成功。<br><img src="Snip20150926_3.png" alt=""></li>
</ul>
<h3 id="6-ReactiveCocoa常见类。"><a href="#6-ReactiveCocoa常见类。" class="headerlink" title="6.ReactiveCocoa常见类。"></a>6.ReactiveCocoa常见类。</h3><p>学习框架首要之处:个人认为先要搞清楚框架中常用的类，在RAC中最核心的类RACSiganl,搞定这个类就能用ReactiveCocoa开发了。</p>
<p><code>练习五</code>:介绍常见类</p>
<p><code>RACSiganl</code>:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>
<ul>
<li><p>信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</p>
</li>
<li><p>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</p>
</li>
<li><p>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。</p>
</li>
<li><p><code>RACSiganl简单使用:</code></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACSignal使用步骤：</span></div><div class="line"><span class="comment">// 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span></div><div class="line"><span class="comment">// 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 3.发送信号 - (void)sendNext:(id)value</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RACSignal底层实现：</span></div><div class="line"><span class="comment">// 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。</span></div><div class="line"><span class="comment">// 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock</span></div><div class="line"><span class="comment">// 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。</span></div><div class="line"><span class="comment">// 2.1 subscribeNext内部会调用siganl的didSubscribe</span></div><div class="line"><span class="comment">// 3.siganl的didSubscribe中调用[subscriber sendNext:@1];</span></div><div class="line"><span class="comment">// 3.1 sendNext底层其实就是执行subscriber的nextBlock</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"><span class="comment">// block调用时刻：每当有订阅者订阅信号，就会调用block。</span></div><div class="line"></div><div class="line"><span class="comment">// 2.发送信号</span></div><div class="line">[subscriber sendNext:@<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</span></div><div class="line">[subscriber sendCompleted];</div><div class="line"></div><div class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line"></div><div class="line"><span class="comment">// block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</span></div><div class="line"></div><div class="line"><span class="comment">// 执行完Block后，当前信号就不在被订阅了。</span></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"信号被销毁"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号,才会激活信号.</span></div><div class="line">[siganl subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// block调用时刻：每当有信号发出数据，就会调用block.</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"接收到数据:%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>RACSubscriber</code>:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</p>
<p><code>RACDisposable</code>:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</p>
<ul>
<li><code>使用场景</code>:不想监听某个信号时，可以通过它主动取消订阅信号。</li>
</ul>
<p><code>RACSubject</code>:RACSubject:信号提供者，自己可以充当信号，又能发送信号。</p>
<ul>
<li><code>使用场景</code>:通常用来代替代理，有了它，就不必要定义代理了。</li>
</ul>
<p><code>RACReplaySubject</code>:重复提供信号类，RACSubject的子类。</p>
<ul>
<li><code>RACReplaySubject</code>与<code>RACSubject</code>区别:</li>
<li>RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。</li>
<li><code>使用场景一</code>:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li>
<li><p><code>使用场景二</code>:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。</p>
</li>
<li><p><code>RACSubject和RACReplaySubject简单使用:</code></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACSubject使用步骤</span></div><div class="line"><span class="comment">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span></div><div class="line"><span class="comment">// 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 3.发送信号 sendNext:(id)value</span></div><div class="line"></div><div class="line"><span class="comment">// RACSubject:底层实现和RACSignal不一样。</span></div><div class="line"><span class="comment">// 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</span></div><div class="line"><span class="comment">// 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSubject *subject = [RACSubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// block调用时刻：当信号发出新值，就会调用.</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者%@"</span>,x);</div><div class="line">&#125;];</div><div class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// block调用时刻：当信号发出新值，就会调用.</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.发送信号</span></div><div class="line">[subject sendNext:<span class="string">@"1"</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RACReplaySubject使用步骤:</span></div><div class="line"><span class="comment">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span></div><div class="line"><span class="comment">// 2.可以先订阅信号，也可以先发送信号。</span></div><div class="line"><span class="comment">// 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 2.2 发送信号 sendNext:(id)value</span></div><div class="line"></div><div class="line"><span class="comment">// RACReplaySubject:底层实现和RACSubject不一样。</span></div><div class="line"><span class="comment">// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span></div><div class="line"><span class="comment">// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock</span></div><div class="line"></div><div class="line"><span class="comment">// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。</span></div><div class="line"><span class="comment">// 也就是先保存值，在订阅值。</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACReplaySubject *replaySubject = [RACReplaySubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 2.发送信号</span></div><div class="line">[replaySubject sendNext:@<span class="number">1</span>];</div><div class="line">[replaySubject sendNext:@<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号</span></div><div class="line">[replaySubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者接收到的数据%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 订阅信号</span></div><div class="line">[replaySubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者接收到的数据%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li><code>RACSubject替换代理</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 需求:</span></div><div class="line"><span class="comment">// 1.给当前控制器添加一个按钮，modal到另一个控制器界面</span></div><div class="line"><span class="comment">// 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器</span></div><div class="line"></div><div class="line">步骤一：在第二个控制器.h，添加一个RACSubject代替代理。</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TwoViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSubject *delegateSignal;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">步骤二：监听第二个控制器按钮点击</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TwoViewController</span></span></div><div class="line">- (<span class="keyword">IBAction</span>)notice:(<span class="keyword">id</span>)sender &#123;</div><div class="line"><span class="comment">// 通知第一个控制器，告诉它，按钮被点了</span></div><div class="line"></div><div class="line"><span class="comment">// 通知代理</span></div><div class="line"><span class="comment">// 判断代理信号是否有值</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.delegateSignal) &#123;</div><div class="line"><span class="comment">// 有值，才需要通知</span></div><div class="line">[<span class="keyword">self</span>.delegateSignal sendNext:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OneViewController</span></span></div><div class="line">- (<span class="keyword">IBAction</span>)btnClick:(<span class="keyword">id</span>)sender &#123;</div><div class="line"></div><div class="line"><span class="comment">// 创建第二个控制器</span></div><div class="line">TwoViewController *twoVc = [[TwoViewController alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 设置代理信号</span></div><div class="line">twoVc.delegateSignal = [RACSubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 订阅代理信号</span></div><div class="line">[twoVc.delegateSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"点击了通知按钮"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 跳转到第二个控制器</span></div><div class="line">[<span class="keyword">self</span> presentViewController:twoVc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>RACTuple</code>:元组类,类似NSArray,用来包装值.</p>
<p><code>RACSequence</code>:RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。</p>
<p><code>使用场景</code>：1.字典转模型</p>
<p><code>RACSequence和RACTuple简单使用</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.遍历数组</span></div><div class="line"><span class="built_in">NSArray</span> *numbers = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// 这里其实是三步</span></div><div class="line"><span class="comment">// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence</span></div><div class="line"><span class="comment">// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal</span></div><div class="line"><span class="comment">// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。</span></div><div class="line">[numbers.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)</span></div><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"name"</span>:<span class="string">@"xmg"</span>,<span class="string">@"age"</span>:@<span class="number">18</span>&#125;;</div><div class="line">[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;</div><div class="line"></div><div class="line"><span class="comment">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span></div><div class="line">RACTupleUnpack(<span class="built_in">NSString</span> *key,<span class="built_in">NSString</span> *value) = x;</div><div class="line"></div><div class="line"><span class="comment">// 相当于以下写法</span></div><div class="line"><span class="comment">//        NSString *key = x[0];</span></div><div class="line"><span class="comment">//        NSString *value = x[1];</span></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,key,value);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3.字典转模型</span></div><div class="line"><span class="comment">// 3.1 OC写法</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *items = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> dictArr) &#123;</div><div class="line">FlagItem *item = [FlagItem flagWithDict:dict];</div><div class="line">[items addObject:item];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3.2 RAC写法</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *flags = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">_flags = flags;</div><div class="line"></div><div class="line"><span class="comment">// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。</span></div><div class="line">[dictArr.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// 运用RAC遍历字典，x：字典</span></div><div class="line"></div><div class="line">FlagItem *item = [FlagItem flagWithDict:x];</div><div class="line"></div><div class="line">[flags addObject:item];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,  <span class="built_in">NSStringFromCGRect</span>([<span class="built_in">UIScreen</span> mainScreen].bounds));</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3.3 RAC高级写法:</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"><span class="comment">// map:映射的意思，目的：把原始值value映射成一个新值</span></div><div class="line"><span class="comment">// array: 把集合转换成数组</span></div><div class="line"><span class="comment">// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。</span></div><div class="line"><span class="built_in">NSArray</span> *flags = [[dictArr.rac_sequence map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line"></div><div class="line"><span class="keyword">return</span> [FlagItem flagWithDict:value];</div><div class="line"></div><div class="line">&#125;] array];</div></pre></td></tr></table></figure>
<p><code>RACMulticastConnection</code>:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</p>
<p><code>使用注意</code>:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.</p>
<p><code>RACMulticastConnection简单使用</code>:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACMulticastConnection使用步骤:</span></div><div class="line"><span class="comment">// 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span></div><div class="line"><span class="comment">// 2.创建连接 RACMulticastConnection *connect = [signal publish];</span></div><div class="line"><span class="comment">// 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]</span></div><div class="line"><span class="comment">// 4.连接 [connect connect]</span></div><div class="line"></div><div class="line"><span class="comment">// RACMulticastConnection底层原理:</span></div><div class="line"><span class="comment">// 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号)  connect.signal -&gt; RACSubject</span></div><div class="line"><span class="comment">// 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。</span></div><div class="line"><span class="comment">// 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject</span></div><div class="line"><span class="comment">// 3.1.订阅原始信号，就会调用原始信号中的didSubscribe</span></div><div class="line"><span class="comment">// 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext</span></div><div class="line"><span class="comment">// 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。</span></div><div class="line"><span class="comment">// 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。</span></div><div class="line"><span class="comment">// 解决：使用RACMulticastConnection就能解决.</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建请求信号</span></div><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"发送请求"</span>);</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"接收数据"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"接收数据"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RACMulticastConnection:解决重复请求问题</span></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"发送请求"</span>);</div><div class="line">[subscriber sendNext:@<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2.创建连接</span></div><div class="line">RACMulticastConnection *connect = [signal publish];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号，</span></div><div class="line"><span class="comment">// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:</span></div><div class="line">[connect.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"订阅者一信号"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line">[connect.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"订阅者二信号"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 4.连接,激活信号</span></div><div class="line">[connect connect];</div></pre></td></tr></table></figure>
<p><code>RACCommand</code>:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</p>
<p><code>使用场景</code>:监听按钮点击，网络请求</p>
<p><code>RACCommand简单使用</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 一、RACCommand使用步骤:</span></div><div class="line"><span class="comment">// 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock</span></div><div class="line"><span class="comment">// 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值</span></div><div class="line"><span class="comment">// 3.执行命令 - (RACSignal *)execute:(id)input</span></div><div class="line"></div><div class="line"><span class="comment">// 二、RACCommand使用注意:</span></div><div class="line"><span class="comment">// 1.signalBlock必须要返回一个信号，不能传nil.</span></div><div class="line"><span class="comment">// 2.如果不想要传递信号，直接创建空的信号[RACSignal empty];</span></div><div class="line"><span class="comment">// 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</span></div><div class="line"></div><div class="line"><span class="comment">// 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</span></div><div class="line"><span class="comment">// 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。</span></div><div class="line"><span class="comment">// 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</span></div><div class="line"></div><div class="line"><span class="comment">// 四、如何拿到RACCommand中返回信号发出的数据。</span></div><div class="line"><span class="comment">// 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</span></div><div class="line"><span class="comment">// 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</span></div><div class="line"></div><div class="line"><span class="comment">// 五、监听当前命令是否正在执行executing</span></div><div class="line"></div><div class="line"><span class="comment">// 六、使用场景,监听按钮点击，网络请求</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 1.创建命令</span></div><div class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"执行命令"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建空信号,必须返回信号</span></div><div class="line"><span class="comment">//        return [RACSignal empty];</span></div><div class="line"></div><div class="line"><span class="comment">// 2.创建信号,用来传递数据</span></div><div class="line"><span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">[subscriber sendNext:<span class="string">@"请求数据"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。</span></div><div class="line">[subscriber sendCompleted];</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 强引用命令，不要被销毁，否则接收不到数据</span></div><div class="line">_conmmand = command;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3.执行命令</span></div><div class="line">[<span class="keyword">self</span>.conmmand execute:@<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// 4.订阅RACCommand中的信号</span></div><div class="line">[command.executionSignals subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line">[x subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// RAC高级用法</span></div><div class="line"><span class="comment">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号</span></div><div class="line">[command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 5.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</span></div><div class="line">[[command.executing skip:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ([x boolValue] == <span class="literal">YES</span>) &#123;</div><div class="line"><span class="comment">// 正在执行</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"正在执行"</span>);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="comment">// 执行完成</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"执行完成"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>RACScheduler</code>:RAC中的队列，用GCD封装的。</p>
<p><code>RACUnit</code> :表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.</p>
<p><code>RACEvent</code>: 把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。</p>
<h3 id="7-ReactiveCocoa开发中常见用法。"><a href="#7-ReactiveCocoa开发中常见用法。" class="headerlink" title="7.ReactiveCocoa开发中常见用法。"></a>7.ReactiveCocoa开发中常见用法。</h3><p>7.1 代替代理:</p>
<ul>
<li><code>rac_signalForSelector</code>：用于替代代理。</li>
</ul>
<p>7.2 代替KVO :</p>
<ul>
<li><code>rac_valuesAndChangesForKeyPath</code>：用于监听某个对象的属性改变。</li>
</ul>
<p>7.3 监听事件:</p>
<ul>
<li><code>rac_signalForControlEvents</code>：用于监听某个事件。</li>
</ul>
<p>7.4 代替通知:</p>
<ul>
<li><code>rac_addObserverForName</code>:用于监听某个通知。</li>
</ul>
<p>7.5 监听文本框文字改变:</p>
<ul>
<li><code>rac_textSignal</code>:只要文本框发出改变就会发出这个信号。</li>
</ul>
<p>7.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面</p>
<ul>
<li><code>rac_liftSelector:withSignalsFromArray:Signals</code>:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</li>
<li>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</li>
</ul>
<p>7.7 代码演示</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1.代替代理</span></div><div class="line"><span class="comment">// 需求：自定义redView,监听红色view中按钮点击</span></div><div class="line"><span class="comment">// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</span></div><div class="line"><span class="comment">// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</span></div><div class="line"><span class="comment">// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</span></div><div class="line">[[redV rac_signalForSelector:<span class="keyword">@selector</span>(btnClick:)] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"点击红色按钮"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2.KVO</span></div><div class="line"><span class="comment">// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</span></div><div class="line"><span class="comment">// observer:可以传入nil</span></div><div class="line">[[redV rac_valuesAndChangesForKeyPath:<span class="string">@"center"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.监听事件</span></div><div class="line"><span class="comment">// 把按钮点击事件转换为信号，点击按钮，就会发送信号</span></div><div class="line">[[<span class="keyword">self</span>.btn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"按钮被点击了"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 4.代替通知</span></div><div class="line"><span class="comment">// 把监听到的通知转换信号</span></div><div class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="built_in">UIKeyboardWillShowNotification</span> object:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"键盘弹出"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 5.监听文本框的文字改变</span></div><div class="line">[_textField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"文字改变了%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 6.处理多个请求，都返回结果的时候，统一做处理.</span></div><div class="line">RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"><span class="comment">// 发送请求1</span></div><div class="line">[subscriber sendNext:<span class="string">@"发送请求1"</span>];</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"><span class="comment">// 发送请求2</span></div><div class="line">[subscriber sendNext:<span class="string">@"发送请求2"</span>];</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</span></div><div class="line">[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 更新UI</span></div><div class="line">- (<span class="keyword">void</span>)updateUIWithR1:(<span class="keyword">id</span>)data r2:(<span class="keyword">id</span>)data1</div><div class="line">&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"更新UI%@  %@"</span>,data,data1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="8-ReactiveCocoa常见宏。"><a href="#8-ReactiveCocoa常见宏。" class="headerlink" title="8.ReactiveCocoa常见宏。"></a>8.ReactiveCocoa常见宏。</h3><p>8.1 <code>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</code>:用于给某个对象的某个属性绑定。</p>
<p><code>基本用法</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只要文本框文字改变，就会修改label的文字</span></div><div class="line">RAC(<span class="keyword">self</span>.labelView,text) = _textField.rac_textSignal;</div></pre></td></tr></table></figure>
<p>8.2 <code>RACObserve(self, name)</code>:监听某个对象的某个属性,返回的是信号。</p>
<p><code>基本用法</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[RACObserve(<span class="keyword">self</span>.view, center) subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>8.3  <code>@weakify(Obj)和@strongify(Obj)</code>,一般两个都是配套使用,解决循环引用问题.</p>
<p>8.4 <code>RACTuplePack</code>：把数据包装成RACTuple（元组类）</p>
<p><code>基本用法</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把参数中的数据包装成元组</span></div><div class="line">RACTuple *tuple = RACTuplePack(@<span class="number">10</span>,@<span class="number">20</span>);</div></pre></td></tr></table></figure></p>
<p>8.5 <code>RACTupleUnpack</code>：把RACTuple（元组类）解包成对应的数据。</p>
<p><code>基本用法</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把参数中的数据包装成元组</span></div><div class="line">RACTuple *tuple = RACTuplePack(<span class="string">@"xmg"</span>,@<span class="number">20</span>);</div><div class="line"></div><div class="line"><span class="comment">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span></div><div class="line"><span class="comment">// name = @"xmg" age = @20</span></div><div class="line">RACTupleUnpack(<span class="built_in">NSString</span> *name,<span class="built_in">NSNumber</span> *age) = tuple;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[静态库的制作]]></title>
      <url>http://yoursite.com/2014/02/16/2014/%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="一、什么是库？"><a href="#一、什么是库？" class="headerlink" title="一、什么是库？"></a>一、什么是库？</h3><p>库是共享程序代码的方式，一般分为静态库和动态库。<br><code>静态库：</code>链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。<br><code>动态库：</code>链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</p>
<h3 id="二、静态库和动态库的好处"><a href="#二、静态库和动态库的好处" class="headerlink" title="二、静态库和动态库的好处"></a>二、静态库和动态库的好处</h3><ul>
<li>使用静态库的好处：<br>1、模块化，分工合作<br>2、避免少量改动经常导致大量的重复编译连接<br>3、也可以重用，注意不是共享使用</li>
<li>动态库使用有如下好处：<br>1、使用动态库，可以将最终可执行文件体积缩小<br>2、使用动态库，多个应用程序共享内存中得同一份库文件，节省资源<br>3、使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。<br>从1可以得出，将整个应用程序分模块，团队合作，进行分工，影响比较小。<br>从2可以看出，其实动态库应该叫共享库，那么从这个意义上来说，苹果禁止iOS开发中使用动态库就可以理解了：<br>因为在现在的iPhone，iPodTouch，iPad上面程序都是单进程的，也就是某一时刻只有一个进程在运行，那么你写个共享库，<br>—-共享给谁？（你使用的时候只有你一个应用程序存在，其他的应该被挂起了，即便是可以同时多个进程运行，别人能使用你的共享库里的东西吗？你这个是给你自己的程序定制的。）<br>—-目前苹果的AppStore不支持模块更新，无法更新某个单独文件(除非自己写一个更新机制：有自己的服务端放置最新动态库文件)<br>至于苹果为啥禁止ios开发使用动态库我就猜到上面俩原因</li>
</ul>
<h3 id="三、iOS里静态库和动态库形式？"><a href="#三、iOS里静态库和动态库形式？" class="headerlink" title="三、iOS里静态库和动态库形式？"></a>三、iOS里静态库和动态库形式？</h3><p>静态库：.a和.framework<br>动态库：.dylib和.framework</p>
<h3 id="四、framework为什么既是静态库又是动态库？"><a href="#四、framework为什么既是静态库又是动态库？" class="headerlink" title="四、framework为什么既是静态库又是动态库？"></a>四、framework为什么既是静态库又是动态库？</h3><p>系统的.framework是动态库，我们自己建立的.framework是静态库。</p>
<h3 id="五、a与-framework有什么区别？"><a href="#五、a与-framework有什么区别？" class="headerlink" title="五、a与.framework有什么区别？"></a>五、a与.framework有什么区别？</h3><p>.a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。<br>.a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用。<br>.a + .h + sourceFile = .framework。<br>建议用.framework.</p>
<h3 id="六、为什么要使用静态库？"><a href="#六、为什么要使用静态库？" class="headerlink" title="六、为什么要使用静态库？"></a>六、为什么要使用静态库？</h3><p>国内的企业，掌握有核心技术，同时是又希望更多的程序员来使用其技术，因此采用”闭源”的方式开发使用。例如：百度地图，友盟，JPush等。在企业开发中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，也会提供静态库给程序员使用。方便共享代码，便于合理使用。实现iOS程序的模块化。可以把固定的业务模块化成静态库。和别人分享你的代码库，但不想让别人看到你代码的实现。开发第三方sdk的需要。</p>
<h3 id="七、静态库的种类"><a href="#七、静态库的种类" class="headerlink" title="七、静态库的种类"></a>七、静态库的种类</h3><ul>
<li><p>静态库文件的版本(4种)<br>1.真机-Debug版本<br>2.真机-Release版本<br>3.模拟器-Debug版本<br>4.模拟器-Release版本</p>
</li>
<li><p>调试版本(Debug版本) VS 发布版本(Release版本)<br>1.调试版本会包含完整的符号信息，以方便调试<br>2.调试版本不会对代码进行优化<br>3.发布版本不会包含完整的符号信息<br>4.发布版本的执行代码是进行过优化的<br>5.发布版本的大小会比调试版本的略小<br>5.在执行速度方面，调试版本会更快些，但不意味着会有显著的提升</p>
</li>
</ul>
<h3 id="八、制作静态库时的几点注意："><a href="#八、制作静态库时的几点注意：" class="headerlink" title="八、制作静态库时的几点注意："></a>八、制作静态库时的几点注意：</h3><p>1 注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。<br>2 图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。<br>3 category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。<br>4 如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。</p>
<h3 id="九、关于静态库的报错"><a href="#九、关于静态库的报错" class="headerlink" title="九、关于静态库的报错"></a>九、关于静态库的报错</h3><p>Undefined symbols for architecture i386:  i386可以理解为制作CPU的时候的CPU的种类</p>
<p>报上面的错表示:静态库不能在使用i386架构的cpu设备上面运行</p>
<p>i386 : iPhone模拟器 3gs-&gt;iPhone5<br>x86_64 : iPhone模拟器 5s-&gt;6plus</p>
<p>lipo -info 静态库:查看该静态库支持哪些架构</p>
<p>armv7 : iPhone 3gs-&gt;4s<br>armv7s : iPhone 5-&gt;5c<br>arm64 : iPhone 5s-&gt;6plus</p>
<h3 id="合并-a"><a href="#合并-a" class="headerlink" title="合并.a"></a>合并.a</h3><p>lipo -create Debug-iphoneos/libTools.a Debug-iphonesimulator/libTools.a -output libTools.a</p>
<ul>
<li>合并.a的好处，开发过程中既可以在真机上调试，也可以在模拟器上调试</li>
<li>合并.a的坏处，如果静态库太大，合并打包后，会非常大，因此很多第三方的静态库的.a是区分版本的</li>
<li>今后在使用.a时一定注意版本</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[运行时Runtime]]></title>
      <url>http://yoursite.com/2014/02/11/2014/Runtime/</url>
      <content type="html"><![CDATA[<h3 id="一、runtime简介"><a href="#一、runtime简介" class="headerlink" title="一、runtime简介"></a>一、runtime简介</h3><ul>
<li>RunTime简称运行时。OC就是<code>运行时机制</code>，也就是在运行时候的一些机制，其中最主要的是消息机制。</li>
<li>对于C语言，<code>函数的调用在编译的时候会决定调用哪个函数</code>。</li>
<li>对于OC的函数，属于<code>动态调用过程</code>，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>
<li>事实证明：</li>
<li>在编译阶段，OC可以<code>调用任何函数</code>，即使这个函数并未实现，只要声明过就不会报错。</li>
<li>在编译阶段，C语言调用<code>未实现的函数</code>就会报错。</li>
</ul>
<h3 id="二、runtime作用"><a href="#二、runtime作用" class="headerlink" title="二、runtime作用"></a>二、runtime作用</h3><h4 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1.发送消息"></a>1.发送消息</h4><ul>
<li>方法调用的本质，就是让对象发送消息。</li>
<li>objc_msgSend,只有对象才能发送消息，因此以objc开头.</li>
<li>使用<code>消息机制</code>前提，必须导入#import <objc message.h=""></objc></li>
<li>消息机制简单使用</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建person对象</span></div><div class="line">Person *p = [[Person alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 调用对象方法</span></div><div class="line">[p eat];</div><div class="line"></div><div class="line"><span class="comment">// 本质：让对象发送消息</span></div><div class="line">objc_msgSend(p, <span class="keyword">@selector</span>(eat));</div><div class="line"></div><div class="line"><span class="comment">// 调用类方法的方式：两种</span></div><div class="line"><span class="comment">// 第一种通过类名调用</span></div><div class="line">[Person eat];</div><div class="line"><span class="comment">// 第二种通过类对象调用</span></div><div class="line">[[Person <span class="keyword">class</span>] eat];</div><div class="line"></div><div class="line"><span class="comment">// 用类名调用类方法，底层会自动把类名转换成类对象调用</span></div><div class="line"><span class="comment">// 本质：让类对象发送消息</span></div><div class="line">objc_msgSend([Person <span class="keyword">class</span>], <span class="keyword">@selector</span>(eat));</div></pre></td></tr></table></figure>
<ul>
<li>消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现</li>
<li><img src="Snip20151013_4.png" alt=""></li>
</ul>
<h4 id="2-交换方法"><a href="#2-交换方法" class="headerlink" title="2.交换方法"></a>2.交换方法</h4><ul>
<li>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。</li>
<li>方式一:继承系统的类，重写方法.</li>
<li>方式二:使用runtime,交换方法.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。</span></div><div class="line">    <span class="comment">// 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;</span></div><div class="line">    <span class="comment">// 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"123"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">Image</span>)</span></div><div class="line"><span class="comment">// 加载分类到内存的时候调用</span></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 交换方法</span></div><div class="line">    <span class="comment">// 获取imageWithName方法地址</span></div><div class="line">    Method imageWithName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageWithName:));</div><div class="line"></div><div class="line">    <span class="comment">// 获取imageWithName方法地址</span></div><div class="line">    Method imageName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageNamed:));</div><div class="line"></div><div class="line">    <span class="comment">// 交换方法地址，相当于交换实现方式</span></div><div class="line">    method_exchangeImplementations(imageWithName, imageName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</span></div><div class="line"></div><div class="line"><span class="comment">// 既能加载图片又能打印</span></div><div class="line">+ (<span class="keyword">instancetype</span>)imageWithName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 这里调用imageWithName，相当于调用imageName</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageWithName:name];</div><div class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"加载空的图片"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>交换原理：</li>
<li><p>交换之前：<br><img src="Snip20151013_2.png" alt=""></p>
</li>
<li><p>交换之后：<br><img src="Snip20151013_3.png" alt=""></p>
</li>
</ul>
<h4 id="3-动态添加方法"><a href="#3-动态添加方法" class="headerlink" title="3.动态添加方法"></a>3.动态添加方法</h4><ul>
<li>开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。</li>
<li>经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。</li>
<li>简单使用</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    Person *p = [[Person alloc] init];</div><div class="line">    <span class="comment">// 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span></div><div class="line">    <span class="comment">// 动态添加方法就不会报错</span></div><div class="line">    [p performSelector:<span class="keyword">@selector</span>(eat)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"><span class="comment">// void(*)()</span></div><div class="line"><span class="comment">// 默认方法都有两个隐式参数，</span></div><div class="line"><span class="keyword">void</span> eat(<span class="keyword">id</span> <span class="keyword">self</span>,SEL sel)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,<span class="keyword">self</span>,<span class="built_in">NSStringFromSelector</span>(sel));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></div><div class="line"><span class="comment">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(eat)) &#123;</div><div class="line">        <span class="comment">// 动态添加eat方法</span></div><div class="line">        <span class="comment">// 第一个参数：给哪个类添加方法</span></div><div class="line">        <span class="comment">// 第二个参数：添加方法的方法编号</span></div><div class="line">        <span class="comment">// 第三个参数：添加方法的函数实现（函数地址）</span></div><div class="line">        <span class="comment">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></div><div class="line">        class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(eat), eat, <span class="string">"v@:"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="4-给分类添加属性"><a href="#4-给分类添加属性" class="headerlink" title="4.给分类添加属性"></a>4.给分类添加属性</h4><ul>
<li>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 给系统NSObject类动态添加属性name</span></div><div class="line">    <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    objc.name = <span class="string">@"小码哥"</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,objc.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 定义关联的key</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"name"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Property</span>)</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 根据关联的key，获取关联的值。</span></div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 第一个参数：给哪个对象添加关联</span></div><div class="line">    <span class="comment">// 第二个参数：关联的key，通过这个key获取</span></div><div class="line">    <span class="comment">// 第三个参数：关联的value</span></div><div class="line">    <span class="comment">// 第四个参数:关联的策略</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="5-字典转模型"><a href="#5-字典转模型" class="headerlink" title="5.字典转模型"></a>5.字典转模型</h4><ul>
<li>设计模型：字典转模型的第一步</li>
<li>模型属性，通常需要跟字典中的key一一对应</li>
<li>问题：一个一个的生成模型属性，很慢？</li>
<li>需求：能不能自动根据一个字典，生成对应的属性。</li>
<li>解决：提供一个分类，专门根据字典生成对应的属性字符串。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Log</span>)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 自动打印属性字符串</span></div><div class="line">+ (<span class="keyword">void</span>)resolveDict:(<span class="built_in">NSDictionary</span> *)dict&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 拼接属性字符串代码</span></div><div class="line">    <span class="built_in">NSMutableString</span> *strM = [<span class="built_in">NSMutableString</span> string];</div><div class="line"></div><div class="line">    <span class="comment">// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</span></div><div class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 类型经常变，抽出来</span></div><div class="line">    <span class="built_in">NSString</span> *type;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFString"</span>)]) &#123;</div><div class="line">        type = <span class="string">@"NSString"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFArray"</span>)])&#123;</div><div class="line">        type = <span class="string">@"NSArray"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFNumber"</span>)])&#123;</div><div class="line">        type = <span class="string">@"int"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFDictionary"</span>)])&#123;</div><div class="line">        type = <span class="string">@"NSDictionary"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 属性字符串</span></div><div class="line">    <span class="built_in">NSString</span> *str;</div><div class="line">    <span class="keyword">if</span> ([type containsString:<span class="string">@"NS"</span>]) &#123;</div><div class="line">    str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, strong) %@ *%@;"</span>,type,key];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">    str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, assign) %@ %@;"</span>,type,key];</div><div class="line">&#125;</div><div class="line">    <span class="comment">// 每生成属性字符串，就自动换行。</span></div><div class="line">    [strM appendFormat:<span class="string">@"\n%@\n"</span>,str];</div><div class="line"></div><div class="line">    &#125;];</div><div class="line">    <span class="comment">// 把拼接好的字符串打印出来，就好了。</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strM);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>字典转模型的方式一：KVC</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Status</span></span></div><div class="line"></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)statusWithDict:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    Status *status = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    [status setValuesForKeysWithDictionary:dict];</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。</li>
<li>如果不一致，就会调用<code>[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]</code><br>报<code>key</code>找不到的错。    </li>
<li>分析:模型中的属性和字典的key不一一对应，系统就会调用<code>setValue:forUndefinedKey:</code>报错。</li>
<li>解决:重写对象的<code>setValue:forUndefinedKey:</code>,把系统的方法覆盖，<br>就能继续使用KVC，字典转模型了。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>字典转模型的方式二：Runtime</li>
<li>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。</li>
<li>步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 解析Plist文件</span></div><div class="line">    <span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"status.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSDictionary</span> *statusDict = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:filePath];</div><div class="line">    <span class="comment">// 获取字典数组</span></div><div class="line">    <span class="built_in">NSArray</span> *dictArr = statusDict[<span class="string">@"statuses"</span>];</div><div class="line">    <span class="comment">// 自动生成模型的属性字符串</span></div><div class="line">    <span class="comment">// [NSObject resolveDict:dictArr[0][@"user"]];</span></div><div class="line">    _statuses = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">    <span class="comment">// 遍历字典数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> dictArr) &#123;</div><div class="line">        Status *status = [Status modelWithDict:dict];</div><div class="line">        [_statuses addObject:status];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 测试数据</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,_statuses,[_statuses[<span class="number">0</span>] user]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Model</span>)</span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 思路：遍历模型中所有属性-》使用运行时</span></div><div class="line"></div><div class="line">    <span class="comment">// 0.创建对应的对象</span></div><div class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 1.利用runtime给对象中的成员属性赋值</span></div><div class="line"></div><div class="line">    <span class="comment">// class_copyIvarList:获取类中的所有成员属性</span></div><div class="line">    <span class="comment">// Ivar：成员属性的意思</span></div><div class="line">    <span class="comment">// 第一个参数：表示获取哪个类中的成员属性</span></div><div class="line">    <span class="comment">// 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</span></div><div class="line">    <span class="comment">// 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</span></div><div class="line">    <span class="comment">/* 类似下面这种写法</span></div><div class="line"></div><div class="line">    Ivar ivar;</div><div class="line">    Ivar ivar1;</div><div class="line">    Ivar ivar2;</div><div class="line">    // 定义一个ivar的数组a</div><div class="line">    Ivar a[] = &#123;ivar,ivar1,ivar2&#125;;</div><div class="line"></div><div class="line">    // 用一个Ivar *指针指向数组第一个元素</div><div class="line">    Ivar *ivarList = a;</div><div class="line"></div><div class="line">    // 根据指针访问数组第一个元素</div><div class="line">    ivarList[0];</div><div class="line"></div><div class="line">    */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="comment">// 获取类中的所有成员属性</span></div><div class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 根据角标，从数组取出对应的成员属性</span></div><div class="line">                Ivar ivar = ivarList[i];</div><div class="line"></div><div class="line">                <span class="comment">// 获取成员属性名</span></div><div class="line">                <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">                <span class="comment">// 处理成员属性名-&gt;字典中的key</span></div><div class="line">                <span class="comment">// 从第一个角标开始截取</span></div><div class="line">                <span class="built_in">NSString</span> *key = [name substringFromIndex:<span class="number">1</span>];</div><div class="line"></div><div class="line">                <span class="comment">// 根据成员属性名去字典中查找对应的value</span></div><div class="line">                <span class="keyword">id</span> value = dict[key];</div><div class="line"></div><div class="line">                <span class="comment">// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span></div><div class="line">                <span class="comment">// 判断下value是否是字典</span></div><div class="line">                <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                    <span class="comment">// 字典转模型</span></div><div class="line">                    <span class="comment">// 获取模型的类对象，调用modelWithDict</span></div><div class="line">                    <span class="comment">// 模型的类名已知，就是成员属性的类型</span></div><div class="line"></div><div class="line">                    <span class="comment">// 获取成员属性类型</span></div><div class="line">                    <span class="built_in">NSString</span> *type = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class="line">                    <span class="comment">// 生成的是这种@"@\"User\"" 类型 -》 @"User"  在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符</span></div><div class="line">                    <span class="comment">// 裁剪类型字符串</span></div><div class="line">                    <span class="built_in">NSRange</span> range = [type rangeOfString:<span class="string">@"\""</span>];</div><div class="line"></div><div class="line">                    type = [type substringFromIndex:range.location + range.length];</div><div class="line"></div><div class="line">                    range = [type rangeOfString:<span class="string">@"\""</span>];</div><div class="line"></div><div class="line">                    <span class="comment">// 裁剪到哪个角标，不包括当前角标</span></div><div class="line">                    type = [type substringToIndex:range.location];</div><div class="line"></div><div class="line">                    <span class="comment">// 根据字符串类名生成类对象</span></div><div class="line">                    Class modelClass = <span class="built_in">NSClassFromString</span>(type);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (modelClass) &#123; <span class="comment">// 有对应的模型才需要转</span></div><div class="line">                        <span class="comment">// 把字典转模型</span></div><div class="line">                        value  =  [modelClass modelWithDict:value];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span></div><div class="line">        <span class="comment">// 判断值是否是数组</span></div><div class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="comment">// 判断对应类有没有实现字典数组转模型数组的协议</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(arrayContainModelClass)]) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 转换成id类型，就能调用任何对象的方法</span></div><div class="line">                <span class="keyword">id</span> idSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 获取数组中字典对应的模型</span></div><div class="line">                <span class="built_in">NSString</span> *type =  [idSelf arrayContainModelClass][key];</div><div class="line"></div><div class="line">                <span class="comment">// 生成模型</span></div><div class="line">                Class classModel = <span class="built_in">NSClassFromString</span>(type);</div><div class="line">                <span class="built_in">NSMutableArray</span> *arrM = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">                <span class="comment">// 遍历字典数组，生成模型数组</span></div><div class="line">                <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> value) &#123;</div><div class="line">                    <span class="comment">// 字典转模型</span></div><div class="line">                    <span class="keyword">id</span> model =  [classModel modelWithDict:dict];</div><div class="line">                    [arrM addObject:model];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 把模型数组赋值给value</span></div><div class="line">                value = arrM;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (value) &#123; <span class="comment">// 有值，才需要给模型的属性赋值</span></div><div class="line">            <span class="comment">// 利用KVC给模型中的属性赋值</span></div><div class="line">            [objc setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> objc;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开发的知名大牛博客]]></title>
      <url>http://yoursite.com/2014/02/10/2014/IOS%E5%BC%80%E5%8F%91%E7%9A%84%E7%9F%A5%E5%90%8D%E5%A4%A7%E7%89%9B%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>王巍的博客：王巍目前在日本横滨任职于LINE。工作内容主要进行Unity3D开发，8小时之外经常进行iOS/Mac开发。他的陈列柜中已有多款应用，其中番茄工作法工具非常棒。<br>(<a href="http://onevcat.com" target="_blank" rel="external">http://onevcat.com</a>)<br>池建强的博客： 池建强，70后程序员，Blogger。98年毕业，先后就职于洪恩软件、RocketSofeware和用友软件工程公司（后更名为瑞友科技），现任瑞友科技IT应用研究院副院长。该博客最初每天发送一条Mac技巧，不过目前已经形成了一种技术和人文结合的风格，时而随笔，时而技术。<br>(<a href="http://macshuo.com/" target="_blank" rel="external">http://macshuo.com/</a>)<br>唐巧的博客： 唐巧是前网易有道员工，现在在粉笔网创业中，负责iOS端的开发。博客中的每篇文章都堪称精华，近期分析了支付宝客户端的插件机制，值得细细品读。<br>(<a href="http://blog.devtang.com/" target="_blank" rel="external">http://blog.devtang.com/</a>)<br>许小帅的博客：许小帅目前任职于腾讯，他还是iOS Feed站点的负责人。博客中对支付宝钱包插件分析的文章，引起了支付宝开发团队的反思，大家可以去感受一下。<br>(<a href="http://imallen.com/" target="_blank" rel="external">http://imallen.com/</a>)<br>蓝晨钰的博客：晨钰目前就读于中山大学。是一名90后iOS开发者。<br>(<a href="http://gracelancy.com/" target="_blank" rel="external">http://gracelancy.com/</a>)<br>萧宸宇的博客：萧宸宇目前任职于Sumi Interactive。他出生于西南一个边陲小镇，梦想着能走出家乡，看看祖国的大好河山。他拥有丰富的 iOS 开发经验，在他的博客中发表了许多 iOS 开发的文章。<br>(<a href="http://iiiyu.com/" target="_blank" rel="external">http://iiiyu.com/</a>)<br>陶丰平的博客：陶丰平目前任职于花瓣网，喜欢技术，喜欢音乐。他在软件开发领域有丰富的开发经验。<br>(<a href="http://www.taofengping.com/" target="_blank" rel="external">http://www.taofengping.com/</a>)<br>乔学士的博客：乔学士目前任职于创业公司拓词，他正在为成为“代码手工艺人”而努力，目前主要进行 iOS 开发。最近他做得非常精彩的一件事就是汇总了WWDC 2013 视频英文字幕下载，大家可以前往他的博客感受一下。<br>(<a href="http://joeyio.com/" target="_blank" rel="external">http://joeyio.com/</a>)<br>破船的博客：破船在移动领域摸爬滚打多年，经历了Symbian、Windows Mobile、Windows Phone和 iOS 等的洗礼。他希望能充分利用业余时间，努力做一名伪步道师。<br>(<a href="http://beyondvincent.com/" target="_blank" rel="external">http://beyondvincent.com/</a>)<br>陈咏聪的博客：陈咏聪现任职于百度，从事 iOS 相关开发。他热爱Web事业，关注设计、产品、开发。沉迷代码，无法自拔。<br>(<a href="http://vinqon.com/" target="_blank" rel="external">http://vinqon.com/</a>)<br>骆仕恺的博客：骆仕恺目前任职于爱折客 / 爱美味。他主要从事 iOS 和Java开发。拥有丰富的 iOS 开发经验。<br>(<a href="http://luosky.com/" target="_blank" rel="external">http://luosky.com/</a>)<br>耿健桓的博客：耿健桓目前在清华大学攻读硕士，之前他是著名站点知乎的 iOS 技术主管。<br>(<a href="http://dlog.dismory.com/" target="_blank" rel="external">http://dlog.dismory.com/</a>)<br>李择一的博客：李择一目前任职于百度，他在移动开发领域积累了丰富的经验，特别是 iOS 开发。最近他在博客中发表关于OC中block的追究非常有深度，大家一定要去感受一下。<br>(<a href="http://cnblogs.com/biosli" target="_blank" rel="external">http://cnblogs.com/biosli</a>)<br>王轲的博客：王轲是一名 iOS 独立开发者，也是IndieBros Studio创始人。在博客中有几篇关于 iOS 性能优化的文章，值得大家去看看。<br>(<a href="http://www.iwangke.me/" target="_blank" rel="external">http://www.iwangke.me/</a>)<br>杨宇建的博客： 杨宇建目前任职于载信软件。在他的博客中有许多 iOS 开发的文章，都是干货。<br>(<a href="http://www.cnblogs.com/easonoutlook/" target="_blank" rel="external">http://www.cnblogs.com/easonoutlook/</a>)<br>连栩的博客： 连栩目前工作在加拿大温哥华，运营着自己的公司 Beyondcow，他是一名 OSX、iOS 程序员同时也是用户体验，交互界面设计师。在开发的软件 Miao 是一款全功能 Mac 微博客户端。他的博客中有许多Cocoa开发的文章，值得大家去品读。<br>(<a href="http://lianxu.me/" target="_blank" rel="external">http://lianxu.me/</a>)<br>高嘉峻的博客：高嘉峻目前任职于天猫。是一名资深80后，号称会写代码的猪。最近他的博客中出现了两篇关于iOS中单元测试的文章，非常棒。<br>(<a href="http://jiajun.org/" target="_blank" rel="external">http://jiajun.org/</a>)<br>webfrogs的博客：目前在北京当一枚程序猿，有幸成为80后的尾巴。目前行走在iOS开发的道路上，用博客记载一路上的所见所闻所想。<br>(<a href="http://webfrogs.me/" target="_blank" rel="external">http://webfrogs.me/</a>)<br>sunny的博客：目前任职北京百度，对runtime有深刻讲解，值得大家学习<br>(<a href="http://blog.sunnyxx.com" target="_blank" rel="external">http://blog.sunnyxx.com</a>)<br>景总的博客：目前任职于天猫国际移动开发CTO，曾就职于平安科技项目经理，对IM和APP性能优化有深刻见解<br>(<a href="http://blog.csdn.net/justinjing0612" target="_blank" rel="external">http://blog.csdn.net/justinjing0612</a>)<br>谭灏的博客：目前就职于腾讯mac管家部门，他是一名 OSX、iOS 程序员，他的博客中有许多mac，ios开发的文章，值得大家去品读<br>(<a href="http://tanhao.me/" target="_blank" rel="external">http://tanhao.me/</a>)<br>田伟宇的博客：目前任职于天猫，全能人才。最近他的博客中出现了篇关于iOS应用架构详谈的文章，非常棒。<br>(<a href="http://casatwy.com" target="_blank" rel="external">http://casatwy.com</a>)<br>念茜的博客：目前就职阿里旗下蚂蚁金服，ios界女神，Qt、Android高级开发工程师,eoe优亿认证开发者，ios反编译大师，著作ios安全攻防<br>(<a href="http://nianxi.net" target="_blank" rel="external">http://nianxi.net</a>)</p>
]]></content>
    </entry>
    
  
  
</search>
