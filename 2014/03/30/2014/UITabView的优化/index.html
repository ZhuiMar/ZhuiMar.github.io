<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><title>UITableView优化 - zhuimar</title><meta name="description" content="为了做到显示和数据分离， 通过重用单元格来达到节省内存的目的..."><link type="text/css" rel="stylesheet" href="/css/pure.css?v=0.0.1"><link type="text/css" rel="stylesheet" href="/css/style.css?v=0.0.1"><script type="text/javascript" src="//cdn.bootcss.com/jquery/1.11.0/jquery.min.js"></script></head></html><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">UITableView优化</h1><a id="logo" href="/.">zhuimar</a></div><div id="nav-menu"><div class="bitcron_nav"><div class="site_nav_wrap"><div class="site_nav"><span class="a_container"><a href="/." class="selected active current">首页</a></span><span class="a_container"><a href="/archives/">归档</a></span><span class="a_container"><a href="/about/">关于</a></span><span class="a_container"><a href="/atom.xml">订阅</a></span></div></div></div></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">UITableView优化</h1><div class="post-meta">2014-03-30<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" type="text/javascript"></script><span class="meta-space">  |  </span><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span><span> 浏览</span></span></div><!--文章内容--><div class="post-content"><h2 id="IOS之UITableView优化-可重用机制"><a href="#IOS之UITableView优化-可重用机制" class="headerlink" title="IOS之UITableView优化-可重用机制"></a>IOS之UITableView优化-可重用机制</h2><p>目的：为了做到显示和数据分离， 通过重用单元格来达到节省内存的目的</p>
<h4 id="1-使用可重用机制创建cell（系统）"><a href="#1-使用可重用机制创建cell（系统）" class="headerlink" title="1.使用可重用机制创建cell（系统）"></a>1.使用可重用机制创建cell（系统）</h4><p>（1）定义可重用标识<br>（2）从可重用队列中取出cell<br>（3）若队列中无可用cell，利用alloc，init新建cell</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *reuseIndentifier = <span class="string">@"MyCell"</span>;  </div><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:reuseIndentifier];  </div><div class="line"><span class="keyword">if</span> (!cell) &#123;  </div><div class="line">    cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:reuseIndentifier];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h4><p>在UITableView的头文件中有visibleCells，存放当前显示的的cells<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>)<span class="built_in">NSArray</span>&lt;__kindofUITableViewCell *&gt; *visibleCells;</div></pre></td></tr></table></figure></p>
<p>当需要更新显示数据时，dequeueReusableCellWithIdentifier会先在可重用cell队列 reusable-cell queue中返回一个cell对象，若不存在，则返回nil；</p>
<h4 id="3-举例"><a href="#3-举例" class="headerlink" title="3.举例"></a>3.举例</h4><p>若一共有50条数据，屏幕最多显示10个cell。</p>
<p>(1）由于初始时 reusable-cell queue为空，所以用 [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 创建10次cell，并给cell指定同样的重用标识，并且10个cell全部都加入到 visiableCells数组。<br>(2）向下拖动tableView，当cell1完全移出屏 幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。 cell11加入到visiableCells，cell1移出visiableCells，cell1加入到 reusable-cell queue。<br>(3). 接着向下拖动tableView，因为 reusable-cell queue中已经有可用cell对象，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用的时候，tableView dequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。 cell1加入到visiableCells，cell1移出 reusable-cell queue；cell2移出 visiableCells，cell2加入到 reusable-cell queue。</p>
<h4 id="4-存在的问题"><a href="#4-存在的问题" class="headerlink" title="4.存在的问题"></a>4.存在的问题</h4><p>重取出来的cell是有可能已经捆绑过数据或者加过子视图的，造成视图叠加混乱的现象<br>解决：<br>(1）删除已有数据或子视图<br>(2）放弃了重用机制，每次根据indexPath获取对应的cell返回。<br>将方法:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:reuseIndentifier];</div></pre></td></tr></table></figure></p>
<p>替换为:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView cellForRowAtIndexPath:indexPath];</div></pre></td></tr></table></figure></p>
<h4 id="5-自定义cell的可重用机制使用"><a href="#5-自定义cell的可重用机制使用" class="headerlink" title="5.自定义cell的可重用机制使用"></a>5.自定义cell的可重用机制使用</h4><p>(1）在nib中加载MyCell这个类<br>(2）注册自定义的cell 的可重用标识<br>[objc] view plain copy 在CODE上查看代码片派生到我的代码片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"MyCell"</span> bundle:<span class="literal">nil</span>];   </div><div class="line">[tableView registerNib:nib forCellReuseIdentifier:reuseIdentity];</div></pre></td></tr></table></figure></p>
<p>用标识，并加入缓存池<br>(3)同上系统cell的使用</p>
<h2 id="IOS的tabViewCell的卡顿的解决方案"><a href="#IOS的tabViewCell的卡顿的解决方案" class="headerlink" title="IOS的tabViewCell的卡顿的解决方案"></a>IOS的tabViewCell的卡顿的解决方案</h2><ul>
<li>当你下滑时候是否发现有那么一点点的卡顿现成，特别是网络不好。可以利用UIScrollViewDelegate代理很好的解决这问题<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate</div><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以识别tableview禁止或者减速滑动结束的时候进行异步加载图片</p>
<ul>
<li>tabViewCell上面的图片透明度和圆角问题也会造成卡顿的情况</li>
<li>​使用不透明视图：没有其他渲染效果，可以提高页面渲染速度;</li>
<li>不要重复创建不必要的cell：​当新cell需要被显示时，就会调用tableView:cellForRowAtIndexPath:方法获取或创建一个cell；而不可视时，它又会被释放。由此可见，同一时间只需要存在一屏幕的cell即可，不需要为每一行创建一个cell;</li>
<li>​使用自定义的cell：默认的UITableViewCell包含了textLabel、detailTextLabel和imageView等view，然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。但是使用自定义的view，而非预定义的会明显快一些;</li>
<li>不要阻塞主线程：显然，主线程就只加载视图，把网络请求等耗时函数放到子线程;</li>
<li>​自动载入更新数据：例如每次载入50条信息，那就可以在滚动到倒数第10条以内时，加载更多信息;</li>
<li>不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的opaque属性设为YES（默认值）;</li>
<li>其中的特例包括背景色，它的alpha值应该为1（例如不要使用clearColor）；图像的alpha值也应该为1，或者在画图时设为不透明;</li>
<li>值得一提的是，cell被重用时，它内部绘制的内容并不会被自动清除，因此你可能需要调用setNeedsDisplayInRect:或setNeedsDisplay方法。<br>此外，在添加table cell的时候，如果不需要动画效果，最好不要使用insertRowsAtIndexPaths:withRowAnimation:方法，而是直接调用reloadData方法。因为前者会对所有indexPaths调用tableView:cellForRowAtIndexPath:方法，即便该 cell并不需要显示（不知道是不是bug），这就可能创建大量多余的cell。勘误：只是在模拟器上测试如此，真机调试时没有这种bug。</li>
<li>UITableViewCell包含了textLabel、detailTextLabel和imageView等view，而你还可以自定义一些视图放在它的contentView里。然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。<br>如果你的table cell包含图片，且数目较多，使用默认的UITableViewCell会非常影响性能。奇怪的是，使用自定义的view，而非预定义的view，明显会快些。当然，最佳的解决办法还是继承UITableViewCell，并在其drawRect:中自行绘制：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect </div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span>(image) &#123; </div><div class="line">        [image drawAtPoint:imagePoint]; </div><div class="line">        <span class="keyword">self</span>.image = <span class="literal">nil</span>; </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [placeHolder drawAtPoint:imagePoint]; </div><div class="line">    &#125; </div><div class="line">    [text drawInRect:textRect withFont:fontlineBreakMode:<span class="built_in">UILineBreakModeTailTruncation</span>]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>不过这样一来，你会发现选中一行后，这个cell就变蓝了，其中的内容就被挡住了。最简单的方法就是将cell的selectionStyle属性设为UITableViewCellSelectionStyleNone，这样就不会被高亮了。<br>此外还可以创建CALayer，将内容绘制到layer上，然后对cell的contentView.layer调用addSublayer:方法。这个例子中，layer并不会显著影响性能，但如果layer透明，或者有圆角、变形等效果，就会影响到绘制速度了。解决办法可参见后面的预渲染图像。</p>
</li>
<li><p>不要做多余的绘制工作<br>在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。<br>例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。</p>
</li>
<li><p>预渲染图像。<br>你会发现即使做到了上述几点，当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕，详细做法可见。<br><a href="http://www.keakon.net/2011/07/26/利用预渲染加速iOS设备的图像显示" target="_blank" rel="external">《利用预渲染加速iOS设备的图像显示》</a></p>
</li>
<li><p>不要阻塞主线程<br>做到前几点后，你的table view滚动时应该足够流畅了，不过你仍可能让用户感到不爽。常见的现象就是在更新数据时，整个界面卡住不动，完全不响应用户请求。<br>出现这种现象的原因就是主线程执行了耗时很长的函数或方法，在其执行完毕前，无法绘制屏幕和响应用户请求。其中最常见的就是网络请求了，它通常都需要花费数秒的时间，而你不应该让用户等待那么久。<br>解决办法就是使用多线程，让子线程去执行这些函数或方法。这里面还有一个学问，当下载线程数超过2时，会显著影响主线程的性能。因此在使用ASIHTTPRequest时，可以用一个NSOperationQueue来维护下载请求，并将其maxConcurrentOperationCount设为2。而NSURLRequest则可以配合GCD来实现，或者使用NSURLConnection的setDelegateQueue:方法。<br>当然，在不需要响应用户请求时，也可以增加下载线程数，以加快下载速度：</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span>*)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate &#123; <span class="keyword">if</span> (!decelerate) &#123;queue.maxConcurrentOperationCount = <span class="number">5</span>; &#125; &#125; -(<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView &#123;queue.maxConcurrentOperationCount = <span class="number">5</span>; &#125; -(<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;queue.maxConcurrentOperationCount = <span class="number">2</span>; &#125;</div></pre></td></tr></table></figure>
<p>此外，自动载入更新数据对用户来说也很友好，这减少了用户等待下载的时间。例如每次载入50条信息，那就可以在滚动到倒数第10条以内时，加载更多信息：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span>*)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cellforRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath </div><div class="line">&#123; </div><div class="line">    <span class="comment">// update方法获取到结果后，设置updating为NO</span></div><div class="line">    <span class="keyword">if</span> (count - indexPath.row &lt; <span class="number">10</span>&amp;&amp; !updating) &#123; </div><div class="line">        updating = <span class="literal">YES</span>; [<span class="keyword">self</span> update]; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一点要注意的就是当图片下载完成后，如果cell是可见的，还需要更新图像：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *indexPaths = [<span class="keyword">self</span>.tableViewindexPathsForVisibleRows];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSIndexPath</span> *visibleIndexPath <span class="keyword">in</span> indexPaths) &#123;</div><div class="line">    <span class="comment">// 也可不遍历，直接与头尾相比较，看是否在中间即可。</span></div><div class="line">    <span class="keyword">if</span> (indexPath == visibleIndexPath) &#123;</div><div class="line">        MyTableViewCell *cell = (MyTableViewCell*)[<span class="keyword">self</span>.tableView cellForRowAtIndexPath:indexPath]; </div><div class="line">        cell.image = image;</div><div class="line">        [cellsetNeedsDisplayInRect:imageRect]; </div><div class="line">        <span class="keyword">break</span>; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后还是前面所说过的insertRowsAtIndexPaths:withRowAnimation:方法，插入新行需要在主线程执行，而一次插入很多行的话（例如50行），会长时间阻塞主线程。而换成reloadData方法的话，瞬间就处理完了。</p>
<ul>
<li>如果只是更新某组的话，使用reloadSection进行局部更新</li>
</ul>
</div><!--文章标签--><div class="tags"></div><!--评论--><div id="disqus_thread"><script>var disqus_shortname = 'zhuimar';
var disqus_identifier = '2014/03/30/2014/UITabView的优化/';
var disqus_title = 'UITableView优化';
var disqus_url = 'http://yoursite.com/2014/03/30/2014/UITabView的优化/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><!--script(id='dsq-count-scr', src='//#{theme.disqus}.disqus.com/count.js', async)--></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" id="search" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"> 分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">19</span></li></ul></div><div class="widget"><div class="widget-title"> 标签</div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"> 最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/2014/音乐锁屏键的处理/">音乐锁屏键的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/31/2014/苹果的内存管理/">苹果的内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/17/2014/网络库AFNetworking详解/">网络库AFNetworking</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/30/2014/图片缓存的优化/">图片缓存的优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/09/13/2014/储存方案/">常见的储存方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/25/2014/iOS精度丢失的处理/">iOS精度丢失的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/08/03/2014/Copy,Strong修饰字符串的区别/">Copy&Strong修饰字符串的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/06/01/2014/UIViewController的生命周期/">UIViewController的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/05/21/2014/iOS常用的三种枚举/">常用的三种种枚举</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/05/20/2014/const-static-extern简介/">关键字const、static、extern</a></li></ul></div><div class="widget"><div class="widget-title"> 友情链接</div><ul class="links-list"><li class="links-list-item"><a href="http://blog.csdn.net/leixiaohua1020" title="雷霄骅" target="_blank">雷霄骅</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="http://blog.devtang.com/" title="唐巧" target="_blank">唐巧</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="http://casatwy.com" title="田伟宇" target="_blank">田伟宇</a></li></ul></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">zhuimar.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> Theme<a target="_blank" href="https://github.com/7ye/maupassant-hexo"> Maupassant.</a></div><a id="back_to_top" href="javascript:void(0)" class="back_to_top"><span>△</span></a><script type="text/javascript" src="/js/totop.js?v=0.0.1"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>function auto_code_fit(){
  if($(".highlight").length != 0){
    var pc_width = $(".post-content").width();
    $(".highlight .code").find("pre").width((pc_width-70)+"px");
  }
}
window.onresize = function(){
  auto_code_fit();
}
auto_code_fit();</script></div></body>