<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[组透明]]></title>
      <url>http://yoursite.com/2014/12/08/2014/%E7%BB%84%E9%80%8F%E6%98%8E/</url>
      <content type="html"><![CDATA[<p>UIView有一个叫做alpha的属性来确定视图的透明度。CALayer有一个等同的属性叫做opacity，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了opacity属性，那它的子图层都会受此影响。</p>
<p> iOS常见的做法是把一个控件的alpha值设置为0.5（50%）以使其看上去呈现为不可用状态。对于独立的视图来说还不错，但是当一个控件有子视图的时候就有点奇怪了，图4.20展示了一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</p>
<p>这是由透明度的混合叠加造成的，当你显示一个50%透明度的图层时，图层的每个像素都会一半显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。</p>
<p>在我们的示例中，按钮和表情都是白色背景。虽然他们都是50%的可见度，但是合起来的可见度是75%，所以标签所在的区域看上去就没有周围的部分那么透明。所以看上去子视图就高亮了，使得这个显示效果都糟透了。</p>
<p>理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置Info.plist文件中的UIViewGroupOpacity为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果UIViewGroupOpacity并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变）。</p>
<p>另一个方法就是，你可以设置CALayer的一个叫做shouldRasterize属性来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了。</p>
<p>为了启用shouldRasterize属性，我们设置了图层的rasterizationScale属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了shouldRasterize属性，你就要确保你设置了rasterizationScale属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。</p>
<p>当shouldRasterize和UIViewGroupOpacity一起的时候，性能问题就出现了,但是性能碰撞都本地化了。使用shouldRasterize属性解决组透明问题。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="built_in">UIButton</span> *)customButton&#123;</div><div class="line">    <span class="comment">//create button</span></div><div class="line">    <span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">50</span>);</div><div class="line">    <span class="built_in">UIButton</span> *button = [[<span class="built_in">UIButton</span> alloc] initWithFrame:frame];</div><div class="line">    button.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    button.layer.cornerRadius = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="comment">//add label</span></div><div class="line">    frame = <span class="built_in">CGRectMake</span>(<span class="number">20</span>, <span class="number">10</span>, <span class="number">110</span>, <span class="number">30</span>);</div><div class="line">    <span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] initWithFrame:frame];</div><div class="line">    label.text = <span class="string">@"Hello World"</span>;</div><div class="line">    label.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</div><div class="line">    [button addSubview:label];</div><div class="line">    <span class="keyword">return</span> button;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    <span class="comment">//create opaque button</span></div><div class="line">    <span class="built_in">UIButton</span> *button1 = [<span class="keyword">self</span> customButton];</div><div class="line">    button1.center = <span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">150</span>);</div><div class="line">    [<span class="keyword">self</span>.containerView addSubview:button1];</div><div class="line"></div><div class="line">    <span class="comment">//create translucent button</span></div><div class="line">    <span class="built_in">UIButton</span> *button2 = [<span class="keyword">self</span> customButton];</div><div class="line">    ￼</div><div class="line">    button2.center = <span class="built_in">CGPointMake</span>(<span class="number">250</span>, <span class="number">150</span>);</div><div class="line">    button2.alpha = <span class="number">0.5</span>;</div><div class="line">    [<span class="keyword">self</span>.containerView addSubview:button2];</div><div class="line"></div><div class="line">    <span class="comment">//enable rasterization for the translucent button</span></div><div class="line">    button2.layer.shouldRasterize = <span class="literal">YES</span>;</div><div class="line">    button2.layer.rasterizationScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[专用图层 - CATransformLayer]]></title>
      <url>http://yoursite.com/2014/12/07/2014/%E4%B8%93%E7%94%A8%E5%9B%BE%E5%B1%82%20-%20CATransformLayer/</url>
      <content type="html"><![CDATA[<p>当我们在构造复杂的3D事物的时候，如果能够组织独立元素就太方便了。比如说，你想创造一个孩子的手臂：你就需要确定哪一部分是孩子的手腕，哪一部分是孩子的前臂，哪一部分是孩子的肘，哪一部分是孩子的上臂，哪一部分是孩子的肩膀等等。</p>
<p>当然是允许独立地移动每个区域的啦。以肘为指点会移动前臂和手，而不是肩膀。Core Animation图层很容易就可以让你在2D环境下做出这样的层级体系下的变换，但是3D情况下就不太可能，因为所有的图层都把他的孩子都平面化到一个场景中。</p>
<p>CATransformLayer解决了这个问题，CATransformLayer不同于普通的CALayer，因为它不能显示它自己的内容。只有当存在了一个能作用域子图层的变换它才真正存在。CATransformLayer并不平面化它的子图层，所以它能够用于构造一个层级的3D结构，比如我的手臂示例。</p>
<p>用代码创建一个手臂需要相当多的代码，所以我就演示得更简单一些吧：在第五章的立方体示例，我们将通过旋转camara来解决图层平面化问题而不是像立方体示例代码中用的sublayerTransform。这是一个非常不错的技巧，但是只能作用域单个对象上，如果你的场景包含两个立方体，那我们就不能用这个技巧单独旋转他们了。</p>
<p>那么，就让我们来试一试CATransformLayer吧，第一个问题就来了：在第五章，我们是用多个视图来构造了我们的立方体，而不是单独的图层。我们不能在不打乱已有的视图层次的前提下在一个本身不是有寄宿图的图层中放置一个寄宿图图层。我们可以创建一个新的UIView子类寄宿在CATransformLayer（用+layerClass方法）之上。但是，为了简化案例，我们仅仅重建了一个单独的图层，而不是使用视图。这意味着我们不能像第五章一样在立方体表面显示按钮和标签，不过我们现在也用不到这个特性。</p>
<p>我们以我们在第五章使用过的相同基本逻辑放置立方体。但是并不像以前那样直接将立方面添加到容器视图的宿主图层，我们将他们放置到一个CATransformLayer中创建一个独立的立方体对象，然后将两个这样的立方体放进容器中。我们随机地给立方面染色以将他们区分开来，这样就不用靠标签或是光亮来区分他们。图6.5是运行结果。</p>
<p>用<font color="#DC143C">CATransformLayer</font>装配一个3D图层体系</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="built_in">CALayer</span> *)faceWithTransform:(<span class="built_in">CATransform3D</span>)transform&#123;</div><div class="line">    <span class="comment">//create cube face layer</span></div><div class="line">    <span class="built_in">CALayer</span> *face = [<span class="built_in">CALayer</span> layer];</div><div class="line">    face.frame = <span class="built_in">CGRectMake</span>(<span class="number">-50</span>, <span class="number">-50</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"></div><div class="line">    <span class="comment">//apply a random color</span></div><div class="line">    <span class="built_in">CGFloat</span> red = (rand() / (<span class="keyword">double</span>)INT_MAX);</div><div class="line">    <span class="built_in">CGFloat</span> green = (rand() / (<span class="keyword">double</span>)INT_MAX);</div><div class="line">    <span class="built_in">CGFloat</span> blue = (rand() / (<span class="keyword">double</span>)INT_MAX);</div><div class="line">    face.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:red green:green blue:blue alpha:<span class="number">1.0</span>].CGColor;</div><div class="line"></div><div class="line">    ￼<span class="comment">//apply the transform and return</span></div><div class="line">    face.transform = transform;</div><div class="line">    <span class="keyword">return</span> face;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">CALayer</span> *)cubeWithTransform:(<span class="built_in">CATransform3D</span>)transform&#123;</div><div class="line">    <span class="comment">//create cube layer</span></div><div class="line">    <span class="built_in">CATransformLayer</span> *cube = [<span class="built_in">CATransformLayer</span> layer];</div><div class="line"></div><div class="line">    <span class="comment">//add cube face 1</span></div><div class="line">    <span class="built_in">CATransform3D</span> ct = <span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);</div><div class="line">    [cube addSublayer:[<span class="keyword">self</span> faceWithTransform:ct]];</div><div class="line"></div><div class="line">    <span class="comment">//add cube face 2</span></div><div class="line">    ct = <span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    ct = <span class="built_in">CATransform3DRotate</span>(ct, M_PI_2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    [cube addSublayer:[<span class="keyword">self</span> faceWithTransform:ct]];</div><div class="line"></div><div class="line">    <span class="comment">//add cube face 3</span></div><div class="line">    ct = <span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">0</span>, <span class="number">-50</span>, <span class="number">0</span>);</div><div class="line">    ct = <span class="built_in">CATransform3DRotate</span>(ct, M_PI_2, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    [cube addSublayer:[<span class="keyword">self</span> faceWithTransform:ct]];</div><div class="line"></div><div class="line">    <span class="comment">//add cube face 4</span></div><div class="line">    ct = <span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>);</div><div class="line">    ct = <span class="built_in">CATransform3DRotate</span>(ct, -M_PI_2, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    [cube addSublayer:[<span class="keyword">self</span> faceWithTransform:ct]];</div><div class="line"></div><div class="line">    <span class="comment">//add cube face 5</span></div><div class="line">    ct = <span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">-50</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    ct = <span class="built_in">CATransform3DRotate</span>(ct, -M_PI_2, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    [cube addSublayer:[<span class="keyword">self</span> faceWithTransform:ct]];</div><div class="line"></div><div class="line">    <span class="comment">//add cube face 6</span></div><div class="line">    ct = <span class="built_in">CATransform3DMakeTranslation</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-50</span>);</div><div class="line">    ct = <span class="built_in">CATransform3DRotate</span>(ct, M_PI, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    [cube addSublayer:[<span class="keyword">self</span> faceWithTransform:ct]];</div><div class="line"></div><div class="line">    <span class="comment">//center the cube layer within the container</span></div><div class="line">    <span class="built_in">CGSize</span> containerSize = <span class="keyword">self</span>.containerView.bounds.size;</div><div class="line">    cube.position = <span class="built_in">CGPointMake</span>(containerSize.width / <span class="number">2.0</span>, containerSize.height / <span class="number">2.0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//apply the transform and return</span></div><div class="line">    cube.transform = transform;</div><div class="line">    <span class="keyword">return</span> cube;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;￼</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    <span class="comment">//set up the perspective transform</span></div><div class="line">    <span class="built_in">CATransform3D</span> pt = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    pt.m34 = <span class="number">-1.0</span> / <span class="number">500.0</span>;</div><div class="line">    <span class="keyword">self</span>.containerView.layer.sublayerTransform = pt;</div><div class="line"></div><div class="line">    <span class="comment">//set up the transform for cube 1 and add it</span></div><div class="line">    <span class="built_in">CATransform3D</span> c1t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    c1t = <span class="built_in">CATransform3DTranslate</span>(c1t, <span class="number">-100</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    <span class="built_in">CALayer</span> *cube1 = [<span class="keyword">self</span> cubeWithTransform:c1t];</div><div class="line">    [<span class="keyword">self</span>.containerView.layer addSublayer:cube1];</div><div class="line"></div><div class="line">    <span class="comment">//set up the transform for cube 2 and add it</span></div><div class="line">    <span class="built_in">CATransform3D</span> c2t = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    c2t = <span class="built_in">CATransform3DTranslate</span>(c2t, <span class="number">100</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    c2t = <span class="built_in">CATransform3DRotate</span>(c2t, -M_PI_4, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    c2t = <span class="built_in">CATransform3DRotate</span>(c2t, -M_PI_4, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="built_in">CALayer</span> *cube2 = [<span class="keyword">self</span> cubeWithTransform:c2t];</div><div class="line">    [<span class="keyword">self</span>.containerView.layer addSublayer:cube2];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>同一视角下的俩不同变换的立方体</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[专用图层 - CATiledLayer]]></title>
      <url>http://yoursite.com/2014/11/29/2014/%E4%B8%93%E7%94%A8%E5%9B%BE%E5%B1%82%20-%20CATiledLayer/</url>
      <content type="html"><![CDATA[<p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。<br>能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048<em>2048，或4096</em>4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU。</p>
<p>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。让我们用实验来证明一下。</p>
<h3 id="小片裁剪"><a href="#小片裁剪" class="headerlink" title="小片裁剪"></a>小片裁剪</h3><p>这个示例中，我们将会从一个2048*2048分辨率的雪人图片入手。为了能够从CATiledLayer中获益，我们需要把这个图片裁切成许多小一些的图片。你可以通过代码来完成这件事情，但是如果你在运行时读入整个图片并裁切，那CATiledLayer这些所有的性能优点就损失殆尽了。理想情况下来说，最好能够逐个步骤来实现。</p>
<p>下面代码演示了一个简单的Mac OS命令行程序，它用CATiledLayer将一个图片裁剪成小图并存储到不同的文件中。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])&#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span>&#123;</div><div class="line">        ￼<span class="comment">//handle incorrect arguments</span></div><div class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"TileCutter arguments: inputfile"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//input file</span></div><div class="line">            <span class="built_in">NSString</span> *inputFile = [<span class="built_in">NSString</span> stringWithCString:argv[<span class="number">1</span>] encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"></div><div class="line">            <span class="comment">//tile size</span></div><div class="line">            <span class="built_in">CGFloat</span> tileSize = <span class="number">256</span>; <span class="comment">//output path</span></div><div class="line">            <span class="built_in">NSString</span> *outputPath = [inputFile stringByDeletingPathExtension];</div><div class="line"></div><div class="line">            <span class="comment">//load image</span></div><div class="line">            <span class="built_in">NSImage</span> *image = [[<span class="built_in">NSImage</span> alloc] initWithContentsOfFile:inputFile];</div><div class="line">            <span class="built_in">NSSize</span> size = [image size];</div><div class="line">            <span class="built_in">NSArray</span> *representations = [image representations];</div><div class="line">            <span class="keyword">if</span> ([representations count])&#123;</div><div class="line">                <span class="built_in">NSBitmapImageRep</span> *representation = representations[<span class="number">0</span>];</div><div class="line">                size.width = [representation pixelsWide];</div><div class="line">                size.height = [representation pixelsHigh];</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSRect</span> rect = <span class="built_in">NSMakeRect</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, size.width, size.height);</div><div class="line">            <span class="built_in">CGImageRef</span> imageRef = [image <span class="built_in">CGImageForProposedRect</span>:&amp;rect context:<span class="literal">NULL</span> hints:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">            <span class="comment">//calculate rows and columns</span></div><div class="line">            <span class="built_in">NSInteger</span> rows = ceil(size.height / tileSize);</div><div class="line">            <span class="built_in">NSInteger</span> cols = ceil(size.width / tileSize);</div><div class="line"></div><div class="line">            <span class="comment">//generate tiles</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; rows; ++y) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; cols; ++x) &#123;</div><div class="line">                <span class="comment">//extract tile image</span></div><div class="line">                <span class="built_in">CGRect</span> tileRect = <span class="built_in">CGRectMake</span>(x*tileSize, y*tileSize, tileSize, tileSize);</div><div class="line">                <span class="built_in">CGImageRef</span> tileImage = <span class="built_in">CGImageCreateWithImageInRect</span>(imageRef, tileRect);</div><div class="line"></div><div class="line">                <span class="comment">//convert to jpeg data</span></div><div class="line">                <span class="built_in">NSBitmapImageRep</span> *imageRep = [[<span class="built_in">NSBitmapImageRep</span> alloc] initWithCGImage:tileImage];</div><div class="line">                <span class="built_in">NSData</span> *data = [imageRep representationUsingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];</div><div class="line">                <span class="built_in">CGImageRelease</span>(tileImage);</div><div class="line"></div><div class="line">                <span class="comment">//save file</span></div><div class="line">                <span class="built_in">NSString</span> *path = [outputPath stringByAppendingFormat: <span class="string">@"_%02i_%02i.jpg"</span>, x, y];</div><div class="line">                [data writeToFile:path atomically:<span class="literal">NO</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个程序将2048<em>2048分辨率的图片裁剪成了64个不同的256</em>256的小图。（256*256是CATiledLayer的默认小图大小，默认大小可以通过tileSize属性更改）。程序接受一个图片路径作为命令行的第一个参数。我们可以在编译的scheme将路径参数硬编码然后就可以在Xcode中运行了，但是以后作用在另一个图片上就不方便了。所以，我们编译了这个程序并把它保存到敏感的地方，然后从终端调用，如下面所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; path/to/TileCutterApp path/to/Snowman.jpg</div></pre></td></tr></table></figure>
<font color="##DC143C" size="3">The app is very basic, but could easily be extended to support additional arguments such as tile size, or to export images in formats other than JPEG. The result of running it is a sequence of 64 new images, named as follows:</font>

<p>这个程序相当基础，但是能够轻易地扩展支持额外的参数比如小图大小，或者导出格式等等。运行结果是64个新图的序列，如下面命名:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Snowman_00_00.jpg</div><div class="line">Snowman_00_01.jpg</div><div class="line">Snowman_00_02.jpg</div><div class="line">...</div><div class="line">Snowman_07_07.jpg</div></pre></td></tr></table></figure></p>
<p>既然我们有了裁切后的小图，我们就要让iOS程序用到他们。CATiledLayer很好地和UIScrollView集成在一起。除了设置图层和滑动视图边界以适配整个图片大小，我们真正要做的就是实现-drawLayer:inContext:方法，当需要载入新的小图时，CATiledLayer就会调用到这个方法。</p>
<p>一个简单的滚动CATiledLayer实现。代码如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIScrollView</span> *scrollView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//add the tiled layer</span></div><div class="line">    <span class="built_in">CATiledLayer</span> *tileLayer = [<span class="built_in">CATiledLayer</span> layer];￼</div><div class="line">    tileLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2048</span>, <span class="number">2048</span>);</div><div class="line">    tileLayer.delegate = <span class="keyword">self</span>; [<span class="keyword">self</span>.scrollView.layer addSublayer:tileLayer];</div><div class="line"></div><div class="line">    <span class="comment">//configure the scroll view</span></div><div class="line">    <span class="keyword">self</span>.scrollView.contentSize = tileLayer.frame.size;</div><div class="line"></div><div class="line">    <span class="comment">//draw layer</span></div><div class="line">    [tileLayer setNeedsDisplay];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CATiledLayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</div><div class="line">    <span class="comment">//determine tile coordinate</span></div><div class="line">    <span class="built_in">CGRect</span> bounds = <span class="built_in">CGContextGetClipBoundingBox</span>(ctx);</div><div class="line">    <span class="built_in">NSInteger</span> x = floor(bounds.origin.x / layer.tileSize.width);</div><div class="line">    <span class="built_in">NSInteger</span> y = floor(bounds.origin.y / layer.tileSize.height);</div><div class="line"></div><div class="line">    <span class="comment">//load tile image</span></div><div class="line">    <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat: <span class="string">@"Snowman_%02i_%02i"</span>, x, y];</div><div class="line">    <span class="built_in">NSString</span> *imagePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:imageName ofType:<span class="string">@"jpg"</span>];</div><div class="line">    <span class="built_in">UIImage</span> *tileImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:imagePath];</div><div class="line"></div><div class="line">    <span class="comment">//draw tile</span></div><div class="line">    <span class="built_in">UIGraphicsPushContext</span>(ctx);</div><div class="line">    [tileImage drawInRect:bounds];</div><div class="line">    <span class="built_in">UIGraphicsPopContext</span>();</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>当你滑动这个图片，你会发现当CATiledLayer载入小图的时候，他们会淡入到界面中。这是CATiledLayer的默认行为。（你可能已经在iOS 6之前的苹果地图程序中见过这个效果）你可以用fadeDuration属性改变淡入时长或直接禁用掉。CATiledLayer（不同于大部分的UIKit和Core Animation方法）支持多线程绘制，-drawLayer:inContext:方法可以在多个线程中同时地并发调用，所以请小心谨慎地确保你在这个方法中实现的绘制代码是线程安全的。</p>
<h3 id="Retina小图"><a href="#Retina小图" class="headerlink" title="Retina小图"></a>Retina小图</h3><p>你也许已经注意到了这些小图并不是以Retina的分辨率显示的。为了以屏幕的原生分辨率来渲染CATiledLayer，我们需要设置图层的contentsScale来匹配UIScreen的scale属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tileLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div></pre></td></tr></table></figure></p>
<p>有趣的是，tileSize是以像素为单位，而不是点，所以增大了contentsScale就自动有了默认的小图尺寸（现在它是128<em>128的点而不是256</em>256）.所以，我们不需要手工更新小图的尺寸或是在Retina分辨率下指定一个不同的小图。我们需要做的是适应小图渲染代码以对应安排scale的变化，然而：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//determine tile coordinate</span></div><div class="line"><span class="built_in">CGRect</span> bounds = <span class="built_in">CGContextGetClipBoundingBox</span>(ctx);</div><div class="line"><span class="built_in">CGFloat</span> scale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line"><span class="built_in">NSInteger</span> x = floor(bounds.origin.x / layer.tileSize.width * scale);</div><div class="line"><span class="built_in">NSInteger</span> y = floor(bounds.origin.y / layer.tileSize.height * scale);</div></pre></td></tr></table></figure></p>
<p>通过这个方法纠正scale也意味着我们的雪人图将以一半的大小渲染在Retina设备上（总尺寸是1024<em>1024，而不是2048</em>2048）。这个通常都不会影响到用CATiledLayer正常显示的图片类型（比如照片和地图，他们在设计上就是要支持放大缩小，能够在不同的缩放条件下显示），但是也需要在心里明白。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[专用图层 - CATextLayer]]></title>
      <url>http://yoursite.com/2014/11/23/2014/%E4%B8%93%E7%94%A8%E5%9B%BE%E5%B1%82%20-%20CATextLayer/</url>
      <content type="html"><![CDATA[<h3 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h3><p>用户界面是无法从一个单独的图片里面构建的。一个设计良好的图标能够很好地表现一个按钮或控件的意图，不过你迟早都要需要一个不错的老式风格的文本标签。</p>
<p>如果你想在一个图层里面显示文字，完全可以借助图层代理直接将字符串使用Core Graphics写入图层的内容（这就是UILabel的精髓）。如果越过寄宿于图层的视图，直接在图层上操作，那其实相当繁琐。你要为每一个显示文字的图层创建一个能像图层代理一样工作的类，还要逻辑上判断哪个图层需要显示哪个字符串，更别提还要记录不同的字体，颜色等一系列乱七八糟的东西。</p>
<p>万幸的是这些都是不必要的，Core Animation提供了一个CALayer的子类CATextLayer，它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。</p>
<p>同样，CATextLayer也要比UILabel渲染得快得多。很少有人知道在iOS 6及之前的版本，UILabel其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而CATextLayer使用了Core text，并且渲染得非常快。</p>
<p>让我们来尝试用<font color="#DC143C">CATextLayer</font>来显示一些文字<font color="#DC143C">CATextLayer</font> 来实现一个<font color="#DC143C">UILabel</font><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *labelView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    <span class="comment">//create a text layer</span></div><div class="line">    <span class="built_in">CATextLayer</span> *textLayer = [<span class="built_in">CATextLayer</span> layer];</div><div class="line">    textLayer.frame = <span class="keyword">self</span>.labelView.bounds;</div><div class="line">    [<span class="keyword">self</span>.labelView.layer addSublayer:textLayer];</div><div class="line"></div><div class="line">    <span class="comment">//set text attributes</span></div><div class="line">    textLayer.foregroundColor = [<span class="built_in">UIColor</span> blackColor].CGColor;</div><div class="line">    textLayer.alignmentMode = kCAAlignmentJustified;</div><div class="line">    textLayer.wrapped = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="comment">//choose a font</span></div><div class="line">    <span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</div><div class="line"></div><div class="line">    <span class="comment">//set layer font</span></div><div class="line">    <span class="built_in">CFStringRef</span> fontName = (__bridge <span class="built_in">CFStringRef</span>)font.fontName;</div><div class="line">    <span class="built_in">CGFontRef</span> fontRef = <span class="built_in">CGFontCreateWithFontName</span>(fontName);</div><div class="line">    textLayer.font = fontRef;</div><div class="line">    textLayer.fontSize = font.pointSize;</div><div class="line">    <span class="built_in">CGFontRelease</span>(fontRef);</div><div class="line"></div><div class="line">    <span class="comment">//choose some text</span></div><div class="line">    <span class="built_in">NSString</span> *text = <span class="string">@"Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis"</span>;</div><div class="line"></div><div class="line">    <span class="comment">//set layer text</span></div><div class="line">    textLayer.string = text;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>用CATextLayer来显示一个纯文本标签。如果你仔细看这个文本，你会发现一个奇怪的地方：这些文本有一些像素化了。这是因为并没有以Retina的方式渲染，第二章提到了这个contentScale属性，用来决定图层内容应该以怎样的分辨率来渲染。contentsScale并不关心屏幕的拉伸因素而总是默认为1.0。如果我们想以Retina的质量来显示文字，我们就得手动地设置CATextLayer的contentsScale属性，如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div></pre></td></tr></table></figure></p>
<p>设置contentsScale来匹配屏幕<br>CATextLayer的font属性不是一个UIFont类型，而是一个CFTypeRef类型。这样可以根据你的具体需要来决定字体属性应该是用CGFontRef类型还是CTFontRef类型（Core Text字体）。同时字体大小也是用fontSize属性单独设置的，因为CTFontRef和CGFontRef并不像UIFont一样包含点大小。这个例子会告诉你如何将UIFont转换成CGFontRef。</p>
<p>另外，CATextLayer的string属性并不是你想象的NSString类型，而是id类型。这样你既可以用NSString也可以用NSAttributedString来指定文本了（注意，NSAttributedString并不是NSString的子类）。属性化字符串是iOS用来渲染字体风格的机制，它以特定的方式来决定指定范围内的字符串的原始信息，比如字体，颜色，字重，斜体等。</p>
<h3 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h3><p>iOS 6中，Apple给UILabel和其他UIKit文本视图添加了直接的属性化字符串的支持，应该说这是一个很方便的特性。不过事实上从iOS3.2开始CATextLayer就已经支持属性化字符串了。这样的话，如果你想要支持更低版本的iOS系统，CATextLayer无疑是你向界面中增加富文本的好办法，而且也不用去跟复杂的Core Text打交道，也省了用UIWebView的麻烦。</p>
<p>让我们编辑一下示例使用到NSAttributedString. iOS 6及以上我们可以用新的NSTextAttributeName实例来设置我们的字符串属性，但是练习的目的是为了演示在iOS 5及以下，所以我们用了Core Text，也就是说你需要把Core Text framework添加到你的项目中。否则，编译器是无法识别属性常量的。</p>
<p>运行一下代码 用NSAttributedString实现一个富文本标签<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"DrawingView.h"</span></span></div><div class="line"><span class="meta">#import</span></div><div class="line"><span class="meta">#import</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *labelView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line"></div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    <span class="comment">//create a text layer</span></div><div class="line">    <span class="built_in">CATextLayer</span> *textLayer = [<span class="built_in">CATextLayer</span> layer];</div><div class="line">    textLayer.frame = <span class="keyword">self</span>.labelView.bounds;</div><div class="line">    textLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line">    [<span class="keyword">self</span>.labelView.layer addSublayer:textLayer];</div><div class="line"></div><div class="line">    <span class="comment">//set text attributes</span></div><div class="line">    textLayer.alignmentMode = kCAAlignmentJustified;</div><div class="line">    textLayer.wrapped = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="comment">//choose a font</span></div><div class="line">    <span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>];</div><div class="line"></div><div class="line">    <span class="comment">//choose some text</span></div><div class="line">    <span class="built_in">NSString</span> *text = <span class="string">@"Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc \ elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis"</span>;</div><div class="line">    ￼</div><div class="line">    <span class="comment">//create attributed string</span></div><div class="line">    <span class="built_in">NSMutableAttributedString</span> *string = <span class="literal">nil</span>;</div><div class="line">    string = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:text];</div><div class="line"></div><div class="line">    <span class="comment">//convert UIFont to a CTFont</span></div><div class="line">    <span class="built_in">CFStringRef</span> fontName = (__bridge <span class="built_in">CFStringRef</span>)font.fontName;</div><div class="line">    <span class="built_in">CGFloat</span> fontSize = font.pointSize;</div><div class="line">    <span class="built_in">CTFontRef</span> fontRef = <span class="built_in">CTFontCreateWithName</span>(fontName, fontSize, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//set text attributes</span></div><div class="line">    <span class="built_in">NSDictionary</span> *attribs = @&#123;</div><div class="line">        (__bridge <span class="keyword">id</span>)kCTForegroundColorAttributeName:(__bridge <span class="keyword">id</span>)[<span class="built_in">UIColor</span> blackColor].CGColor,</div><div class="line">        (__bridge <span class="keyword">id</span>)kCTFontAttributeName: (__bridge <span class="keyword">id</span>)fontRef</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    [string setAttributes:attribs range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [text length])];</div><div class="line">    attribs = @&#123;</div><div class="line">        (__bridge <span class="keyword">id</span>)kCTForegroundColorAttributeName: (__bridge <span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor].CGColor,</div><div class="line">        (__bridge <span class="keyword">id</span>)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),</div><div class="line">        (__bridge <span class="keyword">id</span>)kCTFontAttributeName: (__bridge <span class="keyword">id</span>)fontRef</div><div class="line">    &#125;;</div><div class="line">    [string setAttributes:attribs range:<span class="built_in">NSMakeRange</span>(<span class="number">6</span>, <span class="number">5</span>)];</div><div class="line"></div><div class="line">    <span class="comment">//release the CTFont we created earlier</span></div><div class="line">    <span class="built_in">CFRelease</span>(fontRef);</div><div class="line"></div><div class="line">    <span class="comment">//set layer text</span></div><div class="line">    textLayer.string = string;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>以上就是用CATextLayer实现一个富文本标签</p>
<h3 id="行距和字距"><a href="#行距和字距" class="headerlink" title="行距和字距"></a>行距和字距</h3><p>有必要提一下的是，由于绘制的实现机制不同（Core Text和WebKit），用CATextLayer渲染和用UILabel渲染出的文本行距和字距也不是不尽相同的。</p>
<p>二者的差异程度（由使用的字体和字符决定）总的来说挺小，但是如果你想正确的显示普通便签和CATextLayer就一定要记住这一点。</p>
<h3 id="UILabel的替代品"><a href="#UILabel的替代品" class="headerlink" title="UILabel的替代品"></a>UILabel的替代品</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"LayerLabel.h"</span></span></div><div class="line"><span class="meta">#import</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LayerLabel</span></span></div><div class="line">+ (Class)layerClass&#123;</div><div class="line">    <span class="comment">//this makes our label create a CATextLayer //instead of a regular CALayer for its backing layer</span></div><div class="line">    <span class="keyword">return</span> [<span class="built_in">CATextLayer</span> <span class="keyword">class</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">CATextLayer</span> *)textLayer&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">CATextLayer</span> *)<span class="keyword">self</span>.layer;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setUp&#123;</div><div class="line">    <span class="comment">//set defaults from UILabel settings</span></div><div class="line">    <span class="keyword">self</span>.text = <span class="keyword">self</span>.text;</div><div class="line">    <span class="keyword">self</span>.textColor = <span class="keyword">self</span>.textColor;</div><div class="line">    <span class="keyword">self</span>.font = <span class="keyword">self</span>.font;</div><div class="line"></div><div class="line">    <span class="comment">//we should really derive these from the UILabel settings too</span></div><div class="line">    <span class="comment">//but that's complicated, so for now we'll just hard-code them</span></div><div class="line">    [<span class="keyword">self</span> textLayer].alignmentMode = kCAAlignmentJustified;</div><div class="line">    ￼</div><div class="line">    [<span class="keyword">self</span> textLayer].wrapped = <span class="literal">YES</span>;</div><div class="line">    [<span class="keyword">self</span>.layer display];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame&#123;</div><div class="line">    <span class="comment">//called when creating label programmatically</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</div><div class="line">        [<span class="keyword">self</span> setUp];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)awakeFromNib&#123;</div><div class="line">    <span class="comment">//called when creating label using Interface Builder</span></div><div class="line">    [<span class="keyword">self</span> setUp];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setText:(<span class="built_in">NSString</span> *)text&#123;</div><div class="line">    <span class="keyword">super</span>.text = text;</div><div class="line">    <span class="comment">//set layer text</span></div><div class="line">    [<span class="keyword">self</span> textLayer].string = text;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setTextColor:(<span class="built_in">UIColor</span> *)textColor&#123;</div><div class="line">    <span class="keyword">super</span>.textColor = textColor;</div><div class="line">    <span class="comment">//set layer text color</span></div><div class="line">    [<span class="keyword">self</span> textLayer].foregroundColor = textColor.CGColor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setFont:(<span class="built_in">UIFont</span> *)font&#123;</div><div class="line">    <span class="keyword">super</span>.font = font;</div><div class="line">    <span class="comment">//set layer font</span></div><div class="line">    <span class="built_in">CFStringRef</span> fontName = (__bridge <span class="built_in">CFStringRef</span>)font.fontName;</div><div class="line">    <span class="built_in">CGFontRef</span> fontRef = <span class="built_in">CGFontCreateWithFontName</span>(fontName);</div><div class="line">    [<span class="keyword">self</span> textLayer].font = fontRef;</div><div class="line">    [<span class="keyword">self</span> textLayer].fontSize = font.pointSize;</div><div class="line">    ￼</div><div class="line">    <span class="built_in">CGFontRelease</span>(fontRef);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>如果你运行代码，你会发现文本并没有像素化，而我们也没有设置contentsScale属性。把CATextLayer作为宿主图层的另一好处就是视图自动设置了contentsScale属性。</p>
<p>在这个简单的例子中，我们只是实现了UILabel的一部分风格和布局属性，不过稍微再改进一下我们就可以创建一个支持UILabel所有功能甚至更多功能的LayerLabel类（你可以在一些线上的开源项目中找到）。</p>
<p>如果你打算支持iOS 6及以上，基于CATextLayer的标签可能就有有些局限性。但是总得来说，如果想在app里面充分利用CALayer子类，用+layerClass来创建基于不同图层的视图是一个简单可复用的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[专用图层 - CAShapeLayer]]></title>
      <url>http://yoursite.com/2014/11/21/2014/%E4%B8%93%E7%94%A8%E5%9B%BE%E5%B1%82%20-%20CAShapeLayer/</url>
      <content type="html"><![CDATA[<h3 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h3><p>可以不使用图片的情况下用CGPath去构造任意形状的阴影。如果我们能用同样的方式创建相同形状的图层就好了。</p>
<p><font color="#DC143C">CAShapeLayer</font>是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，相比直下，使用CAShapeLayer有以下一些优点：</p>
<ul>
<li>1.渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li>
<li>2.高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>3.不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉（如我们在第二章所见）。</li>
<li>4.不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</li>
</ul>
<h3 id="创建一个CGPath"><a href="#创建一个CGPath" class="headerlink" title="创建一个CGPath"></a>创建一个CGPath</h3><p><font color="#DC143C">CAShapeLayer</font>可以用来绘制所有能够通过CGPath来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个不同的形状。你可以控制一些属性比如lineWith（线宽，用点表示单位），lineCap（线条结尾的样子），和lineJoin（线条之间的结合点的样子）；但是在图层层面你只有一次机会设置这些属性。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。</p>
<p>用CAShapeLayer绘制一个火柴人<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"DrawingView.h"</span></span></div><div class="line"><span class="meta">#import</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//create path</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *path = [[<span class="built_in">UIBezierPath</span> alloc] init];</div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">175</span>, <span class="number">100</span>)];</div><div class="line">    ￼</div><div class="line">    [path addArcWithCenter:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">100</span>) radius:<span class="number">25</span> startAngle:<span class="number">0</span> endAngle:<span class="number">2</span>*M_PI clockwise:<span class="literal">YES</span>];</div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">125</span>)];</div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">175</span>)];</div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">125</span>, <span class="number">225</span>)];</div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">150</span>, <span class="number">175</span>)];</div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">175</span>, <span class="number">225</span>)];</div><div class="line">    [path moveToPoint:<span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">150</span>)];</div><div class="line">    [path addLineToPoint:<span class="built_in">CGPointMake</span>(<span class="number">200</span>, <span class="number">150</span>)];</div><div class="line"></div><div class="line">    <span class="comment">//create shape layer</span></div><div class="line">    <span class="built_in">CAShapeLayer</span> *shapeLayer = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line">    shapeLayer.strokeColor = [<span class="built_in">UIColor</span> redColor].CGColor;</div><div class="line">    shapeLayer.fillColor = [<span class="built_in">UIColor</span> clearColor].CGColor;</div><div class="line">    shapeLayer.lineWidth = <span class="number">5</span>;</div><div class="line">    shapeLayer.lineJoin = kCALineJoinRound;</div><div class="line">    shapeLayer.lineCap = kCALineCapRound;</div><div class="line">    shapeLayer.path = path.CGPath;</div><div class="line">    <span class="comment">//add it to our view</span></div><div class="line">    [<span class="keyword">self</span>.containerView.layer addSublayer:shapeLayer];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>CALayer的cornerRadius属性也可以用来倒角。虽然使用CAShapeLayer类需要更多的工作，但是它有一个优势就是可以单独指定每个角。<br>我们创建圆角矩形其实就是人工绘制单独的直线和弧度，但是事实上UIBezierPath有自动绘制圆角矩形的构造方法，下面这段代码绘制了一个有三个圆角一个直角的矩形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//define path parameters</div><div class="line">CGRect rect = CGRectMake(50, 50, 100, 100);</div><div class="line">CGSize radii = CGSizeMake(20, 20);</div><div class="line">UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;</div><div class="line"></div><div class="line">//create path</div><div class="line">UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];</div></pre></td></tr></table></figure></p>
<p>我们可以通过这个图层路径绘制一个既有直角又有圆角的视图。如果我们想依照此图形来剪裁视图内容，我们可以把CAShapeLayer作为视图的宿主图层，而不是添加一个子视图。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[专用图层 - CAScrollLayer]]></title>
      <url>http://yoursite.com/2014/11/05/2014/%E4%B8%93%E7%94%A8%E5%9B%BE%E5%B1%82%20-%20CAScrollLayer/</url>
      <content type="html"><![CDATA[<h3 id="CAScrollLayer"><a href="#CAScrollLayer" class="headerlink" title="CAScrollLayer"></a>CAScrollLayer</h3><p>对于一个未转换的图层，它的bounds和它的frame是一样的，frame属性是由bounds属性自动计算而出的，所以更改任意一个值都会更新其他值。</p>
<p>但是如果你只想显示一个大图层里面的一小部分呢。比如说，你可能有一个很大的图片，你希望用户能够随意滑动，或者是一个数据或文本的长列表。在一个典型的iOS应用中，你可能会用到UITableView或是UIScrollView，但是对于独立的图层来说，什么会等价于刚刚提到的UITableView和UIScrollView呢？</p>
<p>在第二章中，我们探索了图层的contentsRect属性的用法，它的确是能够解决在图层中小地方显示大图片的解决方法。但是如果你的图层包含子图层那它就不是一个非常好的解决方案，因为，这样做的话每次你想『滑动』可视区域的时候，你就需要手工重新计算并更新所有的子图层位置。</p>
<p>这个时候就需要<font color="#DC143C">CAScrollLayer</font>了。CAScrollLayer有一个-scrollToPoint:方法，它自动适应bounds的原点以便图层内容出现在滑动的地方。注意，这就是它做的所有事情。前面提到过，Core Animation并不处理用户输入，所以CAScrollLayer并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹（当视图滑动超多了它的边界的将会反弹回正确的地方）。</p>
<p>让我们来用CAScrollLayer来常见一个基本的UIScrollView替代品。我们将会用CAScrollLayer作为视图的宿主图层，并创建一个自定义的UIView，然后用UIPanGestureRecognizer实现触摸事件响应。</p>
<p>下面这段代码运行效果：ScrollView显示了一个大于它的frame的UIImageView。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#import &quot;ScrollView.h&quot;</div><div class="line">#import  @implementation ScrollView</div><div class="line">+ (Class)layerClass&#123;</div><div class="line">    return [CAScrollLayer class];</div><div class="line">&#125;</div><div class="line">- (void)setUp&#123;</div><div class="line">    //enable clipping</div><div class="line">    self.layer.masksToBounds = YES;</div><div class="line"></div><div class="line">    //attach pan gesture recognizer</div><div class="line">    UIPanGestureRecognizer *recognizer = nil;</div><div class="line">    recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];</div><div class="line">    [self addGestureRecognizer:recognizer];</div><div class="line">&#125;</div><div class="line">- (id)initWithFrame:(CGRect)frame&#123;</div><div class="line">    //this is called when view is created in code</div><div class="line">    if ((self = [super initWithFrame:frame])) &#123;</div><div class="line">        [self setUp];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">- (void)awakeFromNib &#123;</div><div class="line">    //this is called when view is created from a nib</div><div class="line">    [self setUp];</div><div class="line">&#125;</div><div class="line">- (void)pan:(UIPanGestureRecognizer *)recognizer&#123;</div><div class="line">    //get the offset by subtracting the pan gesture</div><div class="line">    //translation from the current bounds origin</div><div class="line">    CGPoint offset = self.bounds.origin;</div><div class="line">    offset.x -= [recognizer translationInView:self].x;</div><div class="line">    offset.y -= [recognizer translationInView:self].y;</div><div class="line"></div><div class="line">    //scroll the layer</div><div class="line">    [(CAScrollLayer *)self.layer scrollToPoint:offset];</div><div class="line"></div><div class="line">    //reset the pan gesture translation</div><div class="line">    [recognizer setTranslation:CGPointZero inView:self];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>不同于UIScrollView，我们定制的滑动视图类并没有实现任何形式的边界检查（bounds checking）。图层内容极有可能滑出视图的边界并无限滑下去。CAScrollLayer并没有等同于UIScrollView中contentSize的属性，所以当CAScrollLayer滑动的时候完全没有一个全局的可滑动区域的概念，也无法自适应它的边界原点至你指定的值。它之所以不能自适应边界大小是因为它不需要，内容完全可以超过边界。<br>那你一定会奇怪用CAScrollLayer的意义到底何在，因为你可以简单地用一个普通的CALayer然后手动适应边界原点啊。真相其实并不复杂，UIScrollView并没有用CAScrollLayer，事实上，就是简单的通过直接操作图层边界来实现滑动。<br>CAScrollLayer有一个潜在的有用特性。如果你查看CAScrollLayer的头文件，你就会注意到有一个扩展分类实现了一些方法和属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollPoint:(<span class="built_in">CGPoint</span>)p;</div><div class="line">- (<span class="keyword">void</span>)scrollRectToVisible:(<span class="built_in">CGRect</span>)r;</div><div class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">CGRect</span> visibleRect;</div></pre></td></tr></table></figure></p>
<p>看到这些方法和属性名，你也许会以为这些方法给每个CALayer实例增加了滑动功能。但是事实上他们只是放置在CAScrollLayer中的图层的实用方法。scrollPoint:方法从图层树中查找并找到第一个可用的CAScrollLayer，然后滑动它使得指定点成为可视的。scrollRectToVisible:方法实现了同样的事情只不过是作用在一个矩形上的。visibleRect属性决定图层（如果存在的话）的哪部分是当前的可视区域。如果你自己实现这些方法就会相对容易明白一点，但是CAScrollLayer帮你省了这些麻烦，所以当涉及到实现图层滑动的时候就可以用上了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[专用图层 - CAEAGLLayer]]></title>
      <url>http://yoursite.com/2014/10/19/2014/%E4%B8%93%E7%94%A8%E5%9B%BE%E5%B1%82%20-%20CAEAGLLayer/</url>
      <content type="html"><![CDATA[<p>当iOS要处理高性能图形绘制，必要时就是OpenGL。应该说它应该是最后的杀手锏，至少对于非游戏的应用来说是的。因为相比Core Animation和UIkit框架，它不可思议地复杂。</p>
<p>OpenGL提供了Core Animation的基础，它是底层的C接口，直接和iPhone，iPad的硬件通信，极少地抽象出来的方法。OpenGL没有对象或是图层的继承概念。它只是简单地处理三角形。OpenGL中所有东西都是3D空间中有颜色和纹理的三角形。用起来非常复杂和强大，但是用OpenGL绘制iOS用户界面就需要很多很多的工作了。</p>
<p>为了能够以高性能使用Core Animation，你需要判断你需要绘制哪种内容（矢量图形，例子，文本，等等），但后选择合适的图层去呈现这些内容，Core Animation中只有一些类型的内容是被高度优化的；所以如果你想绘制的东西并不能找到标准的图层类，想要得到高性能就比较费事情了。</p>
<p>因为OpenGL根本不会对你的内容进行假设，它能够绘制得相当快。利用OpenGL，你可以绘制任何你知道必要的集合信息和形状逻辑的内容。所以很多游戏都喜欢用OpenGL（这些情况下，Core Animation的限制就明显了：它优化过的内容类型并不一定能满足需求），但是这样依赖，方便的高度抽象接口就没了。</p>
<p>在iOS 5中，苹果引入了一个新的框架叫做GLKit，它去掉了一些设置OpenGL的复杂性，提供了一个叫做CLKView的UIView的子类，帮你处理大部分的设置和绘制工作。前提是各种各样的OpenGL绘图缓冲的底层可配置项仍然需要你用CAEAGLLayer完成，它是CALayer的一个子类，用来显示任意的OpenGL图形。</p>
<p>大部分情况下你都不需要手动设置CAEAGLLayer（假设用GLKView），过去的日子就不要再提了。特别的，我们将设置一个OpenGL ES 2.0的上下文，它是现代的iOS设备的标准做法。</p>
<p>尽管不需要GLKit也可以做到这一切，但是GLKit囊括了很多额外的工作，比如设置顶点和片段着色器，这些都以类C语言叫做GLSL自包含在程序中，同时在运行时载入到图形硬件中。编写GLSL代码和设置EAGLayer没有什么关系，所以我们将用GLKBaseEffect类将着色逻辑抽象出来。其他的事情，我们还是会有以往的方式。</p>
<p>在开始之前，你需要将GLKit和OpenGLES框架加入到你的项目中，里面是设置一个GAEAGLLayer的最少工作，它使用了OpenGL ES 2.0 的绘图上下文，并渲染了一个有色三角。</p>
<p>用<font color="#DC143C">CAEAGLLayer</font>绘制一个三角形</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import</span></div><div class="line"><span class="meta">#import</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *glView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EAGLContext *glContext;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">CAEAGLLayer</span> *glLayer;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) GLuint framebuffer;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) GLuint colorRenderbuffer;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) GLint framebufferWidth;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) GLint framebufferHeight;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) GLKBaseEffect *effect;</div><div class="line">￼</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setUpBuffers&#123;</div><div class="line">    <span class="comment">//set up frame buffer</span></div><div class="line">    glGenFramebuffers(<span class="number">1</span>, &amp;_framebuffer);</div><div class="line">    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);</div><div class="line"></div><div class="line">    <span class="comment">//set up color render buffer</span></div><div class="line">    glGenRenderbuffers(<span class="number">1</span>, &amp;_colorRenderbuffer);</div><div class="line">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);</div><div class="line">    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderbuffer);</div><div class="line">    [<span class="keyword">self</span>.glContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:<span class="keyword">self</span>.glLayer];</div><div class="line">    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;_framebufferWidth);</div><div class="line">    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;_framebufferHeight);</div><div class="line"></div><div class="line">    <span class="comment">//check success</span></div><div class="line">    <span class="keyword">if</span> (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Failed to make complete framebuffer object: %i"</span>, glCheckFramebufferStatus(GL_FRAMEBUFFER));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)tearDownBuffers&#123;</div><div class="line">    <span class="keyword">if</span> (_framebuffer) &#123;</div><div class="line">        <span class="comment">//delete framebuffer</span></div><div class="line">        glDeleteFramebuffers(<span class="number">1</span>, &amp;_framebuffer);</div><div class="line">        _framebuffer = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (_colorRenderbuffer) &#123;</div><div class="line">        <span class="comment">//delete color render buffer</span></div><div class="line">        glDeleteRenderbuffers(<span class="number">1</span>, &amp;_colorRenderbuffer);</div><div class="line">        _colorRenderbuffer = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)drawFrame &#123;</div><div class="line">    <span class="comment">//bind framebuffer &amp; set viewport</span></div><div class="line">    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);</div><div class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, _framebufferWidth, _framebufferHeight);</div><div class="line"></div><div class="line">    <span class="comment">//bind shader program</span></div><div class="line">    [<span class="keyword">self</span>.effect prepareToDraw];</div><div class="line"></div><div class="line">    <span class="comment">//clear the screen</span></div><div class="line">    glClear(GL_COLOR_BUFFER_BIT); glClearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//set up vertices</span></div><div class="line">    GLfloat vertices[] = &#123;</div><div class="line">        <span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">-1.0</span>f, <span class="number">0.0</span>f, <span class="number">0.5</span>f, <span class="number">-1.0</span>f, <span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">-1.0</span>f,</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//set up colors</span></div><div class="line">    GLfloat colors[] = &#123;</div><div class="line">        <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f,</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//draw triangle</span></div><div class="line">    glEnableVertexAttribArray(GLKVertexAttribPosition);</div><div class="line">    glEnableVertexAttribArray(GLKVertexAttribColor);</div><div class="line">    glVertexAttribPointer(GLKVertexAttribPosition, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, vertices);</div><div class="line">    glVertexAttribPointer(GLKVertexAttribColor,<span class="number">4</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, colors);</div><div class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="comment">//present render buffer</span></div><div class="line">    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);</div><div class="line">    [<span class="keyword">self</span>.glContext presentRenderbuffer:GL_RENDERBUFFER];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//set up context</span></div><div class="line">    <span class="keyword">self</span>.glContext = [[EAGLContext alloc] initWithAPI: kEAGLRenderingAPIOpenGLES2];</div><div class="line">    [EAGLContext setCurrentContext:<span class="keyword">self</span>.glContext];</div><div class="line"></div><div class="line">    <span class="comment">//set up layer</span></div><div class="line">    <span class="keyword">self</span>.glLayer = [<span class="built_in">CAEAGLLayer</span> layer];</div><div class="line">    <span class="keyword">self</span>.glLayer.frame = <span class="keyword">self</span>.glView.bounds;</div><div class="line">    [<span class="keyword">self</span>.glView.layer addSublayer:<span class="keyword">self</span>.glLayer];</div><div class="line">    <span class="keyword">self</span>.glLayer.drawableProperties = @&#123;kEAGLDrawablePropertyRetainedBacking:@NO, kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8&#125;;</div><div class="line"></div><div class="line">    <span class="comment">//set up base effect</span></div><div class="line">    <span class="keyword">self</span>.effect = [[GLKBaseEffect alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">//set up buffers</span></div><div class="line">    [<span class="keyword">self</span> setUpBuffers];</div><div class="line"></div><div class="line">    <span class="comment">//draw frame</span></div><div class="line">    [<span class="keyword">self</span> drawFrame];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)viewDidUnload&#123;</div><div class="line">    [<span class="keyword">self</span> tearDownBuffers];</div><div class="line">    [<span class="keyword">super</span> viewDidUnload];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)dealloc&#123;</div><div class="line">    [<span class="keyword">self</span> tearDownBuffers];</div><div class="line">    [EAGLContext setCurrentContext:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>运行代码查看效果 用OpenGL渲染的CAEAGLLayer图层</p>
<p>在一个真正的OpenGL应用中，我们可能会用NSTimer或CADisplayLink周期性地每秒钟调用-drawRrame方法60次，同时会将几何图形生成和绘制分开以便不会每次都重新生成三角形的顶点（这样也可以让我们绘制其他的一些东西而不是一个三角形而已），不过上面这个例子已经足够演示了绘图原则了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[专用图层 - CAEmitterLayer]]></title>
      <url>http://yoursite.com/2014/10/19/2014/%E4%B8%93%E7%94%A8%E5%9B%BE%E5%B1%82%20-%20CAEmitterLayer/</url>
      <content type="html"><![CDATA[<p>在iOS 5中，苹果引入了一个新的CALayer子类叫做CAEmitterLayer。CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。<br>CAEmitterLayer看上去像是许多CAEmitterCell的容器，这些CAEmitierCell定义了一个例子效果。你将会为不同的例子效果定义一个或多个CAEmitterCell作为模版，同时CAEmitterLayer负责基于这些模版实例化一个粒子流。一个CAEmitterCell类似于一个CALayer：它有一个contents属性可以定义为一个CGImage，另外还有一些可设置属性控制着表现和行为。我们不会对这些属性逐一进行详细的描述，你们可以在CAEmitterCell类的头文件中找到。</p>
<p>我们来举个例子。我们将利用在一圆中发射不同速度和透明度的粒子创建一个火爆炸的效果。</p>
<p>用<font color="#DC143C">CAEmitterLayer</font>创建爆炸效果<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    ￼</div><div class="line">    <span class="comment">//create particle emitter layer</span></div><div class="line">    <span class="built_in">CAEmitterLayer</span> *emitter = [<span class="built_in">CAEmitterLayer</span> layer];</div><div class="line">    emitter.frame = <span class="keyword">self</span>.containerView.bounds;</div><div class="line">    [<span class="keyword">self</span>.containerView.layer addSublayer:emitter];</div><div class="line"></div><div class="line">    <span class="comment">//configure emitter</span></div><div class="line">    emitter.renderMode = kCAEmitterLayerAdditive;</div><div class="line">    emitter.emitterPosition = <span class="built_in">CGPointMake</span>(emitter.frame.size.width / <span class="number">2.0</span>, emitter.frame.size.height / <span class="number">2.0</span>);</div><div class="line"></div><div class="line">    <span class="comment">//create a particle template</span></div><div class="line">    <span class="built_in">CAEmitterCell</span> *cell = [[<span class="built_in">CAEmitterCell</span> alloc] init];</div><div class="line">    cell.contents = (__bridge <span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Spark.png"</span>].CGImage;</div><div class="line">    cell.birthRate = <span class="number">150</span>;</div><div class="line">    cell.lifetime = <span class="number">5.0</span>;</div><div class="line">    cell.color = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">1</span> green:<span class="number">0.5</span> blue:<span class="number">0.1</span> alpha:<span class="number">1.0</span>].CGColor;</div><div class="line">    cell.alphaSpeed = <span class="number">-0.4</span>;</div><div class="line">    cell.velocity = <span class="number">50</span>;</div><div class="line">    cell.velocityRange = <span class="number">50</span>;</div><div class="line">    cell.emissionRange = M_PI * <span class="number">2.0</span>;</div><div class="line"></div><div class="line">    <span class="comment">//add particle template to emitter</span></div><div class="line">    emitter.emitterCells = @[cell];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>CAEMitterCell的属性基本上可以分为三种</p>
<ul>
<li>1.这种粒子的某一属性的初始值。比如，color属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。</li>
<li>2.例子某一属性的变化范围。比如emissionRange属性的值是2π，这意味着例子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形</li>
<li>3.指定值在时间线上的变化。比如，在示例中，我们将alphaSpeed设置为-0.4，就是说例子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐小时的效果。</li>
</ul>
<p>CAEmitterLayer的属性它自己控制着整个例子系统的位置和形状。一些属性比如birthRate，lifetime和celocity，这些属性在CAEmitterCell中也有。这些属性会以相乘的方式作用在一起，这样你就可以用一个值来加速或者扩大整个例子系统。其他值得提到的属性有以下这些：</p>
<ul>
<li>1.preservesDepth，是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层</li>
<li>2.renderMode，控制着在视觉上粒子图片是如何混合的。你可能已经注意到了示例中我们把它设置为kCAEmitterLayerAdditive，它实现了这样一个效果：合并例子重叠部分的亮度使得看上去更亮。如果我们把它设置为默认的kCAEmitterLayerUnordered。</li>
</ul>
<p>运行代码看效果</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[专用图层 - AVPlayerLayer]]></title>
      <url>http://yoursite.com/2014/10/14/2014/%E4%B8%93%E7%94%A8%E5%9B%BE%E5%B1%82%20-%20AVPlayerLayer/</url>
      <content type="html"><![CDATA[<p>最后一个图层类型是AVPlayerLayer。尽管它不是Core Animation框架的一部分（AV前缀看上去像），AVPlayerLayer是有别的框架（AVFoundation）提供的，它和Core Animation紧密地结合在一起，提供了一个CALayer子类来显示自定义的内容类型。</p>
<p>AVPlayerLayer是用来在iOS上播放视频的。他是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。AVPlayerLayer的使用相当简单：你可以用+playerLayerWithPlayer:方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用player属性绑定一个AVPlayer实例。</p>
<p>在我们开始之前，我们需要添加AVFoundation到我们的项目中。用AVPlayerLayer播放视频<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView; <span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//get video URL</span></div><div class="line">    <span class="built_in">NSURL</span> *URL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Ship"</span> withExtension:<span class="string">@"mp4"</span>];</div><div class="line"></div><div class="line">    <span class="comment">//create player and player layer</span></div><div class="line">    <span class="built_in">AVPlayer</span> *player = [<span class="built_in">AVPlayer</span> playerWithURL:URL];</div><div class="line">    <span class="built_in">AVPlayerLayer</span> *playerLayer = [<span class="built_in">AVPlayerLayer</span> playerLayerWithPlayer:player];</div><div class="line"></div><div class="line">    <span class="comment">//set player layer frame and attach it to our view</span></div><div class="line">    playerLayer.frame = <span class="keyword">self</span>.containerView.bounds;</div><div class="line">    [<span class="keyword">self</span>.containerView.layer addSublayer:playerLayer];</div><div class="line"></div><div class="line">    <span class="comment">//play the video</span></div><div class="line">    [player play];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>我们用代码创建了一个AVPlayerLayer，但是我们仍然把它添加到了一个容器视图中，而不是直接在controller中的主视图上添加。这样其实是为了可以使用自动布局限制使得图层在最中间；否则，一旦设备被旋转了我们就要手动重新放置位置，因为Core Animation并不支持自动大小和自动布局。</p>
<p>当然，因为AVPlayerLayer是CALayer的子类，它继承了父类的所有特性。我们并不会受限于要在一个矩形中播放视频。下面是给视频增加变换，边框和圆角。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">//set player layer frame and attach it to our view</span></div><div class="line">    playerLayer.frame = <span class="keyword">self</span>.containerView.bounds;</div><div class="line">    [<span class="keyword">self</span>.containerView.layer addSublayer:playerLayer];</div><div class="line"></div><div class="line">    <span class="comment">//transform layer</span></div><div class="line">    <span class="built_in">CATransform3D</span> transform = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    transform.m34 = <span class="number">-1.0</span> / <span class="number">500.0</span>;</div><div class="line">    transform = <span class="built_in">CATransform3DRotate</span>(transform, M_PI_4, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    playerLayer.transform = transform;</div><div class="line">    ￼</div><div class="line">    <span class="comment">//add rounded corners and border</span></div><div class="line">    playerLayer.masksToBounds = <span class="literal">YES</span>;</div><div class="line">    playerLayer.cornerRadius = <span class="number">20.0</span>;</div><div class="line">    playerLayer.borderColor = [<span class="built_in">UIColor</span> redColor].CGColor;</div><div class="line">    playerLayer.borderWidth = <span class="number">5.0</span>;</div><div class="line"></div><div class="line">    <span class="comment">//play the video</span></div><div class="line">    [player play];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行代码查看3D视角下的边框和圆角AVPlayerLayer</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[专用图层 - CAShapeLayer]]></title>
      <url>http://yoursite.com/2014/10/08/2014/%E4%B8%93%E7%94%A8%E5%9B%BE%E5%B1%82%20%20-%20CAShapeLayer/</url>
      <content type="html"><![CDATA[<h3 id="CAReplicatorLayer"><a href="#CAReplicatorLayer" class="headerlink" title="CAReplicatorLayer"></a>CAReplicatorLayer</h3><p>CAReplicatorLayer的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。看上去演示能够更加解释这些，我们来写个例子吧。</p>
<h3 id="重复图层（Repeating-Layers）"><a href="#重复图层（Repeating-Layers）" class="headerlink" title="重复图层（Repeating Layers）"></a>重复图层（Repeating Layers）</h3><p>我们在屏幕的中间创建了一个小白色方块图层，然后用CAReplicatorLayer生成十个图层组成一个圆圈。instanceCount属性指定了图层需要重复多少次。instanceTransform指定了一个CATransform3D3D变换（这种情况下，下一图层的位移和旋转将会移动到圆圈的下一个点）。变换是逐步增加的，每个实例都是相对于前一实例布局。这就是为什么这些复制体最终不会出现在同意位置上。</p>
<p>运行一下代码 用CAReplicatorLayer重复图层<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//create a replicator layer and add it to our view</span></div><div class="line">    <span class="built_in">CAReplicatorLayer</span> *replicator = [<span class="built_in">CAReplicatorLayer</span> layer];</div><div class="line">    replicator.frame = <span class="keyword">self</span>.containerView.bounds;</div><div class="line">    [<span class="keyword">self</span>.containerView.layer addSublayer:replicator];</div><div class="line"></div><div class="line">    <span class="comment">//configure the replicator</span></div><div class="line">    replicator.instanceCount = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="comment">//apply a transform for each instance</span></div><div class="line">    <span class="built_in">CATransform3D</span> transform = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    transform = <span class="built_in">CATransform3DTranslate</span>(transform, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>);</div><div class="line">    transform = <span class="built_in">CATransform3DRotate</span>(transform, M_PI / <span class="number">5.0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    transform = <span class="built_in">CATransform3DTranslate</span>(transform, <span class="number">0</span>, <span class="number">-200</span>, <span class="number">0</span>);</div><div class="line">    replicator.instanceTransform = transform;</div><div class="line"></div><div class="line">    <span class="comment">//apply a color shift for each instance</span></div><div class="line">    replicator.instanceBlueOffset = <span class="number">-0.1</span>;</div><div class="line">    replicator.instanceGreenOffset = <span class="number">-0.1</span>;</div><div class="line"></div><div class="line">    <span class="comment">//create a sublayer and place it inside the replicator</span></div><div class="line">    <span class="built_in">CALayer</span> *layer = [<span class="built_in">CALayer</span> layer];</div><div class="line">    layer.frame = <span class="built_in">CGRectMake</span>(<span class="number">100.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f);</div><div class="line">    layer.backgroundColor = [<span class="built_in">UIColor</span> whiteColor].CGColor;</div><div class="line">    [replicator addSublayer:layer];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>注意到当图层在重复的时候，他们的颜色也在变化：这是用instanceBlueOffset和instanceGreenOffset属性实现的。通过逐步减少蓝色和绿色通道，我们逐渐将图层颜色转换成了红色。这个复制效果看起来很酷，但是CAReplicatorLayer真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云，或者粒子爆炸（尽管iOS 5已经引入了CAEmitterLayer，它更适合创建任意的粒子效果）。除此之外，还有一个实际应用是：反射。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>使用CAReplicatorLayer并应用一个负比例变换于一个复制图层，你就可以创建指定视图（或整个视图层次）内容的镜像图片，这样就创建了一个实时的『反射』效果。让我们来尝试实现这个创意：指定一个继承于UIView的ReflectionView，它会自动产生内容的反射效果。实现这个效果的代码很简单，实际上用ReflectionView实现这个效果会更简单，我们只需要把ReflectionView的实例放置于Interface Builder，它就会实时生成子视图的反射，而不需要别的代码。</p>
<p>用CAReplicatorLayer自动绘制反射<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ReflectionView.h"</span></span></div><div class="line"><span class="meta">#import</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ReflectionView</span></span></div><div class="line"></div><div class="line">+ (Class)layerClass&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">CAReplicatorLayer</span> <span class="keyword">class</span>];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setUp&#123;</div><div class="line">    <span class="comment">//configure replicator</span></div><div class="line">    <span class="built_in">CAReplicatorLayer</span> *layer = (<span class="built_in">CAReplicatorLayer</span> *)<span class="keyword">self</span>.layer;</div><div class="line">    layer.instanceCount = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="comment">//move reflection instance below original and flip vertically</span></div><div class="line">    <span class="built_in">CATransform3D</span> transform = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    <span class="built_in">CGFloat</span> verticalOffset = <span class="keyword">self</span>.bounds.size.height + <span class="number">2</span>;</div><div class="line">    transform = <span class="built_in">CATransform3DTranslate</span>(transform, <span class="number">0</span>, verticalOffset, <span class="number">0</span>);</div><div class="line">    transform = <span class="built_in">CATransform3DScale</span>(transform, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</div><div class="line">    layer.instanceTransform = transform;</div><div class="line"></div><div class="line">    <span class="comment">//reduce alpha of reflection layer</span></div><div class="line">    layer.instanceAlphaOffset = <span class="number">-0.6</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame&#123;</div><div class="line">    <span class="comment">//this is called when view is created in code</span></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame])) &#123;</div><div class="line">        [<span class="keyword">self</span> setUp];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)awakeFromNib&#123;</div><div class="line">    <span class="comment">//this is called when view is created from a nib</span></div><div class="line">    [<span class="keyword">self</span> setUp];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>在Interface Builder中使用ReflectionView。开源代码ReflectionView完成了一个自适应的渐变淡出效果（用CAGradientLayer和图层蒙板实现），代码见 (<a href="https://github.com/nicklockwood/ReflectionView" target="_blank" rel="external">https://github.com/nicklockwood/ReflectionView</a>)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[专用图层 - CAGradientLayer]]></title>
      <url>http://yoursite.com/2014/10/07/2014/%E4%B8%93%E7%94%A8%E5%9B%BE%E5%B1%82%20%20-%20CAGradientLayer.md/</url>
      <content type="html"><![CDATA[<h3 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h3><p>CAGradientLayer是用来生成两种或更多颜色平滑渐变的。用Core Graphics复制一个CAGradientLayer并将内容绘制到一个普通图层的寄宿图也是有可能的，但是CAGradientLayer的真正好处在于绘制使用了硬件加速。</p>
<h3 id="基础渐变"><a href="#基础渐变" class="headerlink" title="基础渐变"></a>基础渐变</h3><p>我们将从一个简单的红变蓝的对角线渐变开始。这些渐变色彩放在一个数组中，并赋给colors属性。这个数组成员接受CGColorRef类型的值（并不是从NSObject派生而来），所以我们要用通过bridge转换以确保编译正常。</p>
<p>CAGradientLayer也有startPoint和endPoint属性，他们决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是{0, 0}，右下角坐标是{1, 1}。</p>
<p>简单的两种颜色的对角线渐变<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//create gradient layer and add it to our container view</span></div><div class="line">    <span class="built_in">CAGradientLayer</span> *gradientLayer = [<span class="built_in">CAGradientLayer</span> layer];</div><div class="line">    gradientLayer.frame = <span class="keyword">self</span>.containerView.bounds;</div><div class="line">    [<span class="keyword">self</span>.containerView.layer addSublayer:gradientLayer];</div><div class="line"></div><div class="line">    <span class="comment">//set gradient colors</span></div><div class="line">    gradientLayer.colors = @[(__bridge <span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor].CGColor, (__bridge <span class="keyword">id</span>)[<span class="built_in">UIColor</span> blueColor].CGColor];</div><div class="line"></div><div class="line">    <span class="comment">//set gradient start and end points</span></div><div class="line">    gradientLayer.startPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    gradientLayer.endPoint = <span class="built_in">CGPointMake</span>(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="多重渐变"><a href="#多重渐变" class="headerlink" title="多重渐变"></a>多重渐变</h3><p>如果你愿意，colors属性可以包含很多颜色，所以创建一个彩虹一样的多重渐变也是很简单的。默认情况下，这些颜色在空间上均匀地被渲染，但是我们可以用locations属性来调整空间。locations属性是一个浮点数值的数组（以NSNumber包装）。这些浮点数定义了colors属性中每个不同颜色的位置，同样的，也是以单位坐标系进行标定。0.0代表着渐变的开始，1.0代表着结束。locations数组并不是强制要求的，但是如果你给它赋值了就一定要确保locations的数组大小和colors数组大小一定要相同，否则你将会得到一个空白的渐变。</p>
<p>现在变成了从红到黄最后到绿色的渐变。locations数组指定了0.0，0.25和0.5三个数值，这样这三个渐变就有点像挤在了左上角。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line">    <span class="comment">//create gradient layer and add it to our container view</span></div><div class="line">    <span class="built_in">CAGradientLayer</span> *gradientLayer = [<span class="built_in">CAGradientLayer</span> layer];</div><div class="line">    gradientLayer.frame = <span class="keyword">self</span>.containerView.bounds;</div><div class="line">    [<span class="keyword">self</span>.containerView.layer addSublayer:gradientLayer];</div><div class="line"></div><div class="line">    <span class="comment">//set gradient colors</span></div><div class="line">    gradientLayer.colors = @[(__bridge <span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor].CGColor, (__bridge <span class="keyword">id</span>) [<span class="built_in">UIColor</span> yellowColor].CGColor, (__bridge <span class="keyword">id</span>)[<span class="built_in">UIColor</span> greenColor].CGColor];</div><div class="line"></div><div class="line">    <span class="comment">//set locations</span></div><div class="line">    gradientLayer.locations = @[@<span class="number">0.0</span>, @<span class="number">0.25</span>, @<span class="number">0.5</span>];</div><div class="line"></div><div class="line">    <span class="comment">//set gradient start and end points</span></div><div class="line">    gradientLayer.startPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    gradientLayer.endPoint = <span class="built_in">CGPointMake</span>(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用locations构造偏移至左上角的三色渐变</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[拉伸过滤]]></title>
      <url>http://yoursite.com/2014/09/30/2014/%E6%8B%89%E4%BC%B8%E8%BF%87%E6%BB%A4/</url>
      <content type="html"><![CDATA[<p>最后我们再来谈谈<font color="#DC143C">minificationFilter</font>和<font color="#DC143C">magnificationFilter</font>属性。总得来讲，当我们视图显示一个图片的时候，都应该正确地显示这个图片（意即：以正确的比例和正确的1：1像素显示在屏幕上）。原因如下：</p>
<ul>
<li>1.能够显示最好的画质，像素既没有被压缩也没有被拉伸。</li>
<li>2.能更好的使用内存，因为这就是所有你要存储的东西。</li>
<li>3.最好的性能表现，CPU不需要为此额外的计算。</li>
</ul>
<p>不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。</p>
<p>当图片需要显示不同的大小的时候，有一种叫做拉伸过滤的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。</p>
<p>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。CALayer为此提供了三种拉伸过滤方法，他们是：</p>
<font color="#DC143C">kCAFilterLinear</font><br><font color="#DC143C">kCAFilterNearest</font><br><font color="#DC143C">kCAFilterTrilinear</font>

<p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是kCAFilterLinear，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。</p>
<p>kCAFilterTrilinear和kCAFilterLinear非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。</p>
<p>这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题。对于大图来说，双线性滤波和三线性滤波表现得更出色。</p>
<p>kCAFilterNearest是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。对于没有斜线的小图来说，最近过滤算法要好很多。</p>
<p>总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。<br>让我们来实验一下。我们对第三章的时钟项目改动一下，用LCD风格的数字方式显示。我们用简单的像素字体（一种用像素构成字符的字体，而非矢量图形）创造数字显示方式，用图片存储起来，而且用第二章介绍过的拼合技术来显示。</p>
<p>一个简单的运用拼合技术显示的LCD数字风格的像素字体。</p>
<p>我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个，图4.17显示了这六个视图是如何在Interface Builder中放置的。如果每个都用一个淡出的outlets对象就会显得太多了，所以我们就用了一个IBOutletCollection对象把他们和控制器联系起来，这样我们就可以以数组的方式访问视图了。</p>
<p>代码如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) IBOutletCollection(<span class="built_in">UIView</span>) <span class="built_in">NSArray</span> *digitViews;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer;</div><div class="line">￼￼</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">//get spritesheet image</span></div><div class="line">    <span class="built_in">UIImage</span> *digits = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Digits.png"</span>];</div><div class="line"></div><div class="line">    <span class="comment">//set up digit views</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> <span class="keyword">self</span>.digitViews) &#123;</div><div class="line">        <span class="comment">//set contents</span></div><div class="line">        view.layer.contents = (__bridge <span class="keyword">id</span>)digits.CGImage;</div><div class="line">        view.layer.contentsRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</div><div class="line">        view.layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//start timer</span></div><div class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(tick) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">    <span class="comment">//set initial clock time</span></div><div class="line">    [<span class="keyword">self</span> tick];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setDigit:(<span class="built_in">NSInteger</span>)digit forView:(<span class="built_in">UIView</span> *)view&#123;</div><div class="line">    <span class="comment">//adjust contentsRect to select correct digit</span></div><div class="line">    view.layer.contentsRect = <span class="built_in">CGRectMake</span>(digit * <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)tick&#123;</div><div class="line">    <span class="comment">//convert time to hours, minutes and seconds</span></div><div class="line">    <span class="built_in">NSCalendar</span> *calendar = [[<span class="built_in">NSCalendar</span> alloc] initWithCalendarIdentifier: <span class="built_in">NSGregorianCalendar</span>];</div><div class="line">    <span class="built_in">NSUInteger</span> units = <span class="built_in">NSHourCalendarUnit</span> | <span class="built_in">NSMinuteCalendarUnit</span> | <span class="built_in">NSSecondCalendarUnit</span>;</div><div class="line">    ￼</div><div class="line">    <span class="built_in">NSDateComponents</span> *components = [calendar components:units fromDate:[<span class="built_in">NSDate</span> date]];</div><div class="line"></div><div class="line">    <span class="comment">//set hours</span></div><div class="line">    [<span class="keyword">self</span> setDigit:components.hour / <span class="number">10</span> forView:<span class="keyword">self</span>.digitViews[<span class="number">0</span>]];</div><div class="line">    [<span class="keyword">self</span> setDigit:components.hour % <span class="number">10</span> forView:<span class="keyword">self</span>.digitViews[<span class="number">1</span>]];</div><div class="line"></div><div class="line">    <span class="comment">//set minutes</span></div><div class="line">    [<span class="keyword">self</span> setDigit:components.minute / <span class="number">10</span> forView:<span class="keyword">self</span>.digitViews[<span class="number">2</span>]];</div><div class="line">    [<span class="keyword">self</span> setDigit:components.minute % <span class="number">10</span> forView:<span class="keyword">self</span>.digitViews[<span class="number">3</span>]];</div><div class="line"></div><div class="line">    <span class="comment">//set seconds</span></div><div class="line">    [<span class="keyword">self</span> setDigit:components.second / <span class="number">10</span> forView:<span class="keyword">self</span>.digitViews[<span class="number">4</span>]];</div><div class="line">    [<span class="keyword">self</span> setDigit:components.second % <span class="number">10</span> forView:<span class="keyword">self</span>.digitViews[<span class="number">5</span>]];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>查看效果<br>这样做的确起了效果，但是图片看起来模糊了。看起来默认的kCAFilterLinear选项让我们失望了。一个模糊的时钟，由默认的kCAFilterLinear引起。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.layer.magnificationFilter = kCAFilterNearest;</div></pre></td></tr></table></figure></p>
<p>设置了最近过滤之后的清晰显示</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[寄宿图 - Custom Drawing]]></title>
      <url>http://yoursite.com/2014/09/29/2014/%E5%AF%84%E5%AE%BF%E5%9B%BE%20-%20Custom%20Drawing/</url>
      <content type="html"><![CDATA[<p>给contents赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现-drawRect:方法来自定义绘制。</p>
<p>-drawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到-drawRect: 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale 的值。</p>
<p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。<br>当视图在屏幕上出现的时候 -drawRect:方法就会被自动调用。-drawRect:方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了-setNeedsDisplay方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如bounds属性）。虽然-drawRect:方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<p>CALayer有一个可选的delegate属性，实现了CALayerDelegate协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（delegate属性被声明为id类型，所有的代理方法都是可选的）。<br>当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)displayLayer:(<span class="built_in">CALayerCALayer</span> *)layer;</div></pre></td></tr></table></figure>
<p>趁着这个机会，如果代理想直接设置contents属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现-displayLayer:方法，CALayer就会转而尝试调用下面这个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx;</div></pre></td></tr></table></figure></p>
<p>在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</p>
<p>在ViewController中实现CALayerDelegate<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    ￼</div><div class="line">    <span class="comment">//create sublayer</span></div><div class="line">    <span class="built_in">CALayer</span> *blueLayer = [<span class="built_in">CALayer</span> layer];</div><div class="line">    blueLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">50.0</span>f, <span class="number">50.0</span>f, <span class="number">100.0</span>f, <span class="number">100.0</span>f);</div><div class="line">    blueLayer.backgroundColor = [<span class="built_in">UIColor</span> blueColor].CGColor;</div><div class="line"></div><div class="line">    <span class="comment">//set controller as layer delegate</span></div><div class="line">    blueLayer.delegate = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="comment">//ensure that layer backing image uses correct scale</span></div><div class="line">    blueLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale; <span class="comment">//add layer to our view</span></div><div class="line">    [<span class="keyword">self</span>.layerView.layer addSublayer:blueLayer];</div><div class="line"></div><div class="line">    <span class="comment">//force layer to redraw</span></div><div class="line">    [blueLayer display];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</div><div class="line">    <span class="comment">//draw a thick red circle</span></div><div class="line">    <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">10.0</span>f);</div><div class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> redColor].CGColor);</div><div class="line">    <span class="built_in">CGContextStrokeEllipseInRect</span>(ctx, layer.bounds);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>注意一下一些有趣的事情：<br>我们在 blueLayer 上显式地调用了-display。不同于UIView，当图层显示在屏幕上时，CALayer 不会自动重绘它的内容。它把重绘的决定权交给了开发者。<br>尽管我们没有用 masksToBounds 属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。<br>现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到 CALayerDelegate 协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个 -displayLayer: 的实现，那所有的问题就都没了。<br>当使用寄宿了视图的图层的时候，你也不必实现 -displayLayer: 和 -drawLayer:inContext: 方法来绘制你的寄宿图。通常做法是实现UIView的 -drawRect: 方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用-display方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[寄宿图 - contents属性]]></title>
      <url>http://yoursite.com/2014/09/27/2014/%E5%AF%84%E5%AE%BF%E5%9B%BE%20-%20contents%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<font color="#DC143C">CALayer</font> 有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。<br>contents这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。<br>头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的contents，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。<br>尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），他们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：<br>layer.contents = (<strong>bridge id)image.CGImage;<br><br><br>如果你没有使用ARC（自动引用计数），你就不需要</strong>bridge这部分。但是，你干嘛不用ARC？！<br>让我们来继续修改我们在第一章新建的工程，以便能够展示一张图片而不仅仅是一个背景色。我们已经用代码的方式建立一个图层，那我们就不需要额外的图层了。那么我们就直接把layerView的宿主图层的contents属性设置成图片。<br><br>看代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *layerView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.layerView];</div><div class="line"></div><div class="line">    <span class="built_in">UIImage</span> *iamge = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"order_date_icon"</span>];</div><div class="line">    <span class="keyword">self</span>.layerView.layer.contents = (__bridge <span class="keyword">id</span>)iamge.CGImage;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">UIView</span> *)layerView&#123;</div><div class="line">    <span class="keyword">if</span> (_layerView == <span class="literal">nil</span>) &#123;</div><div class="line">        _layerView = [[<span class="built_in">UIView</span> alloc]init];</div><div class="line">        _layerView.frame = <span class="built_in">CGRectMake</span>(<span class="number">20</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">        _layerView.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _layerView;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><br><br>运行代码就会看见layer上面展示了我们需要添加的图片。我们利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。通过直接操作图层，我们使用了一些新的函数。<br><br>### contentGravity<br>观察图片你可能会发现 我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。在使用UIImageView的时候遇到过同样的问题，解决方法就是把contentMode属性设置成更合适的值，像这样：<br><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.contentMode = <span class="built_in">UIViewContentModeScaleAspectFit</span>;</div></pre></td></tr></table></figure><br><br>这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 ），不过UIView大多数视觉相关的属性比如contentMode，对这些属性的操作其实是对对应图层的操作。<br>CALayer与contentMode对应的属性叫做contentsGravity，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。contentsGravity可选的常量值有以下一些：<br><br><font color="#DC143C">kCAGravityCenter</font><br><font color="#DC143C">kCAGravityTop</font><br><font color="#DC143C">kCAGravityBottom</font><br><font color="#DC143C">kCAGravityLeft</font><br><font color="#DC143C">kCAGravityRight</font><br><font color="#DC143C">kCAGravityTopLeft</font><br><font color="#DC143C">kCAGravityTopRight</font><br><font color="#DC143C">kCAGravityBottomLeft</font><br><font color="#DC143C">kCAGravityBottomRight</font><br><font color="#DC143C">kCAGravityResize</font><br><font color="#DC143C">kCAGravityResizeAspect</font><br><font color="#DC143C">kCAGravityResizeAspectFill</font>

<p>和cotentMode一样，contentsGravity的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.layerView.layer.contentsGravity = kCAGravityResizeAspect;</div></pre></td></tr></table></figure>
<h3 id="contentsScale"><a href="#contentsScale" class="headerlink" title="contentsScale"></a>contentsScale</h3><p>contentsScale属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>
<p>contentsScale的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为contents由于设置了contentsGravity属性，所以它已经被拉伸以适应图层的边界。</p>
<p>如果你只是单纯地想放大图层的contents图片，你可以通过使用图层的transform和affineTransform属性来达到这个目的, 这(指放大)也不是contengsScale的目的所在。</p>
<p>contentsScale属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置contentsGravity属性）。UIView有一个类似功能但是非常少用到的contentScaleFactor属性</p>
<p>如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。</p>
<p>这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把contentsGravity设置为kCAGravityCenter（这个值并不会拉伸图片），那将会有很明显的变化。</p>
<p> 观察图片你会发现有明显的颗粒感：用错误的contentsScale属性显示Retina图片</p>
<p>那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置contentsScale来修复这个问题。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad]; <span class="comment">//load an image</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Snowman.png"</span>]; <span class="comment">//add it directly to our view's layer</span></div><div class="line">    <span class="keyword">self</span>.layerView.layer.contents = (__bridge <span class="keyword">id</span>)image.CGImage; <span class="comment">//center the image</span></div><div class="line">    <span class="keyword">self</span>.layerView.layer.contentsGravity = kCAGravityCenter;</div><div class="line"></div><div class="line">    <span class="comment">//set the contentsScale to match image</span></div><div class="line">    <span class="keyword">self</span>.layerView.layer.contentsScale = image.scale;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的contentsScale属性，否则，你的图片在Retina设备上就显示得不正确啦<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div></pre></td></tr></table></figure></p>
<p>运行你会发现<br>现在我们的图片总算是显示了正确的大小，不过你也许已经发现了另外一些事情：他超出了视图的边界。默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。UIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds，把它设置为YES。</p>
<h3 id="contentsRect"><a href="#contentsRect" class="headerlink" title="contentsRect"></a>contentsRect</h3><p>CALayer的contentsRect属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比contentsGravity灵活多了。</p>
<p>和bounds，frame不同，contentsRect不是按点来计算的，它使用了单位坐标，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统。</p>
<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ul>
<p>默认的contentsRect是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪。事实上给contentsRect设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>
<p>contentsRect在app中最有趣的地方在于一个叫做image sprites（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。<br>典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等<br>2D游戏引擎入Cocos2D使用了拼合技术，它使用OpenGL来显示图片。不过我们可以使用拼合在一个普通的UIKit应用中，对！就是使用contentsRect<br>首先，我们需要一个拼合后的图表 —— 一个包含小一些的拼合图的大图片。</p>
<p>接下来，我们要在app中载入并显示这些拼合图。规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的contents，然后设置每个图层的contentsRect来去掉我们不想显示的部分。我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来拜访他们的位置，如果你愿意还是可以用代码的方式来实现的）</p>
<p>代码如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *coneView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *shipView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *iglooView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *anchorView;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addSpriteImage:(<span class="built_in">UIImage</span> *)image withContentRect:(<span class="built_in">CGRect</span>)rect ￼toLayer:(<span class="built_in">CALayer</span> *)layer&#123;</div><div class="line"></div><div class="line">    <span class="comment">//set image</span></div><div class="line">    layer.contents = (__bridge <span class="keyword">id</span>)image.CGImage;</div><div class="line"></div><div class="line">    <span class="comment">//scale contents to fit</span></div><div class="line">    layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line">    </div><div class="line">    <span class="comment">//set contentsRect</span></div><div class="line">    layer.contentsRect = rect;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//load sprite sheet</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Sprites.png"</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//set igloo sprite</span></div><div class="line">    [<span class="keyword">self</span> addSpriteImage:image withContentRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span>.iglooView.layer];</div><div class="line">    </div><div class="line">    <span class="comment">//set cone sprite</span></div><div class="line">    [<span class="keyword">self</span> addSpriteImage:image withContentRect:<span class="built_in">CGRectMake</span>(<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span>.coneView.layer];</div><div class="line">    </div><div class="line">    <span class="comment">//set anchor sprite</span></div><div class="line">    [<span class="keyword">self</span> addSpriteImage:image withContentRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span>.anchorView.layer];</div><div class="line">    </div><div class="line">    <span class="comment">//set spaceship sprite</span></div><div class="line">    [<span class="keyword">self</span> addSpriteImage:image withContentRect:<span class="built_in">CGRectMake</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span>.shipView.layer];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入地更快），但是如果有手动安排的话，他们还是有一些不方便的，如果你需要在一个已经创建好的品和图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。<br>Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置contentsRect，这样开发者就不用手动写代码来摆放位置了。<br>这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（<a href="https://github.com/nicklockwood/LayerSprites)，它能够读取Cocos2D格式中的拼合图并在普通的Core" target="_blank" rel="external">https://github.com/nicklockwood/LayerSprites)，它能够读取Cocos2D格式中的拼合图并在普通的Core</a> Animation层中显示出来。</p>
<h3 id="contentsCenter"><a href="#contentsCenter" class="headerlink" title="contentsCenter"></a>contentsCenter</h3><p>本章我们介绍的最后一个和内容有关的属性是contentsCenter，看名字你可能会以为它可能跟图片的位置有关，不过这名字着实误导了你。contentsCenter其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变contentsCenter的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。<br>默认情况下，contentsCenter是{0, 0, 1, 1}，这意味着如果大小（由conttensGravity决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。图2.9展示了contentsCenter设置为{0.25, 0.25, 0.5, 0.5}的效果。</p>
<p>这意味着我们可以随意重设尺寸，边框仍然会是连续的。他工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形</p>
<p>不过，contentsCenter的另一个很酷的特性就是，它可以在Interface Builder里面配置，根本不用写代码。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *button1;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *button2;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addStretchableImage:(<span class="built_in">UIImage</span> *)image withContentCenter:(<span class="built_in">CGRect</span>)rect toLayer:(<span class="built_in">CALayer</span> *)layer&#123;</div><div class="line">    <span class="comment">//set image</span></div><div class="line">    layer.contents = (__bridge <span class="keyword">id</span>)image.CGImage;</div><div class="line"></div><div class="line">    <span class="comment">//set contentsCenter</span></div><div class="line">    layer.contentsCenter = rect;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//load button image</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Button.png"</span>];</div><div class="line"></div><div class="line">    <span class="comment">//set button 1</span></div><div class="line">    [<span class="keyword">self</span> addStretchableImage:image withContentCenter:<span class="built_in">CGRectMake</span>(<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span>.button1.layer];</div><div class="line"></div><div class="line">    <span class="comment">//set button 2</span></div><div class="line">    [<span class="keyword">self</span> addStretchableImage:image withContentCenter:<span class="built_in">CGRectMake</span>(<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) toLayer:<span class="keyword">self</span>.button2.layer];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>xib试图可以用Interface Builder 探测窗口控制contentsCenter属性</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图层与视图]]></title>
      <url>http://yoursite.com/2014/09/01/2014/%E5%9B%BE%E5%B1%82%E4%B8%8E%E8%A7%86%E5%9B%BE/</url>
      <content type="html"><![CDATA[<h3 id="图层的树状结构"><a href="#图层的树状结构" class="headerlink" title="图层的树状结构"></a>图层的树状结构</h3><p>Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做Layer Kit这么一个不怎么和动画有关的名字演变而来，所以做动画这只是Core Animation特性的冰山一角。</p>
<p>Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中。于是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。</p>
<p>如果你曾经在iOS或者Mac OS平台上写过应用程序，你可能会对视图的概念比较熟悉。一个视图就是在屏幕上显示的一个矩形块（比如图片，文字或者视频），它能够拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。</p>
<p>在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于<font color="#DC143C">Core Graphics</font>绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>
<h3 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h3><p>CALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。</p>
<p>CALayer并不清楚具体的响应链（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内。</p>
<h3 id="平行的层级关系"><a href="#平行的层级关系" class="headerlink" title="平行的层级关系"></a>平行的层级关系</h3><p> 每一个UIview都有一个CALayer实例的图层属性，也就是所谓的<font color="#DC143C">backing layer</font>，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作</p>
<p> 实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及<font color="#DC143C">Core Animation</font>底层方法的高级接口。<br> 但是为什么iOS要基于UIView和CALayer提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和UIView，但是Mac OS有AppKit和NSView的原因。他们功能上很相似，但是在实现上有着显著的区别。</p>
<p> 绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。</p>
<p> 实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了<font color="#DC143C">视图层级</font>和<font color="#DC143C">图层树</font>之外，还存在<font color="#DC143C">呈现树</font>和<font color="#DC143C">渲染树</font></p>
<h3 id="图层的能力"><a href="#图层的能力" class="headerlink" title="图层的能力"></a>图层的能力</h3><p> 如果说CALayer是UIView内部实现细节，那我们为什么要全面地了解它呢？苹果当然为我们提供了优美简洁的UIView接口，那么我们是否就没必要直接去处理Core Animation的细节了呢？<br> 某种意义上说的确是这样，对一些简单的需求来说，我们确实没必要处理CALayer，因为苹果已经通过UIView的高级API间接地使得动画变得很简单。</p>
<p> 但是这种简单会不可避免地带来一些灵活上的缺陷。如果你略微想在底层做一些改变，或者使用一些苹果没有在UIView上实现的接口功能，这时除了介入Core Animation底层之外别无选择。<br> 我们已经证实了图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些UIView没有暴露出来的CALayer的功能：</p>
<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li><p>多级非线性动画</p>
<p>我们将会在后续章节中探索这些功能，首先我们要关注一下在应用程序当中CALayer是怎样被利用起来的。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GPU VS CPU]]></title>
      <url>http://yoursite.com/2014/08/24/2014/GPU%20VS%20CPU/</url>
      <content type="html"><![CDATA[<p>关于绘图和动画有两种处理的方式：<font color="#DC143C">CPU</font>(中央处理器）和<font color="#DC143C">GPU</font>图形处理器）。在现代iOS设备中，都有可以运行不同软件的可编程芯片，但是由于历史原因，我们可以说CPU所做的工作都在软件层面，而GPU在硬件层面。<br>总的来说，我们可以用软件（使用CPU）做任何事情，但是对于图像处理，通常用硬件会更快，因为GPU使用图像对高度并行浮点运算做了优化。由于某些原因，我们想尽可能把屏幕渲染的工作交给硬件去处理。问题在于GPU并没有无限制处理性能，而且一旦资源用完的话，性能就会开始下降了（即使CPU并没有完全占用）</p>
<p>大多数动画性能优化都是关于智能利用GPU和CPU，使得它们都不会超出负荷。于是我们首先需要知道Core Animation是如何在这两个处理器之间分配工作的。</p>
<h3 id="动画的舞台"><a href="#动画的舞台" class="headerlink" title="动画的舞台"></a>动画的舞台</h3><p>Core Animation处在iOS的核心地位：应用内和应用间都会用到它。一个简单的动画可能同步显示多个app的内容，例如当在iPad上多个程序之间使用手势切换，会使得多个程序同时显示在屏幕上。在一个特定的应用中用代码实现它是没有意义的，因为在iOS中不可能实现这种效果（App都是被沙箱管理，不能访问别的视图）。</p>
<p>动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的渲染服务。在iOS5和之前的版本是SpringBoard进程（同时管理着iOS的主屏）。在iOS6之后的版本中叫做BackBoard</p>
<p>当运行一段动画时候，这个过程会被四个分离的阶段被打破</p>
<ul>
<li>布局<br>这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段。</li>
<li>显示<br>这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的<font color="#DC143C">-drawRect:</font>和<font color="#DC143C">-drawLayer:inContext:</font>方法的调用路径。</li>
<li>准备<br>这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。</li>
<li>提交<br>这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。</li>
</ul>
<p>但是这些仅仅阶段仅仅发生在你的应用程序之内，在动画在屏幕上显示之前仍然有更多的工作。一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做渲染树的图层树（在第一章“图层树”中提到过）。使用这个树状结构，渲染服务对动画的每一帧做出如下工作。</p>
<p>对所有的图层属性计算中间值，设置<font color="#DC143C">OpenGL</font>几何形状（纹理化的三角形）来执行渲染,在屏幕上渲染可见的三角形。所以一共有六个阶段；最后两个阶段在动画过程中不停地重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你真正只能控制前两个阶段：布局和显示。Core Animation框架在内部处理剩下的事务，你也控制不了它。<br>这并不是个问题，因为在布局和显示阶段，你可以决定哪些由CPU执行，哪些交给GPU去做。那么改如何判断呢？</p>
<h3 id="GPU相关的操作"><a href="#GPU相关的操作" class="headerlink" title="GPU相关的操作"></a>GPU相关的操作</h3><p>GPU为一个具体的任务做了优化：它用来采集图片和形状（三角形），运行变换，应用纹理和混合然后把它们输送到屏幕上。现代iOS设备上可编程的GPU在这些操作的执行上又很大的灵活性，但是Core Animation并没有暴露出直接的接口。除非你想绕开Core Animation并编写你自己的<font color="#DC143C">OpenGL</font>着色器，从根本上解决硬件加速的问题，那么剩下的所有都还是需要在CPU的软件层面上完成。</p>
<p>宽泛的说，大多数CALayer的属性都是用GPU来绘制。比如如果你设置图层背景或者边框的颜色，那么这些可以通过着色的三角板实时绘制出来。如果对一个contents属性设置一张图片，然后裁剪它 - 它就会被纹理的三角形绘制出来，而不需要软件层面做任何绘制。</p>
<p>但是有一些事情会降低（基于GPU）图层绘制，比如。<br>太多的几何结构 - 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数（见本章后续“CPU相关操作”）</p>
<p>重绘 - 主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多。</p>
<p>离屏绘制 - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。</p>
<p>过大的图片 - 如果视图绘制超出GPU支持的<font color="#DC143C">2048x2048</font>或者<font color="#DC143C">4096x4096</font>尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。</p>
<h3 id="CPU相关的操作"><a href="#CPU相关的操作" class="headerlink" title="CPU相关的操作"></a>CPU相关的操作</h3><p>大多数工作在Core Animation的CPU都发生在动画开始之前。这意味着它不会影响到帧率，所以很好，但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。</p>
<p>以下CPU的操作都会延迟动画的开始时间：</p>
<p>布局计算 - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应该是比老版的自动调整逻辑加强了CPU的工作。</p>
<p>视图懒加载 - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示（见后续“IO相关操作”），都会比<font color="#DC143C">CPU</font>正常操作慢得多。</p>
<p>Core Graphics绘制 - 如果对视图实现了<font color="#DC143C">-drawRect:</font>方法，或者<font color="#DC143C">CALayerDelegate</font>的<font color="#DC143C">-drawLayer:inContext:</font>方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core AnimationCore 必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。</p>
<p>解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片（14章“图片IO”会更详细讨论）。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用UIImageView）或者把它绘制到<font color="#DC143C">Core Graphics</font>中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。</p>
<p>当图层被成功打包，发送到渲染服务器之后，CPU仍然要做如下工作：为了显示屏幕上的图层，Core Animation必须对渲染树种的每个可见图层通过<font color="#DC143C">OpenGL</font>循环转换成纹理三角板。由于GPU并不知晓Core Animation图层的任何结构，所以必须要由CPU做这些事情。这里CPU涉及的工作和图层个数成正比，所以如果在你的层级关系中有太多的图层，就会导致CPU没一帧的渲染，即使这些事情不是你的应用程序可控的。</p>
<p>IO相关操作<br> 还有一项没涉及的就是IO相关工作。上下文中的IO（输入/输出）指的是例如闪存或者网络接口的硬件访问。一些动画可能需要从山村（甚至是远程URL）来加载。一个典型的例子就是两个视图控制器之间的过渡效果，这就需要从一个nib文件或者是它的内容中懒加载，或者一个旋转的图片，可能在内存中尺寸太大，需要动态滚动来加载。</p>
<p> IO比内存访问更慢，所以如果动画涉及到IO，就是一个大问题。总的来说，这就需要使用聪敏但尴尬的技术，也就是多线程，缓存和投机加载（提前加载当前不需要的资源，但是之后可能需要用到）。这些技术将会在第14章中讨论。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS中的单例]]></title>
      <url>http://yoursite.com/2014/08/20/2014/iOS%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。<font color="#dd0000">确保某个类有且只有一个对象的场景</font><br></p>
<p>一般情况下的写法(不严谨的写法)<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Singleton</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">+(<span class="keyword">instancetype</span>) shareInstance;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"Singleton.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Singleton</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> Singleton* _instance = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">+(<span class="keyword">instancetype</span>) shareInstance&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        _instance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _instance;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>看看使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"Singleton.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">// 看看打印的结果是不同一个对象</span></div><div class="line">        Singleton* obj1 = [Singleton shareInstance];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj1 = %@."</span>, obj1);</div><div class="line"></div><div class="line">        Singleton* obj2 = [Singleton shareInstance];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj2 = %@."</span>, obj2);</div><div class="line"></div><div class="line">        Singleton* obj3 = [[Singleton alloc] init];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj3 = %@."</span>, obj3);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出的结果为<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">obj1 = &lt;Singleton: <span class="number">0x1001086e0</span>&gt;.</div><div class="line">obj2 = &lt;Singleton: <span class="number">0x1001086e0</span>&gt;.</div><div class="line">obj3 = &lt;Singleton: <span class="number">0x100103940</span>&gt;.</div></pre></td></tr></table></figure></p>
<p>可以看出同一种创建的方式<font color="#dd0000">shareInstance</font><br>得到的是同一个实例对象，使用不同的创建方式<font color="#dd0000">alloc</font><br>和<font color="#dd0000">init</font><br>就产生了不同的对象。那么问题就来了，我们通过不同的途径得到不同的对象，显然是不行的。我们必须要确保对象的唯一性，所以我们就需要封锁用户通过<font color="#dd0000">alloc</font><br>和<font color="#dd0000">init</font><br>以<font color="#dd0000">copy</font><br>来构造对象这条道路。</p>
<p>我们知道，创建对象的步骤分为申请内存<font color="#dd0000">alloc</font><br>、初始化<font color="#dd0000">init</font><br>这两个步骤，我们要确保对象的唯一性，因此在第一步这个阶段我们就要拦截它。当我们调用<font color="#dd0000">alloc</font><br>方法时，oc内部会调用<font color="#dd0000">allocWithZone</font><br>这个方法来申请内存，我们覆写这个方法，然后在这个方法中调用<font color="#dd0000">shareInstance</font><br>方法返回单例对象，这样就可以达到我们的目的。拷贝对象也是同样的原理，覆写<font color="#dd0000">copyWithZone</font><br>方法，然后在这个方法中调用<font color="#dd0000">shareInstance</font><br>方法返回单例对象</p>
<p>写法如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"Singleton.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Singleton</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> Singleton* _instance = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">+(<span class="keyword">instancetype</span>) shareInstance&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        _instance = [[<span class="keyword">super</span> allocWithZone:<span class="literal">NULL</span>] init];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> _instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 防止copy创建新的对象</span></div><div class="line">+(<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone&#123;</div><div class="line">    <span class="keyword">return</span> [Singleton shareInstance];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 防止copy创建新的对象</span></div><div class="line">-(<span class="keyword">id</span>)copyWithZone:(<span class="keyword">struct</span> _NSZone *)zone&#123;</div><div class="line">    <span class="keyword">return</span> [Singleton shareInstance];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>看看打印结果如何<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"Singleton.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        Singleton* obj1 = [Singleton shareInstance];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj1 = %@."</span>, obj1);</div><div class="line"></div><div class="line">        Singleton* obj2 = [Singleton shareInstance];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj2 = %@."</span>, obj2);</div><div class="line"></div><div class="line">        Singleton* obj3 = [[Singleton alloc] init];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj3 = %@."</span>, obj3);</div><div class="line"></div><div class="line">        Singleton* obj4 = [[Singleton alloc] init];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj4 = %@."</span>, [obj4 <span class="keyword">copy</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">obj1 = &lt;Singleton: <span class="number">0x100108720</span>&gt;.</div><div class="line">obj2 = &lt;Singleton: <span class="number">0x100108720</span>&gt;.</div><div class="line">obj3 = &lt;Singleton: <span class="number">0x100108720</span>&gt;.</div><div class="line">obj4 = &lt;Singleton: <span class="number">0x100108720</span>&gt;.</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS按钮点击热区的扩大]]></title>
      <url>http://yoursite.com/2014/08/10/2014/iOS%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%E7%83%AD%E5%8C%BA%E7%9A%84%E6%89%A9%E5%A4%A7/</url>
      <content type="html"><![CDATA[<p>经常会遇到这种情况，有些app的删除，展开或着其他按钮设计的图标看上去很小，给过来的icon的资源图片也很小，搭建页面时，按照标注尺寸布局，完成之后确发现。按钮太小无法点击响应,体验很差。 有两个办法来解决这个问题。</p>
<p>方法一<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    <span class="built_in">CGFloat</span> margin = <span class="number">20</span>;</div><div class="line">    <span class="built_in">CGRect</span> hitRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span> - margin,<span class="number">0</span> - margin, <span class="keyword">self</span>.bounds.size.width + <span class="number">2</span> * margin, <span class="keyword">self</span>.bounds.size.height + <span class="number">2</span> * margin);</div><div class="line">    returnCGRectContainsPoint(hitRect, point) ?<span class="keyword">self</span> : <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法二<br>自定义一个<code>CustomButtion</code> 重写<code>-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)even</code>  方法。自己的按钮继承这个<code>CustomButtion</code><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span>*)event&#123;</div><div class="line">    <span class="built_in">CGRect</span> bounds = <span class="keyword">self</span>.bounds;</div><div class="line">    <span class="comment">//若原热区小于44x44，则放大热区，否则保持原大小不变</span></div><div class="line">    <span class="built_in">CGFloat</span> widthDelta = MAX(<span class="number">44.0</span> - bounds.size.width, <span class="number">0</span>);</div><div class="line">    <span class="built_in">CGFloat</span> heightDelta = MAX(<span class="number">44.0</span> - bounds.size.height, <span class="number">0</span>);</div><div class="line">    bounds = <span class="built_in">CGRectInset</span>(bounds, <span class="number">-0.5</span> * widthDelta, <span class="number">-0.5</span> * heightDelta);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(bounds, point);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>方法三<br>给<code>UIButtion</code>创建一个<code>Category</code><br>.h<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIButton</span> (<span class="title">EnlargeEdge</span>)</span></div><div class="line">- (<span class="keyword">void</span>)setEnlargeEdge:(<span class="built_in">CGFloat</span>) size;</div><div class="line">- (<span class="keyword">void</span>)setEnlargeEdgeWithTop:(<span class="built_in">CGFloat</span>)top right:(<span class="built_in">CGFloat</span>)right bottom:(<span class="built_in">CGFloat</span>)bottom left:(<span class="built_in">CGFloat</span>)left;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>.m<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIButton+EnlargeEdge.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIButton</span> (<span class="title">EnlargeEdge</span>)</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> topNameKey;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> rightNameKey;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> bottomNameKey;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">char</span> leftNameKey;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setEnlargeEdge:(<span class="built_in">CGFloat</span>) size&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;topNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:size], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;rightNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:size], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;bottomNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:size], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;leftNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:size], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setEnlargeEdgeWithTop:(<span class="built_in">CGFloat</span>) top right:(<span class="built_in">CGFloat</span>) right bottom:(<span class="built_in">CGFloat</span>) bottom left:(<span class="built_in">CGFloat</span>) left&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;topNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:top], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;rightNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:right], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;bottomNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:bottom], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;leftNameKey, [<span class="built_in">NSNumber</span> numberWithFloat:left], OBJC_ASSOCIATION_COPY_NONATOMIC);</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">CGRect</span>)enlargedRect&#123;</div><div class="line">    <span class="built_in">NSNumber</span>* topEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;topNameKey);</div><div class="line">    <span class="built_in">NSNumber</span>* rightEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;rightNameKey);</div><div class="line">    <span class="built_in">NSNumber</span>* bottomEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;bottomNameKey);</div><div class="line">    <span class="built_in">NSNumber</span>* leftEdge = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;leftNameKey);</div><div class="line">    <span class="keyword">if</span> (topEdge &amp;&amp; rightEdge &amp;&amp; bottomEdge &amp;&amp; leftEdge)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(<span class="keyword">self</span>.bounds.origin.x - leftEdge.floatValue,</div><div class="line">        <span class="keyword">self</span>.bounds.origin.y - topEdge.floatValue,</div><div class="line">        <span class="keyword">self</span>.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue,</div><div class="line">        <span class="keyword">self</span>.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.bounds;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    <span class="built_in">CGRect</span> rect = [<span class="keyword">self</span> enlargedRect];</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectEqualToRect</span>(rect, <span class="keyword">self</span>.bounds))&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> pointInside:point withEvent:event];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(rect, point) ? <span class="literal">YES</span> : <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">UIView</span>*)hitTest:(<span class="built_in">CGPoint</span>) point withEvent:(<span class="built_in">UIEvent</span>*) event&#123;</div><div class="line">    <span class="built_in">CGRect</span> rect = [<span class="keyword">self</span> enlargedRect];</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectEqualToRect</span>(rect, <span class="keyword">self</span>.bounds))&#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(rect, point) ? <span class="keyword">self</span> : <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>原理<br>利用 <code>objective-c</code> 中的 <code>objc_setAssociatedObject</code> 來記錄要變大的範圍，<code>objc_setAssociatedObject</code> 是 <code>objective-c runtime library</code> 裡面的 <code>function</code>，需要<code>#import &lt;objc/runtime.h&gt;</code><br>最后，最重要的是去覆盖 <code>- (UIView) hitTest:(CGPoint) point withEvent:(UIEvent) event</code>用新设定的 Rect 来当着点击范围。</p>
<p>使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[enlargeButton setEnlargeEdge:<span class="number">20.0</span>];</div><div class="line">[enlargeButton setEnlargeEdgeWithTop:<span class="number">20</span> right:<span class="number">20</span> bottom:<span class="number">20</span> left:<span class="number">10</span>];</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[子View超出父View范围无法响应]]></title>
      <url>http://yoursite.com/2014/08/04/2014/%E5%AD%90View%E8%B6%85%E5%87%BA%E7%88%B6View%E8%8C%83%E5%9B%B4%E6%97%A0%E6%B3%95%E5%93%8D%E5%BA%94/</url>
      <content type="html"><![CDATA[<p>需要在UIView中实现下面的方法，这样UIButton超出的部分就可以点击了。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="built_in">UIView</span> *result = [<span class="keyword">super</span> hitTest:point withEvent:event];</div><div class="line">    <span class="built_in">CGPoint</span> buttonPoint = [<span class="keyword">self</span>.button convertPoint:point fromView:<span class="keyword">self</span>];</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.button pointInside:buttonPoint withEvent:event]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.button;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[指定View倒角位置]]></title>
      <url>http://yoursite.com/2014/07/23/2014/%E6%8C%87%E5%AE%9AView%E5%80%92%E8%A7%92%E4%BD%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>如果需要将UIView的4个角全部都为圆角，做法相当简单，只需设置其Layer的cornerRadius属性即可（项目需要使用QuartzCore框架）。而若要指定某几个角（小于4）为圆角而别的不变时，这种方法就不好用了。</p>
<p>方法一<br>UIBezierPath<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">120</span>, <span class="number">10</span>, <span class="number">80</span>, <span class="number">80</span>)];</div><div class="line">view2.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">[<span class="keyword">self</span>.view addSubview:view2];</div><div class="line"><span class="built_in">UIBezierPath</span> *maskPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:view2.bounds byRoundingCorners:<span class="built_in">UIRectCornerBottomLeft</span> | <span class="built_in">UIRectCornerBottomRight</span> cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">10</span>, <span class="number">10</span>)];</div><div class="line"><span class="built_in">CAShapeLayer</span> *maskLayer = [[<span class="built_in">CAShapeLayer</span> alloc] init];</div><div class="line">maskLayer.frame = view2.bounds;</div><div class="line">maskLayer.path = maskPath.CGPath;</div><div class="line">view2.layer.mask = maskLayer;</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">byRoundingCorners:<span class="built_in">UIRectCornerBottomLeft</span> | <span class="built_in">UIRectCornerBottomLeft</span></div></pre></td></tr></table></figure>
<p>而 <code>UIRectCornerBottomLeft</code> <code>UIRectCornerBottomLeft</code>  两个参数是属于<code>UIRectCorner</code>类型的。用来指定需要倒角的位置，<code>UIRectCorner</code>类型包含的参数有</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIRectCornerTopLeft</span>       <span class="comment">// 顶部左角</span></div><div class="line"><span class="built_in">UIRectCornerTopRight</span>      <span class="comment">// 顶部右角</span></div><div class="line"><span class="built_in">UIRectCornerBottomLeft</span>    <span class="comment">// 底部左角</span></div><div class="line"><span class="built_in">UIRectCornerBottomRight</span>   <span class="comment">// 底部右角</span></div><div class="line"><span class="built_in">UIRectCornerAllCorners</span>    <span class="comment">// 所有角</span></div></pre></td></tr></table></figure>
<p>方法二<br>直接绘制<br>h<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> addRoundedRectToPath(<span class="built_in">CGContextRef</span> context, <span class="built_in">CGRect</span> rect, <span class="keyword">float</span> radius, <span class="keyword">int</span> roundedCornerPosition)&#123;</div><div class="line"></div><div class="line">    <span class="comment">// all corners rounded</span></div><div class="line">    <span class="comment">//  CGContextMoveToPoint(context, rect.origin.x, rect.origin.y + radius);</span></div><div class="line">    <span class="comment">//  CGContextAddLineToPoint(context, rect.origin.x, rect.origin.y + rect.size.height - radius);</span></div><div class="line">    <span class="comment">//  CGContextAddArc(context, rect.origin.x + radius, rect.origin.y + rect.size.height - radius,</span></div><div class="line">    <span class="comment">//                  radius, M_PI / 4, M_PI / 2, 1);</span></div><div class="line">    <span class="comment">//  CGContextAddLineToPoint(context, rect.origin.x + rect.size.width - radius,</span></div><div class="line">    <span class="comment">//                          rect.origin.y + rect.size.height);</span></div><div class="line">    <span class="comment">//  CGContextAddArc(context, rect.origin.x + rect.size.width - radius,</span></div><div class="line">    <span class="comment">//                  rect.origin.y + rect.size.height - radius, radius, M_PI / 2, 0.0f, 1);</span></div><div class="line">    <span class="comment">//  CGContextAddLineToPoint(context, rect.origin.x + rect.size.width, rect.origin.y + radius);</span></div><div class="line">    <span class="comment">//  CGContextAddArc(context, rect.origin.x + rect.size.width - radius, rect.origin.y + radius,</span></div><div class="line">    <span class="comment">//                  radius, 0.0f, -M_PI / 2, 1);</span></div><div class="line">    <span class="comment">//  CGContextAddLineToPoint(context, rect.origin.x + radius, rect.origin.y);</span></div><div class="line">    <span class="comment">//  CGContextAddArc(context, rect.origin.x + radius, rect.origin.y + radius, radius,</span></div><div class="line">    <span class="comment">//                  -M_PI / 2, M_PI, 1);</span></div><div class="line"></div><div class="line">    <span class="comment">// top left</span></div><div class="line">    <span class="keyword">if</span> (roundedCornerPosition == <span class="number">1</span>) &#123;</div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(context, rect.origin.x, rect.origin.y + radius);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, rect.origin.x, rect.origin.y + rect.size.height - radius);</div><div class="line">        <span class="built_in">CGContextAddArc</span>(context, rect.origin.x + radius, rect.origin.y + rect.size.height - radius,</div><div class="line">        radius, M_PI / <span class="number">4</span>, M_PI / <span class="number">2</span>, <span class="number">1</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, rect.origin.x + rect.size.width,</div><div class="line">        rect.origin.y + rect.size.height);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, rect.origin.x + rect.size.width, rect.origin.y);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, rect.origin.x, rect.origin.y);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// bottom left</span></div><div class="line">    <span class="keyword">if</span> (roundedCornerPosition == <span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(context, rect.origin.x, rect.origin.y);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, rect.origin.x, rect.origin.y + rect.size.height);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, rect.origin.x + rect.size.width,</div><div class="line">        rect.origin.y + rect.size.height);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, rect.origin.x + rect.size.width, rect.origin.y);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, rect.origin.x + radius, rect.origin.y);</div><div class="line">        <span class="built_in">CGContextAddArc</span>(context, rect.origin.x + radius, rect.origin.y + radius, radius,</div><div class="line">        -M_PI / <span class="number">2</span>, M_PI, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// you can add the other corners here</span></div><div class="line"></div><div class="line">    <span class="built_in">CGContextClosePath</span>(context);</div><div class="line">    <span class="built_in">CGContextRestoreGState</span>(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">UIImage</span> *)setImage&#123;</div><div class="line"></div><div class="line">    <span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"my_image.png"</span>];</div><div class="line">    <span class="keyword">int</span> w = img.size.width;</div><div class="line">    <span class="keyword">int</span> h = img.size.height;</div><div class="line"></div><div class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, w, h, <span class="number">8</span>, <span class="number">4</span> * w, colorSpace, kCGImageAlphaPremultipliedFirst);</div><div class="line"></div><div class="line">    <span class="built_in">CGContextBeginPath</span>(context);</div><div class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, w, h);</div><div class="line"></div><div class="line">    addRoundedRectToPath(context, rect, <span class="number">50</span>, <span class="number">1</span>);</div><div class="line">    <span class="built_in">CGContextClosePath</span>(context);</div><div class="line">    <span class="built_in">CGContextClip</span>(context);</div><div class="line">    </div><div class="line">    <span class="built_in">CGContextDrawImage</span>(context, rect, img.CGImage);</div><div class="line"></div><div class="line">    <span class="built_in">CGImageRef</span> imageMasked = <span class="built_in">CGBitmapContextCreateImage</span>(context);</div><div class="line">    <span class="built_in">CGContextRelease</span>(context);</div><div class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">    [img release];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="built_in">UIImage</span> imageWithCGImage:imageMasked];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS控制器生命周期]]></title>
      <url>http://yoursite.com/2014/07/15/2014/iOS%E6%8E%A7%E5%88%B6%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<h3 id="UIViewController的生命周期和属性"><a href="#UIViewController的生命周期和属性" class="headerlink" title="UIViewController的生命周期和属性"></a>UIViewController的生命周期和属性</h3><p> 要了解<code>UIViewController</code>，先要弄清楚其生命周期。在面向对象的语言中，是对象，就一定要有生命周期，UIViewController也不例外，生命周期管理Controller的作用范围和时间，也管理其内对象的作用范围和时间。首先，UIViewController中与其生命周期有关的几个函数如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类的初始化方法  </span></div><div class="line">+ (<span class="keyword">void</span>)initialize;  </div><div class="line"><span class="comment">//对象初始化方法  </span></div><div class="line">- (<span class="keyword">instancetype</span>)init;  </div><div class="line"><span class="comment">//从归档初始化  </span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder;  </div><div class="line"><span class="comment">//加载视图  </span></div><div class="line">-(<span class="keyword">void</span>)loadView;  </div><div class="line"><span class="comment">//将要加载视图  </span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad;  </div><div class="line"><span class="comment">//将要布局子视图  </span></div><div class="line">-(<span class="keyword">void</span>)viewWillLayoutSubviews;  </div><div class="line"><span class="comment">//已经布局子视图  </span></div><div class="line">-(<span class="keyword">void</span>)viewDidLayoutSubviews;  </div><div class="line"><span class="comment">//内存警告  </span></div><div class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning;  </div><div class="line"><span class="comment">//已经展示  </span></div><div class="line">-(<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//将要展示  </span></div><div class="line">-(<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//将要消失  </span></div><div class="line">-(<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//已经消失  </span></div><div class="line">-(<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//被释放  </span></div><div class="line">-(<span class="keyword">void</span>)dealloc;</div></pre></td></tr></table></figure></p>
<p>上面这么多的函数，乍一看什么复杂，其实关系什么明朗，除了initialize,init和initWithCoder不是存在所有对象的声明周期中，其他函数都会在UIViewController的声明周期中有序的被调用。那么具体的调用顺序是怎样的呢，最好的办法是实践一下。这是一个ViewController完整的声明周期，其实里面还有好多地方需要我们注意一下：</p>
<p>1：<code>initialize</code>函数并不会每次创建对象都调用，只有在这个类第一次创建对象时才会调用，做一些类的准备工作，再次创建这个类的对象，initalize方法将不会被调用，对于这个类的子类，如果实现了initialize方法，在这个子类第一次创建对象时会调用自己的initalize方法，之后不会调用，如果没有实现，那么它的父类将替它再次调用一下自己的initialize方法，以后创建也都不会再调用。因此，如果我们有一些和这个相关的全局变量，可以在这里进行初始化。<br>2：<code>init</code>方法和initCoder方法相似，只是被调用的环境不一样，如果用代码进行初始化，会调用init，从nib文件或者归档进行初始化，会调用initCoder。<br>3：<code>loadView</code>方法是开始加载视图的起始方法，除非手动调用，否则在ViewController的生命周期中没特殊情况只会被调用一次。<br>4：<code>viewDidLoad</code>方法是我们最常用的方法的，类中成员对象和变量的初始化我们都会放在这个方法中，在类创建后，无论视图的展现或消失，这个方法也是只会在将要布局时调用一次。<br>5：<code>viewWillAppare</code>：视图将要展现时会调用。<br>6：<code>viewWillLayoutSubviews</code>：在viewWillAppare后调用，将要对子视图进行布局。<br>7：<code>viewDidLayoutSubviews</code>：已经布局完成子视图。<br>8：<code>viewDidAppare</code>：视图完成显示时调用。<br>9：<code>viewWillDisappare</code>：视图将要消失时调用。<br>10：<code>viewDidDisappare</code>：视图已经消失时调用。<br>11：<code>dealloc</code>：controller被释放时调用。</p>
<p>注意：经过测试，从nib文件加载的controller，只要不释放，在每次viewWillAppare时都会调用layoutSubviews方法，有时甚至会在viewDidAppare后在调用一次layoutSubviews，而重点是从代码加载的则只会在开始调用一次，之后都不会，所以注意，在layoutSubviews中写相关的布局代码十分危险。</p>
<h3 id="从storyBoard加载UIViewController实例的传值陷阱"><a href="#从storyBoard加载UIViewController实例的传值陷阱" class="headerlink" title="从storyBoard加载UIViewController实例的传值陷阱"></a>从storyBoard加载UIViewController实例的传值陷阱</h3><p>我们知道，当我们从StoryBoard中加载ViewController时，我们在Controller中拖拽的视图是可以被初始化的，这里面有一点需要我们注意，如果我们需要向controller中视图进行传值设置，通过以下方法得到的Controller中，视图还没有被初始化创建出来：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ViewController2 * viewController2 = [[<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:[<span class="built_in">NSBundle</span> mainBundle]] instantiateViewControllerWithIdentifier:<span class="string">@"ViewController2"</span>];</div></pre></td></tr></table></figure></p>
<p>我们可以在ViewController2的storyBoard中拉一个label，然后关联到头文件中，如下打印，会发现我们得到controller时，里面的视图对象并没有进行创建:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ViewController2 * viewController2 = [[<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:[<span class="built_in">NSBundle</span> mainBundle]] instantiateViewControllerWithIdentifier:<span class="string">@"ViewController2"</span>];  </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,viewController2.label);  </div><div class="line">[<span class="keyword">self</span> presentViewController:viewController2 animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></p>
<p>可以想象，如果我们这时候需要对label进行一些属性设置，必然失败。有人提出可以在创建后，手动调以下loadView方法，我们试一下，结果如下：<br>可以看到，手动调用loadView后，label是被创建了出来，但是暴漏了一个更严重的问题，系统不在调用ViewDidLoad方法，这是十分有风险的，因为我们大部分的初始化代码都会放在这个方法里，所以手动调用loadView是一种错误的方法，apple文档声明对于loadView方法，我们从来都不要手动直接调用，那么我们如何实现创建后对成员对象进行传值设置呢，iOS9中增加了这样一个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadViewIfNeeded <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</div></pre></td></tr></table></figure></p>
<p>这个方法十分有用，调用这个方法，会将视图创建出来，并且不会忽略viewDidLoad的调用。<br>在iOS9中，UIViewController还增加了下面一个布尔值的属性，可以同来判断controller的view是否已经加载完成<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *viewIfLoaded <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</div></pre></td></tr></table></figure></p>
<h3 id="UIViewController与StroyBoard的相关相互方法"><a href="#UIViewController与StroyBoard的相关相互方法" class="headerlink" title="UIViewController与StroyBoard的相关相互方法"></a>UIViewController与StroyBoard的相关相互方法</h3><p>对于ViewConroller，我们一般有两种方式创建，一种是用纯代码的方式，一种是与StoryBoard关联，在UIViewController中，有许多方法方便我们与StoryBoard进行交互联系。</p>
<ul>
<li>ViewController直接在StoryBoard中进行跳转的传值<br>在StoryBoard中进行界面跳转是十分方便的，我们在StoryBoard中拉入两个ViewController，在一个上面添加一个按钮，点住按钮按住control，将鼠标拉到第二个controller上，会出现如下的跳转选项：<br>我们选择一个后，就会在两个controller之间建立一个跳转连接。当我们运行点击按钮后，会自动从第一个controller跳转到第二个controller。在UIViewController中有如下方法可以对是否跳转进行控制：<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)shouldPerformSegueWithIdentifier:(<span class="built_in">NSString</span> *)identifier sender:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个方法如果返回NO，自动跳转将不能进行，会被拒绝，需要注意的是，这个方法只会在自动的跳转时被调用，我们手动使用代码跳转StoryBoard中的连接关系时是不会被调用的，我们后面讨论。<br>在执行过上述方法后，如果返回YES，系统还会在执行如下一个方法，作为跳转前的准备，我们可以在这个方法中进行一些传值操作，这个方法无论使我们手动进行跳转还是storyboard中自动跳转，都会被执行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure></p>
<p>sugur对象中封装了相关的ViewController，可以使用segue.destinationViewController获取。<br>segue在StoryBoard中除了用来自动正向跳转外，我们还可以进行反向的跳转，类似pop和dismiss方法，这种segue被称为unwind sugue。例如，我们有一个controller1和一个controllert2，要使用unwind segue从2返回1，我们需要在2中实现如下格式的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)unwindSegueToViewController:(<span class="built_in">UIStoryboardSegue</span> *)segue &#123;  </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"unwindSegueToViewController"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法中的返回值必须为IBAction，参数必须是UIStoryboardSegue，方法名我们可以自己定义，之后在StoryBoard中的ViewController1中的Exit选项中，我们会发现多了一个这样的方法：<br>这样，当我们点击viewController2中的按钮时，就会返回到我们第一个ViewController1中了。<br>当然，在使用unwind segue方法时，也是会有一些回调帮助我们进行跳转前的设置和传值，UIViewController如下方法会在跳转前调用，返回NO，则不能进行跳转：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)canPerformUnwindSegueAction:(SEL)action fromViewController:(<span class="built_in">UIViewController</span> *)fromViewController withSender:(<span class="keyword">id</span>)sender&#123;  </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"canPerformUnwindSegueAction"</span>);  </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后会执行我们自定义的unwindSegue方法，这个方法中我们可以什么都不写，模式是会进行跳转的。</p>
<ul>
<li>使用代码跳转Storyboard中的controller<br>我们除了在Storyboard中拉拉扯扯可以进行控制器的跳转外，我们也可以使用代码来跳转Storyboard中segue连接关系。<br>在Storyboard中两个控制器间建立一个segue联系，我们可以取一个名字：在触发跳转的方法中，使用如下方法进行跳转，这里面的参数id就是我们取得segue的id：</li>
</ul>
<ul>
<li>(void)performSegueWithIdentifier:(NSString *)identifier sender:(nullable id)sender NS_AVAILABLE_IOS(5_0);<br>下面三个属性我们可以获取controller的nib文件名，其storyBoard和其Bundle:<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *nibName;    </div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSBundle</span> *nibBundle;   </div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIStoryboard</span> *storyboard <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="UIViewController之间的一些从属关系"><a href="#UIViewController之间的一些从属关系" class="headerlink" title="UIViewController之间的一些从属关系"></a>UIViewController之间的一些从属关系</h3><p>这部分的内容和方法可能我们接触用到的并不多，但是在某些情况下，使用这些方法可以大大的方便某些逻辑。</p>
<p> parentViewController<br> UIViewController里面封装了一个数组，可以存放其子ViewController，系统中使用的例子就是导航和tabBar这类的控制器，我们使用如下方法可以直接访问这些父的controller：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>,<span class="keyword">readonly</span>) <span class="built_in">UIViewController</span> *parentViewController;</div></pre></td></tr></table></figure></p>
<p>模态跳转中Controller的从属<br>在我们进行控制器的跳转时，只要控制器没有被释放，我们都可以顺藤摸瓜的找到它，使用如下两个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//其所present的contller，比如，A和B两个controller，A跳转到B，那么A的presentedViewController就是B  </span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIViewController</span> *presentedViewController  <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);  </div><div class="line"><span class="comment">//和上面的方法刚好相反，比如，A和B两个controller，A跳转到B，那么B的presentingViewController就是A  </span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIViewController</span> *presentingViewController <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure></p>
<p>了解了上面方法我们可以知道，对于反向传值这样的问题，我们根本不需要代理，block，通知等这样的复杂手段，只需要获取跳转到它的Controller，直接设置即可。举个例子，我们需要在第二个界面消失后，改变第一个界面的颜色，在第二个controller中只需要下面的代码即可实现 ：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.presentingViewController.view.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:arc4random()%<span class="number">255</span>/<span class="number">255.0</span> green:arc4random()%<span class="number">255</span>/<span class="number">255.0</span> blue:arc4random()%<span class="number">255</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];  </div><div class="line">[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></p>
<p>UIViewController的模态跳转及动画特效<br>单纯的UIViewController中，我们使用最多的是如下的两个方法，一个向前跳转，一个向后返回:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)presentViewController:(<span class="built_in">UIViewController</span> *)viewControllerToPresent animated: (<span class="built_in">BOOL</span>)flag completion:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="keyword">void</span>))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);  </div><div class="line">- (<span class="keyword">void</span>)dismissViewControllerAnimated: (<span class="built_in">BOOL</span>)flag completion: (<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="keyword">void</span>))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure></p>
<p>从方法中，我们可以看到，有animated这个参数，来选择是否有动画特效，默认的动画特效是像抽屉一样从手机屏幕的下方向上弹起，当然，这个效果我们可以进行设置，UIViewController有如下一个属性来设置动画特效：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">UIModalTransitionStyle</span> modalTransitionStyle <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</div></pre></td></tr></table></figure></p>
<p>注意，这个要设置的是将要跳转到的controller，枚举如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIModalTransitionStyle</span>) &#123;  </div><div class="line">    <span class="built_in">UIModalTransitionStyleCoverVertical</span> = <span class="number">0</span>,<span class="comment">// 默认的，从下向上覆盖  </span></div><div class="line">    <span class="built_in">UIModalTransitionStyleFlipHorizontal</span> ,  <span class="comment">// 水平翻转  </span></div><div class="line">    <span class="built_in">UIModalTransitionStyleCrossDissolve</span>,    <span class="comment">// 溶解  </span></div><div class="line">    <span class="built_in">UIModalTransitionStylePartialCurl</span> ,     <span class="comment">// 从下向上翻页  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>除了跳转的效果，还有一个属性可以设置弹出的controler的填充效果，但是这个属性只在pad上有效，在iphone上无效，都是填充到整个屏幕：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">UIModalPresentationStyle</span> modalPresentationStyle <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2);  </div><div class="line"><span class="comment">// 枚举如下  </span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIModalPresentationStyle</span>) &#123;  </div><div class="line">    <span class="built_in">UIModalPresentationFullScreen</span> = <span class="number">0</span>,                   <span class="comment">// 填充整个屏幕  </span></div><div class="line">    <span class="built_in">UIModalPresentationPageSheet</span>,                        <span class="comment">// 留下状态栏  </span></div><div class="line">    <span class="built_in">UIModalPresentationFormSheet</span>,                        <span class="comment">// 四周留下变暗的空白  </span></div><div class="line">    <span class="built_in">UIModalPresentationCurrentContext</span>,                   <span class="comment">// 和跳转到它的控制器保持一致  </span></div><div class="line">    <span class="built_in">UIModalPresentationCustom</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0),<span class="comment">// 自定义  </span></div><div class="line">    <span class="built_in">UIModalPresentationOverFullScreen</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),  </div><div class="line">    <span class="built_in">UIModalPresentationOverCurrentContext</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),  </div><div class="line">    <span class="built_in">UIModalPresentationPopover</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0) __TVOS_PROHIBITED,  </div><div class="line">    <span class="built_in">UIModalPresentationNone</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0) = <span class="number">-1</span>,           </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS UITableView优化]]></title>
      <url>http://yoursite.com/2014/07/07/2014/iOS%20UITableView%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="IOS之UITableView优化-可重用机制"><a href="#IOS之UITableView优化-可重用机制" class="headerlink" title="IOS之UITableView优化-可重用机制"></a>IOS之UITableView优化-可重用机制</h3><p>目的：为了做到显示和数据分离， 通过重用单元格来达到节省内存的目的<br>1.使用可重用机制创建cell（系统）<br>(1)定义可重用标识<br>(2)从可重用队列中取出cell<br>(3)若队列中无可用cell，利用alloc，init新建cell</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *reuseIndentifier = <span class="string">@"MyCell"</span>;  </div><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:reuseIndentifier];  </div><div class="line"><span class="keyword">if</span> (!cell) &#123;  </div><div class="line">    cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:reuseIndentifier];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.原理<br>在UITableView的头文件中有visibleCells，存放当前显示的的cells<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>)<span class="built_in">NSArray</span>&lt;__kindofUITableViewCell *&gt; *visibleCells;</div></pre></td></tr></table></figure></p>
<p>当需要更新显示数据时，dequeueReusableCellWithIdentifier会先在可重用cell队列 reusable-cell queue中返回一个cell对象，若不存在，则返回nil；<br>3.举例<br>若一共有50条数据，屏幕最多显示10个cell。<br>(1)由于初始时 reusable-cell queue为空，所以用 [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]创建10次cell，并给cell指定同样的重用标识，并且10个cell全部都加入到 visiableCells数组。<br>(2)向下拖动tableView，当cell1完全移出屏 幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。cell11加入到visiableCells，cell1移出visiableCells，cell1加入到 reusable-cell queue。<br>(3) 接着向下拖动tableView，因为 reusable-cell queue中已经有可用cell对象，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用的时候，tableView dequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。 cell1加入到visiableCells，cell1移出reusable-cell queue,cell2移出 visiableCells，cell2加入到 reusable-cell queue。</p>
<p> 4.存在的问题<br>重取出来的cell是有可能已经捆绑过数据或者加过子视图的，造成视图叠加混乱的现象<br>解决：<br>(1)删除已有数据或子视图<br>(2)放弃了重用机制，每次根据indexPath获取对应的cell返回。<br>将方法:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:reuseIndentifier];</div></pre></td></tr></table></figure></p>
<p>替换为:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView cellForRowAtIndexPath:indexPath];</div></pre></td></tr></table></figure></p>
<p>5.自定义cell的可重用机制使用<br>(1)在nib中加载MyCell这个类<br>(2)注册自定义cell的可重用标识<br>[objc] view plain copy 在CODE上查看代码片派生到我的代码片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"MyCell"</span> bundle:<span class="literal">nil</span>];   </div><div class="line">[tableView registerNib:nib forCellReuseIdentifier:reuseIdentity];</div></pre></td></tr></table></figure></p>
<p>用标识，并加入缓存池<br>(3)同上系统cell的使用</p>
<h3 id="IOS的tabViewCell的卡顿的解决方案"><a href="#IOS的tabViewCell的卡顿的解决方案" class="headerlink" title="IOS的tabViewCell的卡顿的解决方案"></a>IOS的tabViewCell的卡顿的解决方案</h3><p>1.当你下滑时候是否发现有那么一点点的卡顿现成，特别是网络不好。可以利用UIScrollViewDelegate代理很好的解决这问题<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate</div><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView</div></pre></td></tr></table></figure></p>
<p>可以识别tableview禁止或者减速滑动结束的时候进行异步加载图片</p>
<p>2.tabViewCell上面的图片透明度和圆角问题也会造成卡顿的情况<br>3.使用不透明视图：没有其他渲染效果，可以提高页面渲染速度;<br>4.不要重复创建不必要的cell：​当新cell需要被显示时，就会调用tableView:cellForRowAtIndexPath:方法获取或创建一个cell；而不可视时，它又会被释放。由此可见，同一时间只需要存在一屏幕的cell即可，不需要为每一行创建一个cell;<br>5.使用自定义的cell：默认的UITableViewCell包含了textLabel、detailTextLabel和imageView等view，然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。但是使用自定义的view，而非预定义的会明显快一些;<br>6.不要阻塞主线程：显然，主线程就只加载视图，把网络请求等耗时函数放到子线程;<br>7.自动载入更新数据：例如每次载入50条信息，那就可以在滚动到倒数第10条以内时，加载更多信息;<br>8.不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的opaque属性设为YES（默认值）;<br>9.其中的特例包括背景色，它的alpha值应该为1（例如不要使用clearColor）；图像的alpha值也应该为1，或者在画图时设为不透明;<br>10.值得一提的是，cell被重用时，它内部绘制的内容并不会被自动清除，因此你可能需要调用setNeedsDisplayInRect:或setNeedsDisplay方法。此外，在添加table cell的时候，如果不需要动画效果，最好不要使用insertRowsAtIndexPaths:withRowAnimation:方法，而是直接调用reloadData方法。因为前者会对所有indexPaths调用tableView:cellForRowAtIndexPath:方法，即便该 cell并不需要显示（不知道是不是bug），这就可能创建大量多余的cell。勘误：只是在模拟器上测试如此，真机调试时没有这种bug。<br>11.UITableViewCell包含了textLabel、detailTextLabel和imageView等view，而你还可以自定义一些视图放在它的contentView里。然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。<br>如果你的table cell包含图片，且数目较多，使用默认的UITableViewCell会非常影响性能。奇怪的是，使用自定义的view，而非预定义的view，明显会快些。当然，最佳的解决办法还是继承UITableViewCell，并在其drawRect:中自行绘制：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123; </div><div class="line">    <span class="keyword">if</span>(image) &#123; </div><div class="line">        [image drawAtPoint:imagePoint]; </div><div class="line">        <span class="keyword">self</span>.image = <span class="literal">nil</span>; </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [placeHolder drawAtPoint:imagePoint]; </div><div class="line">    &#125; </div><div class="line">    [text drawInRect:textRect withFont:fontlineBreakMode:<span class="built_in">UILineBreakModeTailTruncation</span>]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>13.不过这样一来，你会发现选中一行后，这个cell就变蓝了，其中的内容就被挡住了。最简单的方法就是将cell的selectionStyle属性设为UITableViewCellSelectionStyleNone，这样就不会被高亮了。此外还可以创建CALayer，将内容绘制到layer上，然后对cell的contentView.layer调用addSublayer:方法。这个例子中，layer并不会显著影响性能，但如果layer透明，或者有圆角、变形等效果，就会影响到绘制速度了。解决办法可参见后面的预渲染图像。<br>14.不要做多余的绘制工作,在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。<br>14.预渲染图像,你会发现即使做到了上述几点，当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕，详细做法可见。<br><a href="http://www.keakon.net/2011/07/26/利用预渲染加速iOS设备的图像显示" target="_blank" rel="external">《利用预渲染加速iOS设备的图像显示》</a><br>15.不要阻塞主线程,做到前几点后，你的table view滚动时应该足够流畅了，不过你仍可能让用户感到不爽。常见的现象就是在更新数据时，整个界面卡住不动，完全不响应用户请求。<br>出现这种现象的原因就是主线程执行了耗时很长的函数或方法，在其执行完毕前，无法绘制屏幕和响应用户请求。其中最常见的就是网络请求了，它通常都需要花费数秒的时间，而你不应该让用户等待那么久。解决办法就是使用多线程，让子线程去执行这些函数或方法。这里面还有一个学问，当下载线程数超过2时，会显著影响主线程的性能。因此在使用ASIHTTPRequest时，可以用一个NSOperationQueue来维护下载请求，并将其maxConcurrentOperationCount设为2。而NSURLRequest则可以配合GCD来实现，或者使用NSURLConnection的setDelegateQueue:方法。当然，在不需要响应用户请求时，也可以增加下载线程数，以加快下载速度：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span>*)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate &#123; <span class="keyword">if</span> (!decelerate) &#123;queue.maxConcurrentOperationCount = <span class="number">5</span>; &#125; &#125; -(<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView &#123;queue.maxConcurrentOperationCount = <span class="number">5</span>; &#125; -(<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;queue.maxConcurrentOperationCount = <span class="number">2</span>; &#125;</div></pre></td></tr></table></figure>
<p>此外，自动载入更新数据对用户来说也很友好，这减少了用户等待下载的时间。例如每次载入50条信息，那就可以在滚动到倒数第10条以内时，加载更多信息：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span>*)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cellforRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123; </div><div class="line">    <span class="comment">// update方法获取到结果后，设置updating为NO</span></div><div class="line">    <span class="keyword">if</span> (count - indexPath.row &lt; <span class="number">10</span>&amp;&amp; !updating) &#123; </div><div class="line">        updating = <span class="literal">YES</span>; [<span class="keyword">self</span> update]; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还有一点要注意的就是当图片下载完成后，如果cell是可见的，还需要更新图像：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *indexPaths = [<span class="keyword">self</span>.tableViewindexPathsForVisibleRows];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSIndexPath</span> *visibleIndexPath <span class="keyword">in</span> indexPaths) &#123;</div><div class="line">    <span class="comment">// 也可不遍历，直接与头尾相比较，看是否在中间即可。</span></div><div class="line">    <span class="keyword">if</span> (indexPath == visibleIndexPath) &#123;</div><div class="line">        MyTableViewCell *cell = (MyTableViewCell*)[<span class="keyword">self</span>.tableView cellForRowAtIndexPath:indexPath]; </div><div class="line">        cell.image = image;</div><div class="line">        [cellsetNeedsDisplayInRect:imageRect]; </div><div class="line">        <span class="keyword">break</span>; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后还是前面所说过的insertRowsAtIndexPaths:withRowAnimation:方法，插入新行需要在主线程执行，而一次插入很多行的话（例如50行），会长时间阻塞主线程。而换成reloadData方法的话，瞬间就处理完了。如果只是更新某组的话，使用reloadSection进行局部更新</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[setNeedsDisplay VS setNeedsLayout]]></title>
      <url>http://yoursite.com/2014/07/05/2014/setNeedsDisplay%20VS%20setNeedsLayout/</url>
      <content type="html"><![CDATA[<p>1.UIView的setNeedsDisplay和setNeedsLayout方法<br>首先两个方法都是异步执行的。而setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到  UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，就可以  处理子视图中的一些数据。综上所诉，setNeedsDisplay方便绘图，而layoutSubViews方便出来数据。layoutSubviews在以下情况下会被调用：</p>
<p>1、init初始化不会触发layoutSubviews。<br>2、addSubview会触发layoutSubviews。<br>3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。<br>4、滚动一个UIScrollView会触发layoutSubviews。<br>5、旋转Screen会触发父UIView上的layoutSubviews事件。<br>6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。<br>7、直接调用setLayoutSubviews。</p>
<p>drawRect在以下情况下会被调用：<br>1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).<br>2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。<br>3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。<br>4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。<br>以上1,2推荐；而3,4不提倡</p>
<p>drawRect方法使用注意点：<br>1、若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。<br>2、若使用calayer绘图，只能在drawInContext: 中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法<br>3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS运行时Runtime]]></title>
      <url>http://yoursite.com/2014/06/11/2014/iOS%E8%BF%90%E8%A1%8C%E6%97%B6Runtime/</url>
      <content type="html"><![CDATA[<h3 id="一、runtime简介"><a href="#一、runtime简介" class="headerlink" title="一、runtime简介"></a>一、runtime简介</h3><ul>
<li>RunTime简称运行时。OC就是<code>运行时机制</code>，也就是在运行时候的一些机制，其中最主要的是消息机制。</li>
<li>对于C语言，<code>函数的调用在编译的时候会决定调用哪个函数</code>。</li>
<li>对于OC的函数，属于<code>动态调用过程</code>，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>
<li>在编译阶段，OC可以<code>调用任何函数</code>，即使这个函数并未实现，只要声明过就不会报错。</li>
<li>在编译阶段，C语言调用<code>未实现的函数</code>就会报错。</li>
</ul>
<h3 id="二、runtime作用"><a href="#二、runtime作用" class="headerlink" title="二、runtime作用"></a>二、runtime作用</h3><p>1.发送消息</p>
<ul>
<li>方法调用的本质，就是让对象发送消息。</li>
<li>objc_msgSend,只有对象才能发送消息，因此以objc开头.</li>
<li>使用<code>消息机制</code>前提，必须导入#import <objc message.h=""></objc></li>
<li>消息机制简单使用</li>
</ul>
<p>消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建person对象</span></div><div class="line">Person *p = [[Person alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 调用对象方法</span></div><div class="line">[p eat];</div><div class="line"></div><div class="line"><span class="comment">// 本质：让对象发送消息</span></div><div class="line">objc_msgSend(p, <span class="keyword">@selector</span>(eat));</div><div class="line"></div><div class="line"><span class="comment">// 调用类方法的方式：两种</span></div><div class="line"><span class="comment">// 第一种通过类名调用</span></div><div class="line">[Person eat];</div><div class="line"><span class="comment">// 第二种通过类对象调用</span></div><div class="line">[[Person <span class="keyword">class</span>] eat];</div><div class="line"></div><div class="line"><span class="comment">// 用类名调用类方法，底层会自动把类名转换成类对象调用</span></div><div class="line"><span class="comment">// 本质：让类对象发送消息</span></div><div class="line">objc_msgSend([Person <span class="keyword">class</span>], <span class="keyword">@selector</span>(eat));</div></pre></td></tr></table></figure></p>
<p>2.交换方法</p>
<ul>
<li>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。</li>
<li>方式一:继承系统的类，重写方法.</li>
<li>方式二:使用runtime,交换方法.<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。</span></div><div class="line">    <span class="comment">// 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;</span></div><div class="line">    <span class="comment">// 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"123"</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">Image</span>)</span></div><div class="line"><span class="comment">// 加载分类到内存的时候调用</span></div><div class="line">+ (<span class="keyword">void</span>)load&#123;</div><div class="line">    <span class="comment">// 交换方法</span></div><div class="line">    <span class="comment">// 获取imageWithName方法地址</span></div><div class="line">    Method imageWithName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageWithName:));</div><div class="line"></div><div class="line">    <span class="comment">// 获取imageWithName方法地址</span></div><div class="line">    Method imageName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageNamed:));</div><div class="line"></div><div class="line">    <span class="comment">// 交换方法地址，相当于交换实现方式</span></div><div class="line">    method_exchangeImplementations(imageWithName, imageName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</span></div><div class="line"><span class="comment">// 既能加载图片又能打印</span></div><div class="line">+ (<span class="keyword">instancetype</span>)imageWithName:(<span class="built_in">NSString</span> *)name&#123;</div><div class="line">    <span class="comment">// 这里调用imageWithName，相当于调用imageName</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageWithName:name];</div><div class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"加载空的图片"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>3.动态添加方法</p>
<ul>
<li>开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。</li>
<li>经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。</li>
<li>简单使用<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    Person *p = [[Person alloc] init];</div><div class="line">    <span class="comment">// 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span></div><div class="line">    <span class="comment">// 动态添加方法就不会报错</span></div><div class="line">    [p performSelector:<span class="keyword">@selector</span>(eat)];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"><span class="comment">// void(*)()</span></div><div class="line"><span class="comment">// 默认方法都有两个隐式参数，</span></div><div class="line"><span class="keyword">void</span> eat(<span class="keyword">id</span> <span class="keyword">self</span>,SEL sel)&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,<span class="keyword">self</span>,<span class="built_in">NSStringFromSelector</span>(sel));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></div><div class="line"><span class="comment">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(eat)) &#123;</div><div class="line">        <span class="comment">// 动态添加eat方法</span></div><div class="line">        <span class="comment">// 第一个参数：给哪个类添加方法</span></div><div class="line">        <span class="comment">// 第二个参数：添加方法的方法编号</span></div><div class="line">        <span class="comment">// 第三个参数：添加方法的函数实现（函数地址）</span></div><div class="line">        <span class="comment">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></div><div class="line">        class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(eat), eat, <span class="string">"v@:"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>4.给分类添加属性</p>
<ul>
<li>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 给系统NSObject类动态添加属性name</span></div><div class="line">    <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    objc.name = <span class="string">@"小码哥"</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,objc.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">// 定义关联的key</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"name"</span>;</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Property</span>)</span></div><div class="line">- (<span class="built_in">NSString</span> *)name&#123;</div><div class="line">    <span class="comment">// 根据关联的key，获取关联的值。</span></div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, key);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</div><div class="line">    <span class="comment">// 第一个参数：给哪个对象添加关联</span></div><div class="line">    <span class="comment">// 第二个参数：关联的key，通过这个key获取</span></div><div class="line">    <span class="comment">// 第三个参数：关联的value</span></div><div class="line">    <span class="comment">// 第四个参数:关联的策略</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>5.字典转模型</p>
<ul>
<li>设计模型：字典转模型的第一步</li>
<li>模型属性，通常需要跟字典中的key一一对应</li>
<li>需求：能不能自动根据一个字典，生成对应的属性。</li>
<li><p>解决：提供一个分类，专门根据字典生成对应的属性字符串。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Log</span>)</span></div><div class="line"></div><div class="line"><span class="comment">// 自动打印属性字符串</span></div><div class="line">+ (<span class="keyword">void</span>)resolveDict:(<span class="built_in">NSDictionary</span> *)dict&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 拼接属性字符串代码</span></div><div class="line">    <span class="built_in">NSMutableString</span> *strM = [<span class="built_in">NSMutableString</span> string];</div><div class="line"></div><div class="line">    <span class="comment">// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</span></div><div class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 类型经常变，抽出来</span></div><div class="line">    <span class="built_in">NSString</span> *type;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFString"</span>)]) &#123;</div><div class="line">        type = <span class="string">@"NSString"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFArray"</span>)])&#123;</div><div class="line">        type = <span class="string">@"NSArray"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFNumber"</span>)])&#123;</div><div class="line">        type = <span class="string">@"int"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFDictionary"</span>)])&#123;</div><div class="line">        type = <span class="string">@"NSDictionary"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 属性字符串</span></div><div class="line">    <span class="built_in">NSString</span> *str;</div><div class="line">    <span class="keyword">if</span> ([type containsString:<span class="string">@"NS"</span>]) &#123;</div><div class="line">        str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, strong) %@ *%@;"</span>,type,key];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">        str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, assign) %@ %@;"</span>,type,key];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 每生成属性字符串，就自动换行。</span></div><div class="line">    [strM appendFormat:<span class="string">@"\n%@\n"</span>,str];</div><div class="line"></div><div class="line">    &#125;];</div><div class="line">    <span class="comment">// 把拼接好的字符串打印出来，就好了。</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strM);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>字典转模型的方式一：KVC</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Status</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)statusWithDict:(<span class="built_in">NSDictionary</span> *)dict&#123;</div><div class="line">    Status *status = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    [status setValuesForKeysWithDictionary:dict];</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。如果不一致，就会调用<code>[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]</code>报<code>key</code>找不到的错。    分析:模型中的属性和字典的key不一一对应，系统就会调用<code>setValue:forUndefinedKey:</code>报错。解决:重写对象的<code>setValue:forUndefinedKey:</code>,把系统的方法覆盖,就能继续使用KVC，字典转模型了。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>字典转模型的方式二：Runtime</li>
<li>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。</li>
<li>步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 解析Plist文件</span></div><div class="line">    <span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"status.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSDictionary</span> *statusDict = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:filePath];</div><div class="line">    <span class="comment">// 获取字典数组</span></div><div class="line">    <span class="built_in">NSArray</span> *dictArr = statusDict[<span class="string">@"statuses"</span>];</div><div class="line">    <span class="comment">// 自动生成模型的属性字符串</span></div><div class="line">    <span class="comment">// [NSObject resolveDict:dictArr[0][@"user"]];</span></div><div class="line">    _statuses = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">    <span class="comment">// 遍历字典数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> dictArr) &#123;</div><div class="line">        Status *status = [Status modelWithDict:dict];</div><div class="line">        [_statuses addObject:status];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 测试数据</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,_statuses,[_statuses[<span class="number">0</span>] user]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Model</span>)</span></div><div class="line">+ (<span class="keyword">instancetype</span>)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 思路：遍历模型中所有属性-》使用运行时</span></div><div class="line"></div><div class="line">    <span class="comment">// 0.创建对应的对象</span></div><div class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 1.利用runtime给对象中的成员属性赋值</span></div><div class="line"></div><div class="line">    <span class="comment">// class_copyIvarList:获取类中的所有成员属性</span></div><div class="line">    <span class="comment">// Ivar：成员属性的意思</span></div><div class="line">    <span class="comment">// 第一个参数：表示获取哪个类中的成员属性</span></div><div class="line">    <span class="comment">// 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</span></div><div class="line">    <span class="comment">// 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</span></div><div class="line">    <span class="comment">/* 类似下面这种写法</span></div><div class="line"></div><div class="line">    Ivar ivar;</div><div class="line">    Ivar ivar1;</div><div class="line">    Ivar ivar2;</div><div class="line">    // 定义一个ivar的数组a</div><div class="line">    Ivar a[] = &#123;ivar,ivar1,ivar2&#125;;</div><div class="line"></div><div class="line">    // 用一个Ivar *指针指向数组第一个元素</div><div class="line">    Ivar *ivarList = a;</div><div class="line"></div><div class="line">    // 根据指针访问数组第一个元素</div><div class="line">    ivarList[0];</div><div class="line"></div><div class="line">    */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="comment">// 获取类中的所有成员属性</span></div><div class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 根据角标，从数组取出对应的成员属性</span></div><div class="line">                Ivar ivar = ivarList[i];</div><div class="line"></div><div class="line">                <span class="comment">// 获取成员属性名</span></div><div class="line">                <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">                <span class="comment">// 处理成员属性名-&gt;字典中的key</span></div><div class="line">                <span class="comment">// 从第一个角标开始截取</span></div><div class="line">                <span class="built_in">NSString</span> *key = [name substringFromIndex:<span class="number">1</span>];</div><div class="line"></div><div class="line">                <span class="comment">// 根据成员属性名去字典中查找对应的value</span></div><div class="line">                <span class="keyword">id</span> value = dict[key];</div><div class="line"></div><div class="line">                <span class="comment">// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span></div><div class="line">                <span class="comment">// 判断下value是否是字典</span></div><div class="line">                <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                    <span class="comment">// 字典转模型</span></div><div class="line">                    <span class="comment">// 获取模型的类对象，调用modelWithDict</span></div><div class="line">                    <span class="comment">// 模型的类名已知，就是成员属性的类型</span></div><div class="line"></div><div class="line">                    <span class="comment">// 获取成员属性类型</span></div><div class="line">                    <span class="built_in">NSString</span> *type = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class="line">                    <span class="comment">// 生成的是这种@"@\"User\"" 类型 -》 @"User"  在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符</span></div><div class="line">                    <span class="comment">// 裁剪类型字符串</span></div><div class="line">                    <span class="built_in">NSRange</span> range = [type rangeOfString:<span class="string">@"\""</span>];</div><div class="line"></div><div class="line">                    type = [type substringFromIndex:range.location + range.length];</div><div class="line"></div><div class="line">                    range = [type rangeOfString:<span class="string">@"\""</span>];</div><div class="line"></div><div class="line">                    <span class="comment">// 裁剪到哪个角标，不包括当前角标</span></div><div class="line">                    type = [type substringToIndex:range.location];</div><div class="line"></div><div class="line">                    <span class="comment">// 根据字符串类名生成类对象</span></div><div class="line">                    Class modelClass = <span class="built_in">NSClassFromString</span>(type);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (modelClass) &#123; <span class="comment">// 有对应的模型才需要转</span></div><div class="line">                        <span class="comment">// 把字典转模型</span></div><div class="line">                        value  =  [modelClass modelWithDict:value];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span></div><div class="line">        <span class="comment">// 判断值是否是数组</span></div><div class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="comment">// 判断对应类有没有实现字典数组转模型数组的协议</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(arrayContainModelClass)]) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 转换成id类型，就能调用任何对象的方法</span></div><div class="line">                <span class="keyword">id</span> idSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 获取数组中字典对应的模型</span></div><div class="line">                <span class="built_in">NSString</span> *type =  [idSelf arrayContainModelClass][key];</div><div class="line"></div><div class="line">                <span class="comment">// 生成模型</span></div><div class="line">                Class classModel = <span class="built_in">NSClassFromString</span>(type);</div><div class="line">                <span class="built_in">NSMutableArray</span> *arrM = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">                <span class="comment">// 遍历字典数组，生成模型数组</span></div><div class="line">                <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> value) &#123;</div><div class="line">                    <span class="comment">// 字典转模型</span></div><div class="line">                    <span class="keyword">id</span> model =  [classModel modelWithDict:dict];</div><div class="line">                    [arrM addObject:model];</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// 把模型数组赋值给value</span></div><div class="line">                value = arrM;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (value) &#123; <span class="comment">// 有值，才需要给模型的属性赋值</span></div><div class="line">            <span class="comment">// 利用KVC给模型中的属性赋值</span></div><div class="line">            [objc setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> objc;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS中ReactiveCocoa的使用]]></title>
      <url>http://yoursite.com/2014/06/11/2014/iOS%E4%B8%ADReactiveCocoa%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-ReactiveCocoa简介"><a href="#1-ReactiveCocoa简介" class="headerlink" title="1.ReactiveCocoa简介"></a>1.ReactiveCocoa简介</h3><p>ReactiveCocoa（简称为<code>RAC</code>）,是由<code>Github</code>开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。</p>
<h3 id="2-ReactiveCocoa作用"><a href="#2-ReactiveCocoa作用" class="headerlink" title="2.ReactiveCocoa作用"></a>2.ReactiveCocoa作用</h3><ul>
<li>在我们iOS开发过程中，当某些事件响应的时候，需要处理某些业务逻辑,这些事件都用不同的方式来处理。</li>
<li>比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO等系统提供的方式。</li>
<li>其实这些事件，都可以通过RAC处理</li>
<li>ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中<code>高聚合，低耦合</code>的思想。</li>
</ul>
<h3 id="3-编程思想"><a href="#3-编程思想" class="headerlink" title="3.编程思想"></a>3.编程思想</h3><p>在开发中我们也不能太依赖于某个框架，否则这个框架不更新了，导致项目后期没办法维护，比如之前Facebook提供的<code>Three20框架</code>，在当时也是神器，但是后来不更新了，也就没什么人用了。因此我感觉学习一个框架，还是有必要了解它的<code>编程思想</code>。</p>
<p><code>编程思想的由来</code>：在开发中我们会遇见各种各样的需求，经常会思考如何快速的完成这些需求，这样就会慢慢形成快速完成这些需求的思想。先简单介绍下目前咱们已知的<code>编程思想</code>。<br>3.1 <code>面向过程</code>：处理事情以过程为核心，一步一步的实现。<br>3.2 <code>面向对象</code>：万物皆对象<br>3.3 <code>链式编程思想</code>：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3)</p>
<ul>
<li><code>链式编程特点</code>：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）</li>
<li><code>代表</code>：masonry框架。</li>
<li><code>练习一</code>:模仿masonry，写一个加法计算器，练习链式编程思想。</li>
</ul>
<p>3.4 <code>响应式编程思想</code>：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。<br><em><code>代表</code>：KVO运用。
</em><code>练习二</code>:KVO底层实现。</p>
<p>3.5 <code>函数式编程思想</code>：是把操作尽量写成一系列嵌套的函数或者方法调用。</p>
<ul>
<li><code>函数式编程本质</code>:就是往方法中传入Block,方法中嵌套Block调用，把代码聚合起来管理</li>
<li><code>函数式编程特点</code>：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）</li>
<li><code>代表</code>：ReactiveCocoa。</li>
<li><code>练习三</code>:用函数式编程实现，写一个加法计算器,并且加法计算器自带判断是否等于某个值.</li>
</ul>
<h3 id="4-ReactiveCocoa编程思想"><a href="#4-ReactiveCocoa编程思想" class="headerlink" title="4.ReactiveCocoa编程思想"></a>4.ReactiveCocoa编程思想</h3><p>ReactiveCocoa结合了几种编程风格：<br><code>函数式编程（Functional Programming）</code><br><code>响应式编程（Reactive Programming）</code><br>所以，你可能听说过ReactiveCocoa被描述为函数响应式编程（FRP）框架。以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。</p>
<h3 id="5-如何导入ReactiveCocoa框架"><a href="#5-如何导入ReactiveCocoa框架" class="headerlink" title="5.如何导入ReactiveCocoa框架"></a>5.如何导入ReactiveCocoa框架</h3><p>通常都会使用CocoaPods（用于管理第三方框架的插件）帮助我们导入。<br>CocoaPods教程（<a href="http://code4app.com/article/cocoapods-install-usage）" target="_blank" rel="external">http://code4app.com/article/cocoapods-install-usage）</a></p>
<h3 id="6-ReactiveCocoa常见类。"><a href="#6-ReactiveCocoa常见类。" class="headerlink" title="6.ReactiveCocoa常见类。"></a>6.ReactiveCocoa常见类。</h3><p>学习框架首要之处:个人认为先要搞清楚框架中常用的类，在RAC中最核心的类RACSiganl,搞定这个类就能用ReactiveCocoa开发了。<br><code>练习五</code>:介绍常见类<br><code>RACSiganl</code>:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>
<ul>
<li>信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</li>
<li>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</li>
<li>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。</li>
<li><code>RACSiganl简单使用:</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACSignal使用步骤：</span></div><div class="line"><span class="comment">// 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span></div><div class="line"><span class="comment">// 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 3.发送信号 - (void)sendNext:(id)value</span></div><div class="line"></div><div class="line"><span class="comment">// RACSignal底层实现：</span></div><div class="line"><span class="comment">// 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。</span></div><div class="line"><span class="comment">// 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock</span></div><div class="line"><span class="comment">// 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。</span></div><div class="line"><span class="comment">// 2.1 subscribeNext内部会调用siganl的didSubscribe</span></div><div class="line"><span class="comment">// 3.siganl的didSubscribe中调用[subscriber sendNext:@1];</span></div><div class="line"><span class="comment">// 3.1 sendNext底层其实就是执行subscriber的nextBlock</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    <span class="comment">// block调用时刻：每当有订阅者订阅信号，就会调用block。</span></div><div class="line">    <span class="comment">// 2.发送信号</span></div><div class="line">    [subscriber sendNext:@<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</span></div><div class="line">    [subscriber sendCompleted];</div><div class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line">        <span class="comment">// block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</span></div><div class="line">        <span class="comment">// 执行完Block后，当前信号就不在被订阅了。</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"信号被销毁"</span>);</div><div class="line">    &#125;];</div><div class="line">&#125;];</div><div class="line"><span class="comment">// 3.订阅信号,才会激活信号.</span></div><div class="line">[siganl subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="comment">// block调用时刻：每当有信号发出数据，就会调用block.</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接收到数据:%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>RACSubscriber</code>:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。<br><code>RACDisposable</code>:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</p>
<ul>
<li><code>使用场景</code>:不想监听某个信号时，可以通过它主动取消订阅信号。<br><code>RACSubject</code>:RACSubject:信号提供者，自己可以充当信号，又能发送信号。</li>
<li><code>使用场景</code>:通常用来代替代理，有了它，就不必要定义代理了。</li>
</ul>
<p><code>RACReplaySubject</code>:重复提供信号类，RACSubject的子类。</p>
<ul>
<li><code>RACReplaySubject</code>与<code>RACSubject</code>区别:</li>
<li>RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。</li>
<li><code>使用场景一</code>:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li>
<li><code>使用场景二</code>:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。</li>
<li><code>RACSubject和RACReplaySubject简单使用:</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACSubject使用步骤</span></div><div class="line"><span class="comment">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span></div><div class="line"><span class="comment">// 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 3.发送信号 sendNext:(id)value</span></div><div class="line"></div><div class="line"><span class="comment">// RACSubject:底层实现和RACSignal不一样。</span></div><div class="line"><span class="comment">// 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</span></div><div class="line"><span class="comment">// 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSubject *subject = [RACSubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="comment">// block调用时刻：当信号发出新值，就会调用.</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者%@"</span>,x);</div><div class="line">&#125;];</div><div class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="comment">// block调用时刻：当信号发出新值，就会调用.</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.发送信号</span></div><div class="line">[subject sendNext:<span class="string">@"1"</span>];</div><div class="line"></div><div class="line"><span class="comment">// RACReplaySubject使用步骤:</span></div><div class="line"><span class="comment">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span></div><div class="line"><span class="comment">// 2.可以先订阅信号，也可以先发送信号。</span></div><div class="line"><span class="comment">// 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 2.2 发送信号 sendNext:(id)value</span></div><div class="line"></div><div class="line"><span class="comment">// RACReplaySubject:底层实现和RACSubject不一样。</span></div><div class="line"><span class="comment">// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span></div><div class="line"><span class="comment">// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock</span></div><div class="line"></div><div class="line"><span class="comment">// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。</span></div><div class="line"><span class="comment">// 也就是先保存值，在订阅值。</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACReplaySubject *replaySubject = [RACReplaySubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 2.发送信号</span></div><div class="line">[replaySubject sendNext:@<span class="number">1</span>];</div><div class="line">[replaySubject sendNext:@<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号</span></div><div class="line">[replaySubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者接收到的数据%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 订阅信号</span></div><div class="line">[replaySubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者接收到的数据%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li><code>RACSubject替换代理</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 需求:</span></div><div class="line"><span class="comment">// 1.给当前控制器添加一个按钮，modal到另一个控制器界面</span></div><div class="line"><span class="comment">// 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器</span></div><div class="line"></div><div class="line">步骤一：在第二个控制器.h，添加一个RACSubject代替代理。</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TwoViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSubject *delegateSignal;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">步骤二：监听第二个控制器按钮点击</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TwoViewController</span></span></div><div class="line">- (<span class="keyword">IBAction</span>)notice:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="comment">// 通知第一个控制器，告诉它，按钮被点了</span></div><div class="line">    <span class="comment">// 通知代理</span></div><div class="line">    <span class="comment">// 判断代理信号是否有值</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.delegateSignal) &#123;</div><div class="line">        <span class="comment">// 有值，才需要通知</span></div><div class="line">        [<span class="keyword">self</span>.delegateSignal sendNext:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OneViewController</span></span></div><div class="line">- (<span class="keyword">IBAction</span>)btnClick:(<span class="keyword">id</span>)sender &#123;</div><div class="line"></div><div class="line"><span class="comment">// 创建第二个控制器</span></div><div class="line">TwoViewController *twoVc = [[TwoViewController alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 设置代理信号</span></div><div class="line">twoVc.delegateSignal = [RACSubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 订阅代理信号</span></div><div class="line">[twoVc.delegateSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"点击了通知按钮"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 跳转到第二个控制器</span></div><div class="line">[<span class="keyword">self</span> presentViewController:twoVc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>RACTuple</code>:元组类,类似NSArray,用来包装值.<br><code>RACSequence</code>:RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。<br><code>使用场景</code>：1.字典转模型<br><code>RACSequence和RACTuple简单使用</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.遍历数组</span></div><div class="line"><span class="built_in">NSArray</span> *numbers = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>];</div><div class="line"><span class="comment">// 这里其实是三步</span></div><div class="line"><span class="comment">// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence</span></div><div class="line"><span class="comment">// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal</span></div><div class="line"><span class="comment">// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。</span></div><div class="line">[numbers.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)</span></div><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"name"</span>:<span class="string">@"xmg"</span>,<span class="string">@"age"</span>:@<span class="number">18</span>&#125;;</div><div class="line">[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;</div><div class="line"></div><div class="line"><span class="comment">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span></div><div class="line">RACTupleUnpack(<span class="built_in">NSString</span> *key,<span class="built_in">NSString</span> *value) = x;</div><div class="line">    <span class="comment">// 相当于以下写法</span></div><div class="line">    <span class="comment">// NSString *key = x[0];</span></div><div class="line">    <span class="comment">// NSString *value = x[1];</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,key,value);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.字典转模型</span></div><div class="line"><span class="comment">// 3.1 OC写法</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"><span class="built_in">NSMutableArray</span> *items = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> dictArr) &#123;</div><div class="line">    FlagItem *item = [FlagItem flagWithDict:dict];</div><div class="line">    [items addObject:item];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3.2 RAC写法</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"><span class="built_in">NSMutableArray</span> *flags = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">_flags = flags;</div><div class="line"><span class="comment">// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。</span></div><div class="line">[dictArr.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// 运用RAC遍历字典，x：字典</span></div><div class="line">FlagItem *item = [FlagItem flagWithDict:x];</div><div class="line">    [flags addObject:item];</div><div class="line">&#125;];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,  <span class="built_in">NSStringFromCGRect</span>([<span class="built_in">UIScreen</span> mainScreen].bounds));</div><div class="line"></div><div class="line"><span class="comment">// 3.3 RAC高级写法:</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"><span class="comment">// map:映射的意思，目的：把原始值value映射成一个新值</span></div><div class="line"><span class="comment">// array: 把集合转换成数组</span></div><div class="line"><span class="comment">// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。</span></div><div class="line"><span class="built_in">NSArray</span> *flags = [[dictArr.rac_sequence map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [FlagItem flagWithDict:value];</div><div class="line">&#125;] array];</div></pre></td></tr></table></figure>
<p><code>RACMulticastConnection</code>:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。<br><code>使用注意</code>:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.<br><code>RACMulticastConnection简单使用</code>:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACMulticastConnection使用步骤:</span></div><div class="line"><span class="comment">// 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span></div><div class="line"><span class="comment">// 2.创建连接 RACMulticastConnection *connect = [signal publish];</span></div><div class="line"><span class="comment">// 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]</span></div><div class="line"><span class="comment">// 4.连接 [connect connect]</span></div><div class="line"></div><div class="line"><span class="comment">// RACMulticastConnection底层原理:</span></div><div class="line"><span class="comment">// 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号)  connect.signal -&gt; RACSubject</span></div><div class="line"><span class="comment">// 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。</span></div><div class="line"><span class="comment">// 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject</span></div><div class="line"><span class="comment">// 3.1.订阅原始信号，就会调用原始信号中的didSubscribe</span></div><div class="line"><span class="comment">// 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext</span></div><div class="line"><span class="comment">// 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。</span></div><div class="line"><span class="comment">// 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock</span></div><div class="line"></div><div class="line"><span class="comment">// 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。</span></div><div class="line"><span class="comment">// 解决：使用RACMulticastConnection就能解决.</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建请求信号</span></div><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"发送请求"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接收数据"</span>);</div><div class="line">&#125;];</div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接收数据"</span>);</div><div class="line">&#125;];</div><div class="line"><span class="comment">// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求</span></div><div class="line"><span class="comment">// RACMulticastConnection:解决重复请求问题</span></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"发送请求"</span>);</div><div class="line">[subscriber sendNext:@<span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2.创建连接</span></div><div class="line">RACMulticastConnection *connect = [signal publish];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号，</span></div><div class="line"><span class="comment">// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:</span></div><div class="line">[connect.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅者一信号"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[connect.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"订阅者二信号"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 4.连接,激活信号</span></div><div class="line">[connect connect];</div></pre></td></tr></table></figure>
<p><code>RACCommand</code>:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。<br><code>使用场景</code>:监听按钮点击，网络请求<br><code>RACCommand简单使用</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一、RACCommand使用步骤:</span></div><div class="line"><span class="comment">// 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock</span></div><div class="line"><span class="comment">// 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值</span></div><div class="line"><span class="comment">// 3.执行命令 - (RACSignal *)execute:(id)input</span></div><div class="line"></div><div class="line"><span class="comment">// 二、RACCommand使用注意:</span></div><div class="line"><span class="comment">// 1.signalBlock必须要返回一个信号，不能传nil.</span></div><div class="line"><span class="comment">// 2.如果不想要传递信号，直接创建空的信号[RACSignal empty];</span></div><div class="line"><span class="comment">// 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</span></div><div class="line"></div><div class="line"><span class="comment">// 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</span></div><div class="line"><span class="comment">// 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。</span></div><div class="line"><span class="comment">// 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</span></div><div class="line"></div><div class="line"><span class="comment">// 四、如何拿到RACCommand中返回信号发出的数据。</span></div><div class="line"><span class="comment">// 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</span></div><div class="line"><span class="comment">// 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</span></div><div class="line"></div><div class="line"><span class="comment">// 五、监听当前命令是否正在执行executing</span></div><div class="line"><span class="comment">// 六、使用场景,监听按钮点击，网络请求</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建命令</span></div><div class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"执行命令"</span>);</div><div class="line">    <span class="comment">// 创建空信号,必须返回信号</span></div><div class="line">    <span class="comment">// return [RACSignal empty];</span></div><div class="line">    <span class="comment">// 2.创建信号,用来传递数据</span></div><div class="line">    <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        [subscriber sendNext:<span class="string">@"请求数据"</span>];</div><div class="line">        <span class="comment">// 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。</span></div><div class="line">        [subscriber sendCompleted];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 强引用命令，不要被销毁，否则接收不到数据</span></div><div class="line">_conmmand = command;</div><div class="line"></div><div class="line"><span class="comment">// 3.执行命令</span></div><div class="line">[<span class="keyword">self</span>.conmmand execute:@<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// 4.订阅RACCommand中的信号</span></div><div class="line">[command.executionSignals subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    [x subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">    &#125;];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// RAC高级用法</span></div><div class="line"><span class="comment">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号</span></div><div class="line">[command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 5.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</span></div><div class="line">[[command.executing skip:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="keyword">if</span> ([x boolValue] == <span class="literal">YES</span>) &#123;</div><div class="line">        <span class="comment">// 正在执行</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"正在执行"</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">// 执行完成</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"执行完成"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>RACScheduler</code>:RAC中的队列，用GCD封装的。<br><code>RACUnit</code> :表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.<br><code>RACEvent</code>: 把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。</p>
<h3 id="7-ReactiveCocoa开发中常见用法。"><a href="#7-ReactiveCocoa开发中常见用法。" class="headerlink" title="7.ReactiveCocoa开发中常见用法。"></a>7.ReactiveCocoa开发中常见用法。</h3><p>7.1 代替代理:</p>
<ul>
<li><code>rac_signalForSelector</code>：用于替代代理。<br>7.2 代替KVO :</li>
<li><code>rac_valuesAndChangesForKeyPath</code>：用于监听某个对象的属性改变。<br>7.3 监听事件:</li>
<li><code>rac_signalForControlEvents</code>：用于监听某个事件。<br>7.4 代替通知:</li>
<li><code>rac_addObserverForName</code>:用于监听某个通知。<br>7.5 监听文本框文字改变:</li>
<li><code>rac_textSignal</code>:只要文本框发出改变就会发出这个信号。<br>7.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面</li>
<li><code>rac_liftSelector:withSignalsFromArray:Signals</code>:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</li>
<li>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。<br>7.7 代码演示<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.代替代理</span></div><div class="line"><span class="comment">// 需求：自定义redView,监听红色view中按钮点击</span></div><div class="line"><span class="comment">// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</span></div><div class="line"><span class="comment">// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</span></div><div class="line"><span class="comment">// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</span></div><div class="line">[[redV rac_signalForSelector:<span class="keyword">@selector</span>(btnClick:)] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"点击红色按钮"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2.KVO</span></div><div class="line"><span class="comment">// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</span></div><div class="line"><span class="comment">// observer:可以传入nil</span></div><div class="line">[[redV rac_valuesAndChangesForKeyPath:<span class="string">@"center"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.监听事件</span></div><div class="line"><span class="comment">// 把按钮点击事件转换为信号，点击按钮，就会发送信号</span></div><div class="line">[[<span class="keyword">self</span>.btn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"按钮被点击了"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 4.代替通知</span></div><div class="line"><span class="comment">// 把监听到的通知转换信号</span></div><div class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="built_in">UIKeyboardWillShowNotification</span> object:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"键盘弹出"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 5.监听文本框的文字改变</span></div><div class="line">[_textField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"文字改变了%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 6.处理多个请求，都返回结果的时候，统一做处理.</span></div><div class="line">RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    <span class="comment">// 发送请求1</span></div><div class="line">    [subscriber sendNext:<span class="string">@"发送请求1"</span>];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    <span class="comment">// 发送请求2</span></div><div class="line">    [subscriber sendNext:<span class="string">@"发送请求2"</span>];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="comment">// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</span></div><div class="line">    [<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 更新UI</span></div><div class="line">- (<span class="keyword">void</span>)updateUIWithR1:(<span class="keyword">id</span>)data r2:(<span class="keyword">id</span>)data1&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"更新UI%@  %@"</span>,data,data1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="8-ReactiveCocoa常见宏。"><a href="#8-ReactiveCocoa常见宏。" class="headerlink" title="8.ReactiveCocoa常见宏。"></a>8.ReactiveCocoa常见宏。</h3><p>8.1 <code>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</code>:用于给某个对象的某个属性绑定。<br><code>基本用法</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只要文本框文字改变，就会修改label的文字</span></div><div class="line">RAC(<span class="keyword">self</span>.labelView,text) = _textField.rac_textSignal;</div></pre></td></tr></table></figure></p>
<p>8.2 <code>RACObserve(self, name)</code>:监听某个对象的某个属性,返回的是信号。<br><code>基本用法</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[RACObserve(<span class="keyword">self</span>.view, center) subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>8.3  <code>@weakify(Obj)和@strongify(Obj)</code>,一般两个都是配套使用,解决循环引用问题.<br>8.4 <code>RACTuplePack</code>：把数据包装成RACTuple（元组类）<br><code>基本用法</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把参数中的数据包装成元组</span></div><div class="line">RACTuple *tuple = RACTuplePack(@<span class="number">10</span>,@<span class="number">20</span>);</div></pre></td></tr></table></figure></p>
<p>8.5 <code>RACTupleUnpack</code>：把RACTuple（元组类）解包成对应的数据。<br><code>基本用法</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把参数中的数据包装成元组</span></div><div class="line">RACTuple *tuple = RACTuplePack(<span class="string">@"xmg"</span>,@<span class="number">20</span>);</div><div class="line"><span class="comment">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span></div><div class="line"><span class="comment">// name = @"xmg" age = @20</span></div><div class="line">RACTupleUnpack(<span class="built_in">NSString</span> *name,<span class="built_in">NSNumber</span> *age) = tuple;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS精度丢失的处理]]></title>
      <url>http://yoursite.com/2014/06/03/2014/iOS%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="NSDecimalNumber"><a href="#NSDecimalNumber" class="headerlink" title="NSDecimalNumber"></a>NSDecimalNumber</h3><p>这是一个十进制数字类，继承自NSNumber，苹果针对浮点类型计算精度问题提供出来的计算类，基于十进制的科学计数法来计算，同时可以指定舍入模式，一般用于货币计算。<br>初始化方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建并返回一个十进制对象</span></div><div class="line"><span class="comment">//@param dcm 十进制的结构体</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithDecimal:(<span class="built_in">NSDecimal</span>)dcm;</div><div class="line"></div><div class="line"><span class="comment">//@param mantissa 十进制尾数  （如：123）</span></div><div class="line"><span class="comment">//@param exponent 指数       （如：3）</span></div><div class="line"><span class="comment">//@param flag 是否为负        （如：YES）</span></div><div class="line"><span class="comment">//return 十进制数字对象         (如：-123000)</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithMantissa:(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)mantissa</div><div class="line">                        exponent:(<span class="keyword">short</span>)exponent</div><div class="line">                      isNegative:(<span class="built_in">BOOL</span>)flag;</div><div class="line"></div><div class="line"><span class="comment">//@param numberValue 数字字符串</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithString:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)numberValue;</div><div class="line"></div><div class="line"><span class="comment">//@param numberValue 数字字符串,可以根据locale来解析 (如:@"123,456")</span></div><div class="line"><span class="comment">//@param locale 解析&lt;numberValue&gt;的字典(特别是NSLocaleDecimalSeparator:分割整数跟小数)</span></div><div class="line"><span class="comment">//(如 @&#123;NSLocaleDecimalSeparator:@","&#125;)</span></div><div class="line"><span class="comment">//@return 十进制数字对象                           (如：123.456)</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithString:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)numberValue</div><div class="line">                        locale:(<span class="keyword">nullable</span> <span class="keyword">id</span>)locale;</div></pre></td></tr></table></figure></p>
<h3 id="NSDecimalNumberHandler"><a href="#NSDecimalNumberHandler" class="headerlink" title="NSDecimalNumberHandler"></a>NSDecimalNumberHandler</h3><p>这是一个NSDecimalNumber的公共协议处理类，可以设置舍入模式以及计算错误的处理；配合NSDecimalNumber来使用，将这个类的实例当做NSDecimalNumber相应API的参数来控制数字处理的结果。</p>
<p>初始化方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@param roundingMode 舍入方式</span></div><div class="line"><span class="comment">//@param scale 小数点后舍入值的位数。</span></div><div class="line"><span class="comment">//@param exact 精度错误处理；YES:如果出现错误，将引发异常，NO:忽略错误并将控制权放回给调用者。</span></div><div class="line"><span class="comment">//@param overflow 溢出错误处理；YES:如果出现错误，将引发异常，NO:忽略错误并将控制权放回给调用者。</span></div><div class="line"><span class="comment">//@param underflow 下溢错误处理；YES:如果出现错误，将引发异常，NO:忽略错误并将控制权放回给调用者。</span></div><div class="line"><span class="comment">//@param divideByZero 除以0的错误处理；YES:如果出现错误，将引发异常，NO:忽略错误并将控制权放回给调用者。</span></div><div class="line"><span class="comment">//@return NSDecimalNumberHandler对象</span></div><div class="line">+ (<span class="keyword">instancetype</span>)decimalNumberHandlerWithRoundingMode:(<span class="built_in">NSRoundingMode</span>)roundingMode</div><div class="line">                                               scale:(<span class="keyword">short</span>)scale</div><div class="line">                                    raiseOnExactness:(<span class="built_in">BOOL</span>)exact</div><div class="line">                                     raiseOnOverflow:(<span class="built_in">BOOL</span>)overflow</div><div class="line">                                    raiseOnUnderflow:(<span class="built_in">BOOL</span>)underflow</div><div class="line">                                 raiseOnDivideByZero:(<span class="built_in">BOOL</span>)divideByZero;</div></pre></td></tr></table></figure></p>
<p>快速构造方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//roundingMode:NSRoundPlain</span></div><div class="line"><span class="comment">//scale:全精度</span></div><div class="line"><span class="comment">//exact:NO</span></div><div class="line"><span class="comment">//overflow:NO</span></div><div class="line"><span class="comment">//underflow:NO</span></div><div class="line"><span class="comment">//divideByZero:NO</span></div><div class="line"></div><div class="line">+ (<span class="built_in">NSDecimalNumberHandler</span> *)defaultDecimalNumberHandler;</div></pre></td></tr></table></figure></p>
<h3 id="NSRoundingMode的几种类型"><a href="#NSRoundingMode的几种类型" class="headerlink" title="NSRoundingMode的几种类型"></a>NSRoundingMode的几种类型</h3><ul>
<li>NSRoundPlain:四舍五入</li>
<li>NSRoundDown:只舍不入</li>
<li>NSRoundUp：只入不舍</li>
<li>NSRoundBankers：在四舍五入的基础上加了一个判断：当最后一位为5的时候，只会舍入成偶数。比如：1.25不会返回1.3而是1.2，因为1.3不是偶数</li>
</ul>
<p>加法运算<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@param decimalNumber 相加的十进制对象</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByAdding:(<span class="built_in">NSDecimalNumber</span> *)decimalNumber;</div><div class="line"></div><div class="line"><span class="comment">//@param decimalNumber 相加的十进制对象</span></div><div class="line"><span class="comment">//@param behavior NSDecimalNumberHandler对象</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByAdding:(<span class="built_in">NSDecimalNumber</span> *)decimalNumber</div><div class="line">withBehavior:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">NSDecimalNumberBehaviors</span>&gt;)behavior</div></pre></td></tr></table></figure></p>
<p>减法运算<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@param decimalNumber 减去的十进制对象</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberBySubtracting:(<span class="built_in">NSDecimalNumber</span> *)decimalNumber;</div><div class="line"></div><div class="line"><span class="comment">//@param decimalNumber 减去的十进制对象</span></div><div class="line"><span class="comment">//@param behavior NSDecimalNumberHandler对象</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberBySubtracting:(<span class="built_in">NSDecimalNumber</span> *)decimalNumber</div><div class="line">                                   withBehavior:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">NSDecimalNumberBehaviors</span>&gt;)behavior;</div></pre></td></tr></table></figure></p>
<p>乘法运算<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@param decimalNumber 相乘的十进制对象</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByMultiplyingBy:(<span class="built_in">NSDecimalNumber</span> *)decimalNumber;</div><div class="line"></div><div class="line"><span class="comment">//@param decimalNumber 相乘的十进制对象</span></div><div class="line"><span class="comment">//@param behavior NSDecimalNumberHandler对象</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByMultiplyingBy:(<span class="built_in">NSDecimalNumber</span> *)decimalNumber</div><div class="line">withBehavior:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">NSDecimalNumberBehaviors</span>&gt;)behavior;</div></pre></td></tr></table></figure></p>
<p>除法运算<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@param decimalNumber 除以的十进制对象</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByDividingBy:(<span class="built_in">NSDecimalNumber</span> *)decimalNumber;</div><div class="line"></div><div class="line"><span class="comment">//@param decimalNumber  除以的十进制对象</span></div><div class="line"><span class="comment">//@param behavior NSDecimalNumberHandler对象</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByDividingBy:(<span class="built_in">NSDecimalNumber</span> *)decimalNumber</div><div class="line">                                  withBehavior:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">NSDecimalNumberBehaviors</span>&gt;)behavior;</div></pre></td></tr></table></figure></p>
<p>次方运算<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//@param power 指数</span></div><div class="line"><span class="comment">//return 调用者的power次方</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByRaisingToPower:(<span class="built_in">NSUInteger</span>)power;</div><div class="line"></div><div class="line"><span class="comment">//@param power 指数</span></div><div class="line"><span class="comment">//@param behavior NSDecimalNumberHandler对象</span></div><div class="line"><span class="comment">//return 调用者的power次方</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByRaisingToPower:(<span class="built_in">NSUInteger</span>)power</div><div class="line">                                      withBehavior:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">NSDecimalNumberBehaviors</span>&gt;)behavior;</div></pre></td></tr></table></figure></p>
<p>10为底的乘方运算<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调用者乘以10的power次方</span></div><div class="line"><span class="comment">//@param power 10的指数</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByMultiplyingByPowerOf10:(<span class="keyword">short</span>)power;</div><div class="line"></div><div class="line"><span class="comment">//调用者乘以10的power次方</span></div><div class="line"><span class="comment">//@param power 10的指数</span></div><div class="line"><span class="comment">//@param behavior NSDecimalNumberHandler对象</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByMultiplyingByPowerOf10:(<span class="keyword">short</span>)power</div><div class="line">                                              withBehavior:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">NSDecimalNumberBehaviors</span>&gt;)behavior;</div></pre></td></tr></table></figure></p>
<p>舍入运算<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@param decimalNumber NSDecimalNumberHandler对象</span></div><div class="line">- (<span class="built_in">NSDecimalNumber</span> *)decimalNumberByRoundingAccordingToBehavior:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">NSDecimalNumberBehaviors</span>&gt;)behavior;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS常用的三种种枚举]]></title>
      <url>http://yoursite.com/2014/05/29/2014/iOS%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[<h3 id="Ios中常用的枚举的几种写法"><a href="#Ios中常用的枚举的几种写法" class="headerlink" title="Ios中常用的枚举的几种写法"></a>Ios中常用的枚举的几种写法</h3><p>普通的枚举<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</div><div class="line">    XMtop,</div><div class="line">    XMbottom,</div><div class="line">&#125;XM;</div></pre></td></tr></table></figure></p>
<p>自定义类型枚举<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, KSType) &#123;</div><div class="line">    KSTypeTop,</div><div class="line">    KSTypeBottom,</div><div class="line">    KSTypeRight,</div><div class="line">    KSTypeLeft,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>移位枚举<br>一个参数可以传递多个值 ,如果枚举使用了位运算那么就可以使用并运算,如果是位移枚举,观察第一个枚举值,如果该枚举值!=0 那么可以默认传0做参数,如果传0做参数,那么效率最高<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, SType) &#123;</div><div class="line">    STypeTop        = <span class="number">1</span>&lt;&lt;<span class="number">0</span>,</div><div class="line">    STypeBottom     = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,</div><div class="line">    STypeRight      = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,</div><div class="line">    STypeLeft       = <span class="number">1</span>&lt;&lt;<span class="number">3</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="位移枚举的使用"><a href="#位移枚举的使用" class="headerlink" title="位移枚举的使用"></a>位移枚举的使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 只要枚举中有位运算就可以使用并运算|</span></div><div class="line">    <span class="comment">// 为什么?</span></div><div class="line">    [_textField addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(textBegin) forControlEvents:<span class="built_in">UIControlEventEditingDidBegin</span> | <span class="built_in">UIControlEventEditingChanged</span>];</div><div class="line"></div><div class="line">    <span class="comment">//textBegin 内部的实现原理</span></div><div class="line">    [<span class="keyword">self</span> test:c | b];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)test:(<span class="keyword">int</span>)value&#123;</div><div class="line">    <span class="comment">// 解析value,判断下是否包含a,b,c,d</span></div><div class="line">    <span class="comment">// &amp;:解析有没有包含a,b,c,d</span></div><div class="line">    <span class="comment">// NSLog(@"%d %d %d %d",value &amp; a,value &amp; b,value &amp; c,value &amp; d);</span></div><div class="line">    <span class="keyword">if</span> (value &amp; a) <span class="built_in">NSLog</span>(<span class="string">@"包含了a"</span>);</div><div class="line">    <span class="keyword">if</span> (value &amp; b) <span class="built_in">NSLog</span>(<span class="string">@"包含了b"</span>);</div><div class="line">    <span class="keyword">if</span> (value &amp; c) <span class="built_in">NSLog</span>(<span class="string">@"包含了c"</span>);</div><div class="line">    <span class="keyword">if</span> (value &amp; d) <span class="built_in">NSLog</span>(<span class="string">@"包含了d"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[什么是离屏渲染]]></title>
      <url>http://yoursite.com/2014/05/29/2014/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</url>
      <content type="html"><![CDATA[<p>GPU，中文翻译为“图形处理器”。GPU是相对于CPU的一个概念，GPU是显示卡的“心脏”，也就相当于CPU在电脑中的作用，它决定了该显卡的档次和大部分性能，同时也是2D显示卡和3D显示卡的区别依据。</p>
<h3 id="GPU渲染机制"><a href="#GPU渲染机制" class="headerlink" title="GPU渲染机制"></a>GPU渲染机制</h3><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>
<h3 id="GPU屏幕渲染有以下两种方式"><a href="#GPU屏幕渲染有以下两种方式" class="headerlink" title="GPU屏幕渲染有以下两种方式"></a>GPU屏幕渲染有以下两种方式</h3><p><font color="#dd0000">On-Screen Rendering </font><br><br>意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</p>
<p> <font color="#dd0000">Off-Screen Rendering </font><br><br>意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>
<p> <font color="#dd0000">特殊的离屏渲染 </font><br><br>如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式： CPU渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内 同步地。完成，渲染得到的bitmap最后再交由GPU用于显示。备注：CoreGraphic通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程，一个简单的异步绘制过程大致如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)display &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</div><div class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</div><div class="line">        <span class="comment">// draw in context</span></div><div class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</div><div class="line">        <span class="built_in">CFRelease</span>(ctx);</div><div class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</div><div class="line">            layer.contents = img;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="离屏渲染的触发方式"><a href="#离屏渲染的触发方式" class="headerlink" title="离屏渲染的触发方式"></a>离屏渲染的触发方式</h3><p>设置了以下属性时，都会触发离屏绘制</p>
<ul>
<li>1.shouldRasterize(光栅化）</li>
<li>2.masks(遮罩)</li>
<li>3.shadows(阴影)</li>
<li>4.edge antialiasing(抗锯齿）</li>
<li>5.group opacity(不透明）</li>
<li>6.复杂形状设置圆角</li>
<li>7.渐变</li>
</ul>
<p>其中shouldRasterize (光栅化) 是比较特别的一种</p>
<p><font color="#dd0000">光栅化概念：</font><br>将图转化为一个个栅格组成的图象。</p>
<p><font color="#dd0000">光栅化特点：</font><br>每个元素对应帧缓冲区中的一像素。</p>
<p>shouldRasterize = YES在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。shouldRasterize = YES，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。相当于光栅化是把GPU的操作转到CPU上了，生成位图缓存，直接读取复用。当你使用光栅化时，你可以开启“Color Hits Green and Misses Red”来检查该场景下光栅化操作是否是一个好的选择。绿色表示缓存被复用，红色表示缓存在被重复创建。如果光栅化的层变红得太频繁那么光栅化对优化可能没有多少用处。位图缓存从内存中删除又重新创建得太过频繁，红色表明缓存重建得太迟。可以针对性的选择某个较小而较深的层结构进行光栅化，来尝试减少渲染时间。</p>
<p>注意：<br>对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费，例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。</p>
<h3 id="为什么会使用离屏渲染"><a href="#为什么会使用离屏渲染" class="headerlink" title="为什么会使用离屏渲染"></a>为什么会使用离屏渲染</h3><p>当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染被唤起。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU)。所以当使用离屏渲染的时候会很容易造成性能消耗，因为在OPENGL里离屏渲染会单独在内存中创建一个屏幕外缓冲区并进行渲染，而屏幕外缓冲区跟当前屏幕缓冲区上下文切换是很耗性能的。</p>
<h3 id="Instruments监测离屏渲染"><a href="#Instruments监测离屏渲染" class="headerlink" title="Instruments监测离屏渲染"></a>Instruments监测离屏渲染</h3><p>Instruments的Core Animation工具中有几个和离屏渲染相关的检查选项:</p>
<ul>
<li><p>Color Offscreen-Rendered Yellow<br>开启后会把那些需要离屏渲染的图层高亮成黄色，这就意味着黄色图层可能存在性能问题。</p>
</li>
<li><p>Color Hits Green and Misses Red<br>如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。</p>
</li>
</ul>
<h3 id="iOS版本上的优化"><a href="#iOS版本上的优化" class="headerlink" title="iOS版本上的优化"></a>iOS版本上的优化</h3><p>iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染。<br>iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。这可能是苹果也意识到离屏渲染会产生性能问题，所以能不产生离屏渲染的地方苹果也就不用离屏渲染了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS编程词汇大全]]></title>
      <url>http://yoursite.com/2014/05/21/2014/iOS%E7%BC%96%E7%A8%8B%E8%AF%8D%E6%B1%87%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>A2A integration <code>[,inti&#39;ɡreiʃən]</code>A2A整合<br>abstract <code>[&#39;æbstrækt, æb&#39;strækt]</code> 抽象的<br>abstract <code>base [beis]</code>class (ABC)抽象基类<br>abstract class 抽象类<br>abstraction <code>[æb&#39;strækʃən]</code> 抽象、抽象物、抽象性<br>access <code>[&#39;ækses, &#39;æksəs, æk&#39;ses]</code>存取、访问<br>access level<code>[&#39;levəl]</code>访问级别<br>access function<code>[&#39;fʌŋkʃən]</code>访问函数<br>account <code>[ə&#39;kaunt]</code>账户<br>action <code>[&#39;ækʃən]</code>动作<br>activate<code>[&#39;æktiveit]</code> 激活<br>active <code>[&#39;æktiv]</code>活动的<br>actual parameter<code>[&#39;æktʃuəl]``[pə&#39;ræmitə]</code> 实参<br>adapter <code>[ə&#39;dæptə]</code>适配器<br>add-in 插件<br>address <code>[ə&#39;dres]</code>地址<br>address space 地址空间<br>address-of operator <code>[&#39;ɔpəreitə]</code>取地址操作符<br>ADL (argument-dependent lookup) <code>[&#39;ɑ:ɡjumənt]``[di&#39;pendənt]</code><br>ADO(ActiveX Data Object)ActiveX数据对象<br>advanced <code>[əd&#39;vænst]</code>高级的<br>aggregation <code>[,æɡri&#39;ɡeiʃən]</code> 聚合、聚集<br>algorithm <code>[&#39;ælgə&#39;rɪðəm]</code> 算法<br>alias<code>[ˈeɪli:əs]</code> 别名<br>align<code>[ə&#39;lain]</code>排列、对齐<br>allocate <code>[ˈæləkeit]</code> 分配、配置<br>allocator<code>[&#39;æləukeitə]</code>分配器、配置器<br>angle bracket <code>[&#39;æŋɡl]``[&#39;brækit]</code>尖括号<br>annotation <code>[,ænəu&#39;teiʃən]</code>注解、评注<br>API (Application Programming Interface) 应用(程序)编程接口<br>app domain (application domain) <code>[æp]``[do&#39;men]</code>应用域<br>application <code>[,æpli&#39;keiʃən]</code>应用、应用程序<br>application framework <code>[&#39;freimwə:k]</code> 应用程序框架<br>appearance <code>[ə&#39;piərəns]</code>外观<br>append <code>[ə&#39;pend]</code>附加<br>architecture <code>[&#39;ɑ:kitektʃə]</code>架构、体系结构<br>archive file <code>[&#39;ɑ:kaiv] [&#39;fail]</code> 归档文件、存档文件<br>argument[‘ɑ:ɡjumənt]引数(传给函式的值)。参见parameter <code>[pə&#39;ræmitə]</code><br>array <code>[ə&#39;rei]</code>数组<br>arrow operator <code>[&#39;ærəu]``[&#39;ɔpəreitə]</code>箭头操作符<br>ASP(Active Server Page)活动服务器页面<br>ASP.NET worker process <code>[&#39;prəuses, &#39;prɔ-]</code> ASP.NET工作者进程<br>assembly <code>[ə&#39;sembli]</code> 装配件、配件<br>assembly language  汇编语言<br>assembly manifest <code>[&#39;mænifest]</code>装配件清单<br>assert(ion) <code>[ə&#39;sə:t]</code> assertion<code>[ə&#39;sɝʃən]</code> 断言<br>assign <code>[ə&#39;sain]</code> 赋值<br>assignment <code>[ə&#39;sainmənt]</code>赋值、分配<br>assignment operator 赋值操作符=<br>associated <code>[ə&#39;səuʃi,eitid]</code> 相关的、相关联的<br>associative container <code>[ə&#39;səuʃjətiv]``[kən&#39;teinə]</code>关联式容器(对应sequential container <code>[si&#39;kwenʃəl]</code>)<br>asynchronous <code>[eɪˈsɪŋkrənəs]</code> 异步的<br>atomic <code>[ə&#39;tɔmik]</code>原子的<br>atomic operation  原子操作<br>attribute<code>[&#39;ætribju:t]</code> 特性、属性<br>authentication <code>[ɔːˌθentɪˈkeɪʃn]</code>service 验证服务<br>authorization<code>[,ɔ:θərai&#39;zeiʃən, -ri&#39;z-]</code>授权<br>audio <code>[&#39;ɔ:diəu]</code> 音频<br>A.I.    人工智能artificial intelligence <code>[,ɑ:ti&#39;fiʃəl]``[in&#39;telidʒəns]</code><br>B2B integration <code>[,inti&#39;ɡreiʃən]</code> B2B整合、B2B集成(business-to-business integration)<br>background   背景、后台(进程)<br>backward compatible <code>[kəm&#39;pætəbl]</code> 向后兼容、向下兼容<br>backup   备份<br>backup device<code>[di&#39;vais]</code>备份设备                                       3<br>backup file 备份文件<br>bandwidth <code>[&#39;bændwidθ]</code> 带宽<br>base class 基类<br>base type 基类型<br>batch <code>[bætʃ]</code>批处理<br>BCL (base class library)基类库<br>binary <code>[&#39;bainəri]</code>二进制<br>binary search 二分查找<br>binary tree 二叉树<br>binary function 双参函数<br>binary large object二进制大对象<br>binary operator 二元操作符<br>binding <code>[&#39;baindiŋ]</code> 绑定<br>bit 位<br>bitmap<code>[&#39;bit,mæp]</code>位图<br>bitwise 按位…<br>bitwise copy 为单元进行复制；位元逐一复制,按位拷<br>bitwise operation 按位运算<br>block 块、区块、语句块<br>bookkeeping <code>[&#39;buk,ki:piŋ]</code>簿记<br>boolean <code>[&#39;bu:liən]</code>布林值(真假值，true或false)<br>border <code>[&#39;bɔ:də]</code>边框                                               4<br>bounds checking <code>[baʊndz]``[&#39;tʃekiŋ]</code>边界检查<br>boxing 装箱、装箱转换<br>brace <code>[breis]</code>大括号 curly <code>[&#39;kə:li]</code> brace花括号<br>bracket <code>[&#39;brækit]</code> (square [skwεə] brakcet) 中括号、方括号<br>breakpoint <code>[&#39;breikpɔint]</code>断点<br>browser applications <code>[&#39;brauzə]``[æpli&#39;keiʃəns]</code>浏览器应用(程序)<br>browser-accessible <code>[ək&#39;sesəbl]</code> application 可经由浏览器访问的应用程序<br>build 编连(专指编译和连接<br>built-in <code>[,bɪlt &#39;ɪn]</code>内建、内置<br>bus 总线<br>business 业务、商务(看场合)<br>business Logic <code>[&#39;lɔdʒik]</code>业务逻辑<br>business rules 业务规则<br>buttons 按钮<br>bug 臭虫<br>by/through 通过<br>byte 位元组(由8 bits组成)<br>cache <code>[kæʃ]</code> 高速缓存<br>calendar <code>[&#39;kælində]</code>日历<br>call 调用<br>callback<code>[&#39;kɔ:lbæk]</code> 回调<br>call-level interface (CLI)调用级接口(CLI)<br>call operator 调用操作符<br>candidate key <code>[&#39;kændideit]</code> 候选键 (for database)<br>cascading delete <code>[kæ&#39;skeidiŋ]</code> 级联删除 (for database)<br>cascading update 级联更新 (for database)<br>casting <code>[&#39;kɑ:stiŋ]</code>  转型、造型转换<br>catalog <code>[&#39;kætəlɔɡ]</code>  目录<br>chain <code>[tʃein]</code> 链(function calls)<br>character <code>[&#39;kærəktə]</code> 字符<br>character format<code>[ˈfɔ:mæt]</code>  字符格式<br>character set     字符集<br>CHECK constraints <code>[kən&#39;streint]</code>CHECK约束 (for database)<br>checkpoint <code>[&#39;tʃekpɔint]</code> 检查点 (for database)<br>check box 复选框<br>check button 复选按钮<br>child class 子类<br>CIL (common intermediate <code>[,intə&#39;mi:djət, -dieit]</code> language)通用中间语言、通用中介语言<br>class    类<br>class declaration <code>[,deklə&#39;reiʃən]</code> 类声明<br>class definition <code>[,defi&#39;niʃən]</code>  类定义<br>class derivation <code>[,deri&#39;veiʃən]</code> list 类继承列表<br>class factory    类厂                                        6<br>class hierarchy<code>[&#39;haiə,rɑ:ki]</code>类层次结构<br>class library  类库<br>class loader  类装载器<br>class template <code>[&#39;templit]</code>类模板<br>class template partial<code>[&#39;pɑ:ʃəl]</code> specializations <code>[,spɛʃəlɪ&#39;zeʃən]</code>类模板部分特化<br>class template specializations  类模板特化<br>classification <code>[ˌklæsifiˈkeiʃən]</code> 分类<br>clause <code>[klɔ:z]</code>子句<br>client <code>[&#39;klaiənt]</code> application 客户端应用程序<br>client cursor <code>[&#39;kə:sə]</code> 客户端游标 (for database)<br>code page 代码页<br>cleanup  清理、清除<br>CLI (Common Language Infrastructure <code>[&#39;infrə,strʌktʃə]</code>) 通用语言基础设施<br>client <code>[&#39;klaiənt]</code>客户、客户端<br>client area 客户区<br>client-server 客户机/服务器、客户端/服务器<br>clipboard <code>[&#39;klipbɔ:d]</code>剪贴板<br>clone <code>[kləun]</code>克隆<br>CLS (common language specification <code>[,spesifi&#39;keiʃən]</code>) 通用语言规范<br>code access security 代码访问安全<br>COFF (Common Object File Format)    通用对象文件格式             7<br>collection <code>[kə&#39;lekʃən]</code>集合<br>COM (Component <code>[kəm&#39;pəunənt]</code> Object Model) 组件对象模型<br>combo <code>[&#39;kɔmbəu]</code> box 组合框<br>command <code>[kə&#39;mɑ:nd]</code> line 命令行<br>comment<code>[ˈkɔment]</code> 注释<br>commit <code>[kə&#39;mit]</code>提交 (for database)<br>communication <code>[kə,mju:ni&#39;keiʃən]</code>通讯<br>compatible <code>[kəm&#39;pætəbl]</code>兼容<br>compiler <code>[kəm&#39;pail]</code>编译器<br>compile time 编译期、编译时<br>component<code>[kəm&#39;pəunənt]</code>组件<br>composite <code>[&#39;kɔmpəzit]</code> index 复合索引、组合索引 (for database)<br>composite key 复合键、组合键 (for database)<br>composition <code>[,kɔmpə&#39;ziʃən]</code>复合、组合<br>concept <code>[&#39;kɔnsept]</code>概念<br>concrete<code>[kən&#39;kri:t, &#39;kɔnkri:t]</code>具体的<br>concrete class 具体类<br>concurrency <code>[kən&#39;kʌrənsi]</code>并发、并发机制<br>constraint <code>[kən&#39;streint]</code>约束 (for database)<br>configuration <code>[kən,fiɡju&#39;reiʃən]</code>配置、组态<br>connection <code>[kə&#39;nekʃən</code>] 连接 (for database)<br>connection pooling 连接池                                        8<br>console <code>[kən&#39;səul]</code> 控制台<br>constant <code>[&#39;kɔnstənt]</code>常量<br>construct <code>[kən&#39;strʌkt]</code>构件、成分、概念、构造（for language）<br>constructor (ctor) <code>[kɔn&#39;strʌktə]</code>构造函数、构造器<br>container <code>[kən&#39;teinə]</code> 容器<br>containment<code>[kən&#39;teinmənt]</code>包容<br>context <code>[&#39;kɔntekst]</code>环境、上下文<br>control <code>[kən&#39;trəul]</code>控件<br>cookie <code>[&#39;kuki]</code> (不译)<br>copy    拷贝<br>CORBA   通用对象请求中介架构<br>(Common Object Request<code>[ri&#39;kwest]</code>Broker Architecture)<br>cover   覆盖、涵盖<br>create/creation <code>[kri:&#39;eiʃən]</code>创建、生成<br>crosstab query <code>[&#39;kwiəri]</code>交叉表查询 (for database)<br>CRTP<br>(curiously recurring <code>[rɪ&#39;kɝɪŋ]</code>template <code>[&#39;templit]</code> pattern <code>[&#39;pætən]</code>)<br>CTS (common type system)通用类型系统<br>cube<code>[kju:b]</code>多维数据集 (for database)<br>cursor<code>[&#39;kə:sə]</code>光标<br>cursor 游标 (for database)<br>custom<code>[&#39;kʌstəm]</code>定制、自定义                            9<br>data   数据<br>data connection   数据连接 (for database)<br>Data Control Language (DCL) 数据控制语言(DCL) (for database)<br>Data Definition<code>[,defi&#39;niʃən]</code>Language (DDL) 数据定义语言(DDL) (for database)<br>data dictionary <code>[&#39;dikʃənəri]</code>数据字典 (for database)<br>data dictionary view 数据字典视图 (for database)<br>data file 数据文件 (for database)<br>data integrity<code>[inˈteɡriti]</code>数据完整性 (for database)<br>data manipulation <code>[mə,nipju&#39;leiʃən]</code> language (DML)数据操作语言(DML) (for database)<br>data mart 数据集市 (for database)<br>data pump <code>[pʌmp]</code>数据抽取 (for database)<br>data scrubbing <code>[skrʌbliŋ]</code>数据清理 (for database)<br>data source <code>[sɔ:s]</code>数据源 (for database)<br>Data source name (DSN) 数据源名称(DSN) (for database)<br>data warehouse <code>[&#39;wεəhaus, &#39;wεəhauz, -haus]</code>数据仓库 (for database)<br>dataset   数据集 (for database)<br>database 数据库 (for database)<br>database catalog 数据库目录 (for database)<br>database diagram <code>[&#39;daiəɡræm]</code> 数据关系图 (for database)<br>database file 数据库文件 (for database)<br>database object 数据库对象 (for database)<br>database owner 数据库所有者 (for database)<br>database project <code>[&#39;prɔdʒekt]</code>数据库工程 (for database)<br>database role 数据库角色 (for database)<br>database schema<code>[&#39;ski:mə]</code>数据库模式、数据库架构 (for database)<br>database script <code>[skript]</code>数据库脚本 (for database)<br>data-bound 数据绑定 (for database)<br>data-aware control数据感知控件 (for database)<br>data member 数据成员、成员变量<br>dataset 数据集 (for database)<br>data source 数据源 (for database)<br>data structure<code>[&#39;strʌktʃə]</code>数据结构<br>data table 数据表 (for database)<br>datagram <code>[&#39;deitəɡræm]</code>数据报文<br>DBMS (database management system)数据库管理系统 (for database)<br>DCOM (distributed <code>[di&#39;stribjutid]</code> COM)分布式COM<br>dead lock 死锁 (for database)<br>Deallocate <code>[de&#39;elkeit]</code>归还<br>debug 调试<br>debugger 调试器<br>decay <code>[di&#39;kei]</code>退化<br>decision <code>[di&#39;siʒən]</code>support <code>[sə&#39;pɔ:t]</code> 决策支持                11<br>declaration <code>[,deklə&#39;reiʃən]</code>声明<br>Declarative<code>[dɪˈklærətɪv]</code>referential <code>[,refə&#39;renʃəl]</code> integrity <code>[in&#39;teɡrəti]</code>(DRI)声明引用完整性(DRI) (for database)<br>deduction <code>[di&#39;dʌkʃən]</code>推导<br>Deafault <code>[di&#39;fɔ:lt]</code> constraint默认约束 (for database)<br>default database 默认数据库 (for database)<br>default instance <code>[&#39;instəns]</code>默认实例 (for database)<br>default result set 默认结果集 (for database)<br>default 缺省、默认值<br>defer 推迟<br>definition <code>[,defi&#39;niʃən]</code>定义<br>delegate <code>[&#39;deliɡeit]</code>委托<br>delegation 委托<br>dependent name<br>deploy <code>[di:&#39;plɔi]</code>部署<br>dereference<code>[di&#39;refərəns]</code>解引用<br>dereference operator (提领)运算子<br>derived class 派生类<br>design by contract 契约式设计<br>design pattern <code>[&#39;pætən]</code>设计模式<br>destroy <code>[di&#39;strɔi]</code>销毁<br>destructor(dtor)<code>[di&#39;strʌktə]</code>析构函数、析构器                12<br>device <code>[di&#39;vais]</code>设备<br>DHTML<br>(dynamic <code>[dai&#39;næmik]</code>HyperText <code>[&#39;haipətekst]</code>Markup Language)动态超文本标记语言<br>dialog <code>[&#39;daiəlɔɡ]</code>对话框<br>digest<code>[daiˈdʒest]</code>摘要<br>digital 数字的<br>DIME<br>(Direct Internet Message Encapsulation <code>[in,-kæpsə&#39;leiʃən]</code>)<br>直接Internet消息封装<br>directive <code>[di&#39;rektiv, dai-]</code> (编译)指示符<br>directory <code>[di&#39;rektəri, dai-]</code>目录<br>dirty pages脏页 (for database)<br>dirty read 脏读 (for database)<br>disassembler <code>[,disə&#39;semblə]</code>反汇编器<br>DISCO (Discovery of Web Services)Web Services的查找<br>disk 盘<br>dispatch <code>[dis&#39;pætʃ]</code>调度、分派、派发（我喜欢“调度”）<br>DISPID (Dispatch<code>[dis&#39;pætʃ]</code> Identifier<code>[ai&#39;dentifaiə]</code>)分派标识符<br>distributed <code>[di&#39;stribjutid]</code> computing <code>[kəm&#39;pju:tiŋ]</code>分布式计算<br>distributed query分布式查询 (for database)<br>DNA (Distributed interNet Application)                            13<br>分布式网间应用程序<br>document <code>[&#39;dɔkjumənt, &#39;dɔkjument]</code>文档<br>DOM (Document Object Model)文档对象模型<br>dot operator<code>[&#39;ɔpəreitə]</code> (圆)点操作符<br>driver 驱动(程序)<br>DTD (document type definition <code>[,defi&#39;niʃən]</code>) 文档类型定义<br>double-byte character set (DBCS)双字节字符集(DBCS)<br>dump <code>[dʌmp]</code> 转储<br>dump file 转储文件<br>dynamic <code>[dai&#39;næmik]</code> cursor <code>[&#39;kə:sə]</code>动态游标 (for database)<br>dynamic filter <code>[filtə]</code>动态筛选 (for database)<br>dynamic locking   动态锁定 (for database)<br>dynamic recovery<code>[ri&#39;kʌvəri]</code> 动态恢复 (for database)<br>dynamic snapshot <code>[&#39;snæpʃɔt]</code> 动态快照 (for database)<br>dynamic SQL statements<code>[&#39;steitmənt]</code>动态SQL语句 (for database)<br>dynamic assembly 动态装配件、动态配件<br>dynamic binding 动态绑定<br>EAI (enterprise<code>[ˈentəpraɪz]</code> application integration <code>[,inti&#39;ɡreiʃən]</code>)企业应用程序集成(整合)<br>EBCO (empty base class optimization <code>[,ɔptimai&#39;zeiʃən, -mi&#39;z-]</code>)空基类优化（机制）<br>e-business   电子商务                                  14<br>EDI (Electronic <code>[,ilek&#39;trɔnik]</code> Data Interchange <code>[,intə&#39;tʃeindʒ, &#39;intətʃeindʒ]</code>)电子数据交换<br>efficiency <code>[i&#39;fiʃənsi]</code>效率<br>efficient <code>[i&#39;fiʃənt]</code>高效<br>end-to-end authentication<code>[ɔː,θentɪ&#39;keɪʃən]</code> 端对端身份验证<br>end user 最终用户<br>engine 引擎<br>entity <code>[&#39;entəti]</code> 实体<br>encapsulation <code>[in,-kæpsə&#39;leiʃən]</code>封装<br>enclosing<code>[ɪn&#39;kləʊziŋ]</code> class 外围类别(与巢状类别 nested class有关)<br>enum (enumeration <code>[i,nju:mə&#39;reiʃən]</code>) 枚举<br>enumerators <code>[i&#39;nju:mə,reitəz]</code> 枚举成员、枚举器<br>equal <code>[&#39;i:kwəl]</code>相等<br>equality<code>[i:&#39;kwɔləti]</code>相等性<br>equality operator 等号操作符<br>error<code>[&#39;erə]</code> log错误日志 (for database)<br>escape code 转义码<br>escape character 转义符、转义字符<br>exclusive<code>[ik&#39;sklu:siv]</code> lock   排它锁 (for database)<br>explicit <code>[ik&#39;splisit]</code> transaction <code>[træn&#39;zækʃən]</code> 显式事务 (for database)<br>evaluate <code>[i&#39;væljueit]</code>评估<br>event 事件<br>event driven 事件驱动的<br>event handler <code>[&#39;hændlə]</code>事件处理器<br>evidence <code>[&#39;evidəns]</code>证据<br>exception <code>[ik&#39;sepʃən]</code> 异常<br>exception declaration <code>[,deklə&#39;reiʃən]</code>异常声明<br>exception handling <code>[&#39;hændliŋ]</code>异常处理、异常处理机制<br>exception-safe 异常安全的<br>exception specification <code>[,spesifi&#39;keiʃən]</code>异常规范<br>exit  退出<br>explicit <code>[ik&#39;splisit]</code> 显式<br>explicit specialization <code>[,speʃəlai&#39;zeiʃən]</code> 显式特化<br>export <code>[ik&#39;spɔ:t]</code>导出<br>expression <code>[ik&#39;spreʃən]</code>表达式<br>facility <code>[fə&#39;siliti]</code> 设施、设备<br>fat client 胖客户端<br>feature <code>[&#39;fi:tʃə]</code>特性、特征<br>fetch <code>[fetʃ]</code>提取<br>field 字段(java)<br>field 字段 (for database)<br>field length 字段长度 (for database)<br>file   文件<br>filter <code>[filtə]</code>筛选 (for database)                                16<br>finalization<code>[ˌfaɪnl&#39;aɪzeʃən]</code> 终结<br>firewall <code>[&#39;faiəwɔ:l]</code> 防火墙<br>finalizer <code>[&#39;faɪnəlaɪzə]</code> 终结器<br>firmware<code>[&#39;fə:mwεə]</code>固件<br>flag  标记<br>flash memory 闪存<br>flush<code>[flʌʃ]</code> 刷新<br>font 字体<br>foreign key (FK) 外键(FK) (for database)<br>form 窗体<br>formal parameter <code>[pə&#39;ræmitə]</code> 形参<br>forward declaration 前置声明<br>forward-only 只向前的<br>forward-only cursor 只向前游标 (for database)<br>fragmentation <code>[,fræɡmen&#39;teiʃən]</code> 碎片 (for database)<br>framework <code>[&#39;freimwə:k]</code> 框架<br>full specialization 完全特化<br>function 函数<br>function call operator (即operator ()) 函数调用操作符<br>function object 函数对象<br>function overloaded <code>[&#39;əuvə&#39;ləudid]</code> resolution<code>[,rezə&#39;lu:ʃən]</code>函数重载决议<br>functionality <code>[,fʌŋkʃə&#39;næliti]</code>功能<br>function template函数模板<br>functor <code>[&#39;fʌŋktə]</code>仿函数<br>GAC (global assembly cache <code>[kæʃ]</code>)<br>全局装配件缓存、全局配件缓存<br>GC (Garbage collection)<br>垃圾回收(机制)、垃圾收集(机制)<br>game游戏<br>generate <code>[&#39;dʒenəreit]</code>生成<br>generic <code>[dʒi&#39;nerik]</code>泛化的、一般化的、通用的<br>generic algorithm<code>[&#39;ælɡəriðəm]</code>通用算法<br>genericity <code>[&#39;dʒenerisity]</code> 泛型<br>getter (相对于 setter)取值函数<br>global<code>[&#39;ɡləubəl]</code>全局的<br>global object 全局对象<br>global scope <code>[skəup]</code> resolution operator 全局范围解析操作符<br>grant <code>[ɡrɑ:nt, ɡrænt]</code>授权 (for database)<br>granularity<code>[ˌɡrænjuˈlæriti]</code> 粒度<br>group 组、群<br>group box 分组框<br>GUI  图形界面<br>GUID (Globally Unique <code>[ju:&#39;ni:k]</code> Identifier<code>[ai&#39;dentifaiə]</code>) 全球唯一标识符<br>hand shaking 握手                                       18<br>handle  句柄<br>handler 处理器<br>hard-coded 硬编码的<br>hard-copy 截屏图<br>hard disk 硬盘<br>hardware 硬件<br>hash table 散列表、哈希表<br>header file头文件<br>heap <code>[hi:p]</code>堆<br>help file 帮助文件<br>hierarchy <code>[&#39;haiə,rɑ:ki]</code>层次结构、继承体系<br>hierarchical <code>[,haiə&#39;rɑ:kikəl]</code> data 阶层式数据、层次式数据<br>hook[huk]钩子<br>Host (application)宿主(应用程序)<br>hot key 热键<br>hyperlink <code>[&#39;haipəliŋk]</code>超链接<br>HTML (HyperText <code>[&#39;haipətekst]</code> Markup Language) 超文本标记语言<br>HTTP pipeline <code>[&#39;paip,lain]</code>    HTTP管道<br>HTTP (HyperText Transfer Protocol) 超文本传输协议<br>icon 图标<br>IDE (Integrated Development Environment)集成开发环境<br>IDL (Interface Definition Language) 接口定义语言<br>identifier <code>[ai&#39;dentifaiə]</code>标识符<br>idle<code>[&#39;aidl]</code> time 空闲时间<br>if and only if当且仅当<br>IL (Intermediate Language) 中间语言、中介语言<br>image 图象<br>IME 输入法<br>immediate <code>[i&#39;mi:diət]</code> base 直接基类<br>immediate derived <code>[di&#39;raivd]</code> 直接派生类<br>immediate updating 即时更新 (for database)<br>implicit [im’plisit] transaction <code>[træn&#39;zækʃən]</code>隐式事务 (for database)<br>incremental<code>[ˌɪŋkrəˈmentl]</code> update 增量更新 (for database)<br>index 索引 (for database)<br>implement <code>[&#39;implimənt, &#39;impliment</code>]实现<br>implementation <code>[,implimen&#39;teiʃən]</code> 实现、实现品<br>implicit <code>[im&#39;plisit]</code>隐式<br>import 导入<br>increment <code>[&#39;inkrimənt</code>] operator 增加操作符<br>infinite <code>[&#39;infinət]</code> loop  无限循环<br>infinite recursive<code>[ri&#39;kə:siv]</code> 无限递归<br>information 信息<br>infrastructure <code>[&#39;infrə,strʌktʃə]</code>基础设施<br>inheritance <code>[in&#39;heritəns]</code>继承、继承机制                        20<br>inline <code>[&#39;in,lain]</code>内联<br>inline expansion 内联展开<br>initialization<code>[i,niʃəlai&#39;zeiʃən]</code>初始化<br>initialization list 初始化列表、初始值列表<br>initialize <code>[ɪ&#39;nɪʃəlaɪz]</code>初始化<br>inner <code>[&#39;inə]</code> join 内联接 (for database)<br>in-place active 现场激活<br>instance <code>[&#39;instəns]</code>实例<br>instantiated<code>[ɪns&#39;tænʃɪetid]</code>具现化、实体化(常应用于template)<br>instantiation<code>[inˌstænʃiˈeiʃən]</code>具现体、具现化实体(常应用于template)<br>integrate<code>[ˈɪntɪgreɪt]</code> 集成、整合<br>integrity<code>[ɪnˈtegrəti]</code> 完整性、一致性<br>integrity constraint完整性约束 (for database)<br>interprocess communication (IPC)进程间通讯(IPC)<br>interacts <code>[,intə&#39;rækts]</code>交互<br>interface 接口<br>for GUI 界面<br>interoperability<code>[ˈintərˌɔpərəˈbiləti]</code> 互操作性、互操作能力<br>interpreter<code>[in&#39;tə:pritə]</code>解释器<br>introspection <code>[,intrəu&#39;spekʃən]</code>自省<br>invariants<code>[in&#39;vεəriənts]</code>不变性                                  21<br>invoke <code>[in&#39;vəuk]</code>调用<br>isolation <code>[ˌaɪsəˈleɪʃn]</code> level 隔离级别 (for database)<br>iterate <code>[&#39;itəreit]</code>迭代<br>iterative <code>[&#39;itərətiv]</code>反复的、迭代的<br>iterator <code>[ɪtə&#39;retɚ]</code>迭代器<br>iteration <code>[,itə&#39;reiʃən]</code> 迭代(回圈每次轮回称为一个iteration)<br>item 项、条款、项目<br>JIT compilation <code>[ˌkɔmpəˈleɪʃən]</code> JIT编译 即时编译<br>key  键 (for database)<br>key column  键列 (for database)<br>laser 激光<br>late binding 迟绑定<br>left outer join 左向外联接 (for database)<br>level 阶、层例<br>high level 高阶、高层<br>library 库<br>lifetime 生命期、寿命<br>link 连接、链接<br>linkage <code>[&#39;liŋkidʒ]</code>连接、链接<br>linker 连接器、链接器<br>literal <code>[&#39;litərəl]</code> constant 字面常数<br>list 列表、表、链表                                       22<br>list box 列表框<br>livelock 活锁 (for database)<br>load 装载、加载<br>load balancing <code>[&#39;bælənsiŋ]</code> 负载平衡<br>loader 装载器、载入器<br>local 局部的<br>local object 局部对象<br>lock 锁<br>log 日志<br>login 登录<br>login security mode登录安全模式 (for database)<br>lookup table   查找表 (for database)<br>loop <code>[lu:p]</code>循环<br>loose coupling<code>[&#39;kʌpliŋ]</code> 松散耦合<br>lvalue 左值<br>machine code 机器码、机器代码<br>macro <code>[&#39;mækrəu]</code>宏<br>maintain <code>[mein&#39;tein]</code>维护<br>managed code 受控代码、托管代码<br>Managed Extensions <code>[ik&#39;stenʃəns]</code> 受控扩充件、托管扩展<br>managed object 受控对象、托管对象<br>mangled <code>[&#39;mæŋg(ə)l]</code> name<br>manifest<code>[&#39;mænifest]</code>清单<br>manipulator <code>[mə&#39;nipjuleitə]</code>操纵器(iostream预先定义的一种东西)<br>many-to-many relationship 多对多关系 (for database)<br>many-to-one relationship 多对一关系 (for database)<br>marshal <code>[&#39;mɑ:ʃəl]</code>列集<br>member 成员<br>member access operator 成员取用运算子(有dot和arrow两种)<br>member function  成员函数<br>member initialization list 成员初始值列表<br>memberwise 以member 为单元…、members 逐一…<br>memberwise copy<br>memory 内存<br>memory leak 内存泄漏<br>menu 菜单<br>message 消息<br>message based 基于消息的<br>message loop 消息环<br>message queuing<code>[kjuiŋ]</code>消息队列<br>metadata <code>[&#39;metədeɪtə]</code> 元数据<br>metaprogramming<code>[mɛtə&#39;prəuɡræmiŋ]</code>元编程<br>method <code>[&#39;meθəd]</code>方法<br>micro 微<br>middleware 中间件<br>middle tier中间层<br>modeling <code>[&#39;mɔdəliŋ]</code>建模<br>modeling language 建模语言<br>modifier <code>[&#39;mɔdifaiə]</code>修饰字、修饰符<br>modem<code>[ˈməudem]</code>调制解调器<br>module<code>[&#39;mɔdju:l]</code>模块<br>most derived <code>[di&#39;raivd]</code> class最底层的派生类<br>mouse 鼠标<br>mutable <code>[&#39;mju:təbl]</code>可变的<br>mutex<code>[&#39;mjutex]</code>   互斥元、互斥体<br>multidimensional <code>[ˌmʌltidiˈmenʃənl]</code> OLAP (MOLAP) 多维OLAP(MOLAP) (for database)<br>multithreaded<code>[ˌmʌltidiθ&#39;redid]</code> server application 多线程服务器应用程序<br>multiuser <code>[,mʌlti&#39;ju:zə]</code>多用户<br>multi-tasking 多任务<br>multi-thread 多线程<br>multicast <code>[&#39;mʌltikɑ:st]</code> delegate <code>[&#39;deliɡət]</code> 组播委托、多点委托<br>named parameter 命名参数<br>named pipe 命名管道<br>namespace 名字空间、命名空间<br>native 原生的、本地的<br>native code 本地码、本机码<br>Native Image Generator <code>[&#39;dʒenəreitə]</code> (NGEN)本地映像生成器<br>nested <code>[&#39;nestid]</code> class 嵌套类<br>nested query 嵌套查询 (for database)<br>nested table 嵌套表 (for database)<br>network 网络<br>network card 网卡<br>nondependent name<br>object 对象<br>object based 基于对象的<br>object file 目标文件<br>object model 对象模型<br>object oriented 面向对象的<br>object pooling 对象池化<br>ODBC data source ODBC数据源 (for database)<br>ODBC driver  ODBC驱动程序 (for database)<br>ODR (one-definition rule)<br>OLE Automation <code>[,ɔ:tə&#39;meiʃən]</code> objects<br>OLE自动化对象 (for database)<br>OLE Automation <code>[ˌɔ:təˈmeiʃən]</code> server<br>OLE(Object Linking and Embedding<code>[im&#39;bediŋ]</code>)<br>自动化服务器 (for database)<br>OLE DB consumer <code>[kən&#39;sju:mə]</code><br>OLE DB使用者 (for database)<br>OLE DB for OLAP 用于OLAP的OLE DB (for database)<br>OLE DB provider OLE DB提供者 (for database)<br>one-to-many relationship 一对多关系 (for database)<br>one-to-one relationship 一对一关系 (for database)<br>online analytical <code>[ˌænəˈlɪtɪkl]</code> processing (OLAP)    联机分析处理(OLAP) (for database)<br>online redo<code>[ri:ˈdu:]</code> log 联机重做日志 (for database)<br>online transaction processing (OLTP)   联机事务处理(OLTP) (for database)<br>Open Data Services (ODS)   开放式数据服务(ODS) (for database)<br>Open Database Connectivity <code>[,kɔnek&#39;tivəti]</code> (ODBC) 开放式数据库连接(ODBC) (for database)<br>operand <code>[&#39;ɔpərænd]</code>操作数<br>operating system (OS) 操作系统<br>operation 操作<br>operator   操作符、运算符<br>option <code>[&#39;ɔpʃən]</code>选项<br>optimizer <code>[&#39;ɔptimaizə]</code>优化器<br>outer join 外联接 (for database)<br>overflow <code>[,əuvə&#39;fləu]</code>上限溢位(相对于underflow)<br>overhead 额外开销<br>overload 重载<br>overload resolution 重载决议<br>overloaded function 重载的函数<br>overloaded operator 被重载的操作符<br>override <code>[,əuvə&#39;raid]</code>覆写、重载、重新定义<br>package <code>[&#39;pækidʒ]</code>包<br>packaging 打包<br>palette <code>[&#39;pælit]</code>调色板<br>parallel <code>[&#39;pærəlel]</code>并行<br>parameter <code>[pə&#39;ræmitə]</code>参数、形式参数、形参<br>parameter list 参数列表<br>parameterize <code>[pə&#39;ræmitəraiz]</code>参数化<br>parent class   父类<br>parentheses<code>[pəˈrenθɪsɪsiz]</code>圆括弧、圆括号<br>parse<code>[pɑ:z]</code>解析<br>parser <code>[&#39;pɑ:sə]</code>解析器<br>part  零件、部件<br>partial specialization 局部特化<br>pass by address 传址(函式引数的传递方式)(非正式用语)<br>pass by reference 传地址、按引用传递<br>pass by value 按值传递<br>pattern <code>[&#39;pætən]</code> 模式                                          28<br>PDA (personal digital <code>[&#39;didʒitəl]</code> assistant)个人数字助理<br>PE (Portable Executable[ˈeksikju:təbl]) file 可移植可执行文件<br>performance <code>[pə&#39;fɔ:məns]</code>性能<br>persistence <code>[pə&#39;sistəns]</code>持久性<br>PInvoke (platform invoke service) 平台调用服务<br>pixel <code>[&#39;piksəl]</code>像素<br>placement <code>[&#39;pleismənt]</code> delete<br>placement new<br>placeholder <code>[&#39;pleis,həuldə]</code>占位符<br>platform <code>[&#39;plætfɔ:m]</code>平台<br>POD (plain old data (type)) 简单旧数据类型<br>POI (point of instantiation<code>[in,stænʃieiʃən]</code>)<br>pointer 指针<br>poll <code>[pəul]</code>轮询<br>pooling 池化<br>polymorphism<code>[,pɒlɪ&#39;mɔːfɪz(ə)m]</code>多态<br>pop up 弹出式<br>port <code>[pɔ:t, pəut]</code>端口<br>postfix <code>[&#39;pəustfiks]</code>后缀<br>precedence <code>[&#39;presidəns, pri&#39;si:-]</code>优先序(通常用于运算子的优先执行次序)<br>prefix <code>[,pri:&#39;fiks, &#39;pri:fiks]</code>前缀<br>preprocessor <code>[,priː&#39;prəʊsesə]</code>预处理器<br>primary key (PK)主键(PK) (for database)<br>primary table   主表 (for database)<br>primary template原始模板<br>primitive <code>[&#39;primitiv]</code>type 原始类型<br>print 打印<br>printer 打印机<br>procedure   <code>[prə&#39;si:dʒə]</code>过程<br>procedural <code>[prə&#39;si:dʒərəl]</code> 过程式的、过程化的<br>process 进程<br>profile <code>[&#39;prəufail]</code>评测<br>profiler<code>[&#39;prəufailə]</code>效能(性能)评测器<br>program 程序<br>programmer 程序员<br>programming编程、程序设计<br>progress bar 进度指示器<br>project 项目、工程<br>property 属性<br>protocol <code>[&#39;prəutəkɔl]</code>协议<br>pseudo <code>[&#39;psju:dəu]</code> code伪码<br>qualified <code>[&#39;kwɔlifaid]</code> 经过资格修饰(例如加上scope运算子)<br>qualified name<br>qualifier <code>[&#39;kwɔlifaiə]</code>修饰符<br>quality 质量<br>queue <code>[kju:]</code>队列<br>race condition 竞争条件（多线程环境常用语）<br>radian<code>[&#39;reidiən]</code>弧度<br>radio button   单选按钮<br>raise <code>[reiz]</code>引发(常用来表示发出一个exception)<br>random number 随机数<br>range 范围、区间<br>rank  等级<br>raw <code>[rɔ:]</code>未经处理的<br>readOnly只读<br>record 记录 (for database)<br>recordset <code>[&#39;rekɔdset]</code> 记录集 (for database)<br>recursive <code>[ri&#39;kə:siv]</code>递归<br>re-direction 重定向<br>refactoring <code>[ri&#39;fæktəriŋ]</code>重构<br>refer 引用、参考<br>reference 引用、参考<br>reference counting引用计数<br>referential <code>[,refə&#39;renʃəl</code> integrity <code>[in&#39;teɡrəti]</code> (RI)引用完整性(RI) (for database)<br>register <code>[&#39;redʒistə</code>]寄存器<br>reflection 反射<br>refresh data 刷新数据 (for database)<br>regular expression 正则表达式<br>relational database 关系数据库<br>remote  远程<br>remote request 远程请求<br>represent 表述，表现<br>resolve  解析、决议<br>resolution <code>[,rezə&#39;lu:ʃən]</code>解析过程<br>result set   结果集 (for database)<br>retrieve <code>[ri&#39;tri:v]</code> data 检索数据<br>return  返回<br>return type 返回类型<br>return value 返回值<br>right outer join 右向外联接 (for database)<br>revoke <code>[ri&#39;vəuk]</code>撤销<br>robust <code>[rəu&#39;bʌst]</code>健壮<br>robustness <code>[rəʊ&#39;bʌstnɪs]</code>健壮性<br>roll back  回滚 (for database)<br>roll forward 前滚 (for database)<br>routine <code>[ru:&#39;ti:n]</code>例程<br>row  行 (for database)<br>row lock 行锁 (for database)                                32<br>rowset  行集 (for database)<br>RPC (remote <code>[ri&#39;məut]</code> procedure call)RPC(远程过程调用)<br>runtime 执行期、运行期、执行时、运行时<br>rvalue 右值<br>save 保存<br>savepoint 保存点 (for database)<br>SAX (Simple API for XML)<br>scalable <code>[&#39;skeiləbl]</code>可伸缩的、可扩展的<br>schedule <code>[&#39;ʃədju:əl]</code> 调度<br>scheduler <code>[&#39;ʃedju:ələ]</code> 调度程序<br>schema <code>[&#39;ski:mə]</code>模式、纲目结构<br>scroll bar滚动条<br>scope <code>[skəup]</code>作用域、生存空间<br>scope operator 生存空间操作符<br>scope resolution <code>[,rezə&#39;lu:ʃən]</code>operator 生存空间解析操作符<br>screen 屏幕<br>SDK (Software Development Kit)软件开发包<br>sealed <code>[si:ld]</code> class 密封类<br>search <code>[sə:tʃ]</code>查找<br>semantics <code>[si&#39;mæntiks]</code>语义<br>semaphore <code>[ˈseməˌfɔ:,]</code>信号量<br>sequential <code>[si&#39;kwenʃəl]</code>container序列式容器<br>server  服务器、服务端<br>serial<code>[&#39;siəriəl]</code>串行<br>serialization<code>[,siəriəlai&#39;zeiʃən ]</code>serialize 序列化<br>server cursor服务端游标、服务器游标 (for database)<br>session  会话 (for database)<br>setter<code>[&#39;setə]</code>设值函数<br>shared lock 共享锁 (for database)<br>sibling<code>[&#39;sibliŋ]</code>同级<br>side effect 副作用<br>signature<code>[&#39;signətʃə]</code>签名<br>single-threaded 单线程<br>slider<code>[&#39;slaidə]</code>滑块<br>slot<code>[slɔt]</code>槽<br>smart pointer<code>[&#39;pɔintə]</code>智能指针<br>SMTP (Simple Mail Transfer Protocol)   简单邮件传输协议<br>snapshot<code>[&#39;snæpʃɔt]</code>截屏图<br>snapshot  快照 (for database)<br>specialization<code>[,speʃəlai&#39;zeiʃən]</code>特化<br>specification<code>[,spesifi&#39;keiʃən]</code>规范、规格<br>splitter 切分窗口<br>SOAP (simple object access protocol <code>[&#39;prəutəkɔl]</code>)   简单对象访问协议<br>software  软件<br>source code 源码、源代码<br>SQL (Structured <code>[&#39;strʌktʃəd]</code> Query Language) 结构化查询语言 (for database)<br>stack<code>[stæk]</code>栈、堆栈<br>stack unwinding <code>[ʌn&#39;waindiʃ]</code>叠辗转开解(此词用于exception主题)<br>standard library 标准库<br>standard template library 标准模板库<br>stateless<code>[&#39;steɪtlɪs]</code>无状态的<br>statement <code>[&#39;steitmənt]</code>语句、声明<br>static cursor 静态游标 (for database)<br>static SQL statements 静态SQL语句 (for database)<br>stored <code>[stɔ:d]</code>procedure 存储过程 (for database)<br>status<code>[&#39;steitəs]</code>bar 状态条<br>stream<code>[stri:m]</code>流<br>string  字符串<br>stub 存根<br>subobject<code>[&#39;sʌb&#39;ɔbdʒikt]</code>子对象<br>subquery 子查询 (for database)<br>subroutine<code>[&#39;sʌbruːtiːn]</code>子例程<br>subscript operator 下标操作符<br>subset  子集<br>subtype 子类型<br>support 支持<br>suspend<code>[sə&#39;spend]</code>挂起<br>symbol   记号<br>syntax<code>[&#39;sintæks]</code>语法<br>system databases 系统数据库 (for database)<br>system tables 系统表 (for database)<br>table 表 (for database)<br>table lock 表锁 (for database)<br>table-level constraint 表级约束 (for database)<br>tape backup 磁带备份 (for database)<br>target 标的,目标<br>task switch 工作切换<br>TCP (Transport Control Protocol <code>[&#39;prəutəkɔl]</code>) 传输控制协议<br>template<code>[&#39;templit]</code>模板<br>template-id<br>template argument deduction<code>[di&#39;dʌkʃən]</code>模板参数推导<br>template explicit<code>[ik&#39;splisit]</code>specialization 模板显式特化<br>template parameter   模板参数<br>template template parameter<br>temporary<code>[&#39;tempərəri]</code>object 临时对象<br>temporary table 临时表 (for database)<br>text 文本<br>text file 文本文件<br>thin client 瘦客户端<br>third-party 第三方<br>thread 线程<br>thread-safe 线程安全的<br>throw 抛出、引发(常指发出一个exception)<br>token 符号、标记、令牌（看场合）<br>trace 跟踪<br>transaction<code>[træn&#39;zækʃən]</code>事务 (for database)<br>transaction log 事务日志 (for database)<br>transaction rollback<code>[&#39;rəulbæk]</code>事务回滚 (for database)<br>transactional replication<code>[,repli&#39;keiʃən]</code>事务复制 (for database)<br>translation unit 翻译单元<br>traverse<code>[&#39;trævəs, -və:s, trə&#39;və:s, træ-]</code>遍历<br>trigger<code>[&#39;triɡə]</code>触发器 (for database)<br>two-phase<code>[feiz]</code>commit 两阶段提交 (for database)<br>tuple<code>[&#39;tʌpl]</code>n. 元组，重数<br>two-phase<code>[feiz]</code>lookup 两阶段查找<br>type 类型<br>UDDI(Universary<code>[feiz]</code>Description, Discovery and Integration<code>[,inti&#39;ɡreiʃən]</code>)统一描述、查询与集成<br>UML (unified<code>[&#39;ju:nifaid]</code>modeling language)统一建模语言<br>unary<code>[&#39;ju:nəri]</code>function 单参函数<br>unary operator 一元操作符<br>unboxing<code>[,ʌn&#39;bɔks ɪŋ]</code>箱、拆箱转换<br>underflow 下限溢位(相对于overflow)<br>Union<code>[&#39;ju:niən]</code>query  联合查询 (for database)<br>UNIQUE <code>[ju:&#39;ni:k]</code>constraints UNIQUE约束 (for database)<br>unique index 唯一索引 (for database)<br>unmanaged code 非受控代码、非托管代码<br>unmarshal<code>[ʌn &#39;mɑrʃəl]</code>散集<br>unqualified <code>[,ʌn&#39;kwɔlifaid]</code>未经限定的、未经修饰的<br>URI (Uniform Resource identifier [ai’dentifaiə]) 统一资源标识符<br>URL (Uniform Resource Locator)    统一资源定位器<br>user  用户<br>user interface 用户界面<br>value types 值类型<br>variable<code>[&#39;vεəriəbl]</code>变量<br>vector<code>[&#39;vektə]</code>向量(一种容器，有点类似array)<br>viable<code>[&#39;vaiəbl]</code>可行的<br>video 视频<br>view  视图<br>VEE (Virtual Execution Engine)虚拟执行引擎<br>vendor <code>[&#39;vendɔ:]</code>厂商<br>view  视图 (for database)<br>virtual function 虚函数<br>virtual machine 虚拟机<br>virtual memory 虚拟内存<br>vowel<code>[&#39;vauəl]</code>元音字母<br>Web Services web服务<br>WHERE clause   WHERE子句 (for database)<br>wildcard<code>[&#39;waildka:d]</code>characters 通配符字符 (for database)<br>wildcard search  通配符搜索 (for database)<br>window  窗口<br>window function  窗口函数<br>window procedure  窗口过程<br>Windows authentication<code>[ɔː,θentɪ&#39;keɪʃən]</code>Windows身份验证<br>wizard<code>[&#39;wizəd]</code>向导<br>word 单词<br>word processor 字处理器<br>wrapper<code>[&#39;ræpə]</code>包装、包装器<br>write enable<code>[iˈneibl]</code>写启用 (for database)<br>write-ahead log 预写日志 (for database)<br>write-only只写<br>WSDL (Web Service Description Language)Web Service描述语言<br>XML(eXtensible<code>[ik&#39;stensəbl]</code>Message Interface (XMI)<br>XML消息接口<br>XML (extensible Markup Language) 可扩展标记语言<br>XSD (XML Schema<code>[&#39;ski:mə]</code>Definition) XML模式定义语言<br>XSL (extensible Stylesheet Language) 可扩展样式表语言<br>XSLT (extensible Stylesheet Language Transformation)可扩展样式表语言转换<br>xxx based  基于xxx的<br>xxx oriented 面向xxx<br>application<code>[ˌæplɪ&#39;keɪʃ(ə)n]</code>应用程式 应用、应用程序<br>application framework<code>[&#39;freɪmwɜːk]</code>应用程式框架、应用框架 应用程序框架<br>architecture<code>[&#39;ɑːkɪtektʃə]</code>架构、系统架构 体系结构<br>argument<code>[&#39;ɑːgjʊm(ə)nt]</code>引数（传给函式的值）<br>parameter 叁数、实质叁数、实叁、自变量<br>array<code>[ə&#39;reɪ]</code>阵列 数组<br>arrow<code>[&#39;ærəʊ]</code> 箭头<br>operator<code>[&#39;ɔpəreitə]</code>arrow运算子 箭头操作符<br>assembly<code>[ə&#39;semblɪ]</code>装配件<br>assembly language<code>[&#39;læŋgwɪdʒ]</code>组合语言 汇编语言<br>assert(ion)<code>[ə&#39;sɜːt]`` [ə&#39;sɜːʃ(ə)n]</code>断言<br>assign<code>[ə&#39;saɪn]</code>指派、指定、设值、赋值 赋值<br>assignment <code>[ə&#39;saɪnm(ə)nt]</code>指派、指定 赋值、分配<br>assignment operator <code>[&#39;ɒpəreɪtə]</code>指派（赋值）运算子 = 赋值操作符<br>associated <code>[ə&#39;soʃɪetɪd]</code>相应的、相关的 相关的、关联、相应的<br>associative <code>[ə&#39;səʊʃɪətɪv]</code> container [kən’teɪnə]关联式容器<br>sequential container 关联式容器<br>atomic<code>[ə&#39;tɔmik]</code>不可分割的 原子的<br>attribute<code>[ə&#39;trɪbjuːt]</code>属性、特性<br>audio<code>[&#39;ɔːdɪəʊ]</code>音讯 音频<br>A.I. 人工智慧 人工智能（artificial<code>[ɑ:ti&#39;fiʃəl]</code> intelligence<code>[ɪn&#39;telɪdʒ(ə)ns]</code>）<br>background<code>[&#39;bækgraʊnd]</code>背景 背景（用於图形着色）<br>backward <code>[&#39;bækwəd]</code> compatible<code>[kəm&#39;pætɪb(ə)l]</code>回溯相容 向下兼容<br>bandwidth<code>[&#39;bændwidθ]</code>频宽 带宽<br>base<code>[beis]</code>class<code>[klɑːs]</code>基础类别 基类<br>base type<code>[taip]</code>基础型别 (等同於 base class)<br>batch<code>[bætʃ]</code>批次（意思是整批作业） 批处理<br>benefit<code>[&#39;benɪfɪt]</code>利益 收益<br>best<code>[best]</code> viable<code>[&#39;vaiəbl]</code> function<code>[&#39;fʌŋ(k)ʃ(ə)n]</code>最佳可行函式<br>binary<code>[&#39;baɪnərɪ]</code> search<code>[sɜːtʃ]</code>二分搜寻法 二分查找<br>binary tree<code>[triː]</code>二元树 二叉树<br>binary function 二元函式 双叁函数<br>binary operator<code>[&#39;ɒpəreɪtə]</code>二元操作符<br>binding<code>[&#39;baɪndɪŋ]</code>系结 绑定<br>bit<code>[bɪt]</code>(发音为beit)位元 位<br>bit field<code>[fiːld]</code>位元栏 位域<br>bitmap<code>[&#39;bɪtmæp]</code>位元图 位图<br>bitwise 以 bit 为单元逐一┅<br>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝<br>block [英]<code>[blɔk]</code>&nbsp;<code>[美]``[blɑk]</code>&nbsp;区块,区段 块、区块、语句块<br>boolean<code>[&#39;bu:li:ən]</code>布林值（真假值，true 或 false） 布尔值<br>border<code>[&#39;bɔ:də]</code>边框、框线 边框<br>curly<code>[&#39;kə:li]</code>brace <code>[breis]</code>大括弧、大括号 花括弧、花括号<br>square<code>[skwεə]</code> bracket <code>[&#39;brækit]</code>中括弧、中括号 方括弧、方括号<br>breakpoint<code>[&#39;breikpɔint]</code>中断点 断点<br>build<code>[bild]</code>建造、构筑、建置（MS 用语）<br>build－in 内建 内置<br>bus 汇流排 总线<br>business<code>[&#39;bɪznɪs]</code>商务,业务 业务<br>buttons<code>[bʌtəns]</code>按钮 按钮<br>byte<code>[bait]</code> 字节   位元组（由 8 bits 组成）<br>cache<code>[kæʃ]</code> 快取 高速缓存<br>call<code>[kɔ:l]</code> 调用 呼叫、叫用<br>callback<code>[&#39;kɔ:lbæk]</code> 回调 回呼<br>operator<code>[&#39;ɔpəreitə]</code> call（函式呼叫）运算子调用操作符 （同 function call operator）<br>candidate<code>[&#39;kændidit]</code> function 候选函式 候选函数 （在函式多载决议程序中出现的候选函式）<br>chain<code>[tʃein]</code>串链（例 chain of function calls）链<br>character <code>[&#39;kærəktə]</code> 字符 字元<br>check <code>[tʃek]</code> box复选框 核取方块 (i.e. check button)<br>checked <code>[tʃekt]</code> exception<code>[ik&#39;sepʃən]</code>可控式异常 (Java)<br>check button <code>[&#39;bʌtən]</code> 复选按钮 方钮 (i.e. check box)<br>child <code>[tʃaild]</code> class 子类别（或称为derived <code>[di&#39;raivd]</code> class, subtype <code>[&#39;sʌbtaip]</code>图表类型)子类<br>class <code>[klɑ:s]</code>类别 类<br>class body 类别本体 类体<br>class declaration<code>[,deklə&#39;reiʃən]</code>类声明 类别宣告、类别宣告式<br>class definition<code>[,defi&#39;niʃən]</code>类定义 类别定义、类别定义式<br>class derivation<code>[,deri&#39;veiʃən]</code>list类继承列表 类别衍化列<br>class head <code>[hed]</code>类头 类别表头<br>class hierarchy<code>[&#39;haiərɑ:ki]</code>类别继承体系, 类别阶层 类层次体系<br>class library<code>[&#39;laibrəri]</code> 类库 类别程式库、类别库<br>class template<code>[&#39;templit]</code>类别模板、类别范本 类模板<br>class template partial <code>[&#39;pɑ:ʃəl]</code> specializations <code>[&#39;speʃəlaiz]</code>类别模板偏特化 类模板部分特化<br>class template specializations 类别模板特化 类模板特化<br>cleanup<code>[&#39;kli:nʌp]</code>清理、善後 清理、清除<br>client<code>[&#39;klaiənt]</code>客户端、客端、客户 客户<br>client－server <code>[&#39;sə:və]</code>主从架构 客户/服务器<br>clipboard <code>[&#39;klipbɔ:d]</code> 剪贴板 剪贴簿<br>clone<code>[kləun]</code>复制 克隆<br>collection<code>[kə&#39;lekʃən]</code>集合 群集<br>combo<code>[&#39;kɔmbəu]</code> box <code>[bɔks]</code>复合方块 复合框 组合框<br>command <code>[kə&#39;mɑ:nd]</code> line <code>[lain]</code> 命令行 命令列 (系统文字模式下的整行执行命令)<br>communication <code>[kə,mju:ni&#39;keiʃən]</code>通讯<br>compatible <code>[kəm&#39;pætəbl]</code> 兼容 相容<br>compile <code>[kəm&#39;pail]</code>time 编译期 编译期、编译时<br>compiler <code>[kəm&#39;pailə]</code>编译器 编译器<br>component<code>[kəm&#39;pəunənt]</code>组件 组件<br>composition<code>[,kɔmpə&#39;ziʃən]</code> 复合、合成、组合 组合<br>computer <code>[kəm&#39;pju:tə]</code>电脑、计算机 计算机、电脑<br>concept <code>[&#39;kɔnsept]</code>概念 概念<br>concrete <code>[kən&#39;kri:t]</code>具象的 实在的<br>concurrent <code>[kən&#39;kʌrənt]</code>并行 并发<br>configuration <code>[kən,fiɡju&#39;reiʃən]</code> 配置 组态<br>connection <code>[kə&#39;nekʃən]</code>连接，连线（网络,资料库） 连接<br>constraint<code>[kən&#39;streint]</code>  约束（条件）<br>construct <code>[kən&#39;strʌkt]</code>构件 构件<br>container <code>[kən&#39;teinə]</code>容器 容器 （存放资料的某种结构如 list, vector…）<br>containment <code>[kən&#39;teinmənt]</code>内含 包容<br>context<code>[&#39;kɔntekst]</code> 背景关系、周遭环境、上下脉络 环境、上下文<br>control<code>[kən&#39;trəul]</code>控制元件、控件 控件<br>console <code>[kən&#39;səul]</code>主控台 控制台<br>const <code>[&#39;kɔnstənt]</code>常数（constant 的缩写，C++ 关键字）<br>constant<code>[&#39;kɔnstənt]</code> 常数（相对於 variable） 常量<br>constructor<code>[kɔn&#39;strʌktə]</code>（ctor） 建构式 构造函数 （与class 同名的一种 member functions）<br>copy<code>[&#39;kɔpi]</code> (v) 复制、拷贝 拷贝<br>copy (n) 复件, 副本<br>cover<code>[&#39;kʌvə]</code> 涵盖 覆盖<br>create <code>[kri&#39;eit]</code>创建、建立、产生、生成 创建<br>creation <code>[kri:&#39;eiʃən]</code>产生、生成 创建<br>cursor <code>[&#39;kə:sə]</code>游标 光标<br>custom<code>[&#39;kʌstəm]</code>订制、自定 定制<br>data<code>[&#39;deitə]</code>资料 数据<br>database<code>[&#39;deitəbeis]</code>资料库 数据库<br>database schema <code>[&#39;ski:mə]</code>数据库结构纲目<br>data member <code>[&#39;membə]</code> 资料成员、成员变数 数据成员、成员变量<br>data structure <code>[&#39;strʌktʃə]</code>资料结构 数据结构<br>datagram <code>[&#39;deitəɡræm]</code>资料元 数据报文<br>dead <code>[ded]</code> lock <code>[lɔk]</code>死结 死锁<br>debug <code>[di:&#39;bʌɡ]</code>除错 调试<br>debugger <code>[di:&#39;bʌɡə]</code>除错器 调试器<br>declaration<code>[,deklə&#39;reiʃən]</code>宣告、宣告式 声明<br>deduction<code>[di&#39;dʌkʃən]</code>推导（例：template argument deduction)推导、推断<br>default<code>[di&#39;fɔ:lt]</code>预设 缺省、默认<br>defer<code>[di&#39;fə:]</code> 延缓 推迟<br>define<code>[di&#39;fain]</code>定义 预定义<br>definition<code>[,defi&#39;niʃən]</code>定义、定义区、定义式 定义<br>delegate<code>[&#39;deliɡeit]</code>委派、委托、委任 委托<br>delegation<code>[,deli&#39;ɡeiʃən]</code>同上）<br>demarshal 反编列 散集<br>dereference <code>[di&#39;refərəns]</code>提领（取出指标所指物体的内容)解叁考<br>derived <code>[di&#39;raivd]</code> class 衍生类别 派生类<br>design <code>[di&#39;zain]</code> by contract <code>[kən&#39;trækt]</code>契约式设计<br>design <code>[di&#39;zain]</code> pattern <code>[&#39;pætən]</code> 设计范式、设计样式 设计模式<br>destroy <code>[di&#39;strɔi]</code> 摧毁、销毁<br>destructor <code>[di&#39;strʌktə]</code> 解构式 析构函数<br>device <code>[di&#39;vais]</code> 装置、设备 设备<br>dialog <code>[&#39;daiəlɔɡ]</code>对话窗、对话盒 对话框<br>directive <code>[di&#39;rektiv]</code> 指令（例：using directive） (编译)指示符<br>directory <code>[di&#39;rektəri]</code> 目录 目录<br>disk <code>[disk]</code> 碟 盘<br>dispatch <code>[dis&#39;pætʃ]</code> 分派 分派<br>distributed <code>[di&#39;stribjutid]</code> computing <code>[kəm&#39;pju:tiŋ]</code> 分布式计算 (分布式电算) 分布式计算<br>分散式计算 (分散式电算)<br>document <code>[&#39;dɔkjumənt]</code>文件 文档<br>dot <code>[dɔt]</code> operator<code>[&#39;ɔpəreitə]</code> dot（句点）运算子 . (圆)点操作符<br>driver <code>[draivə]</code>驱动程式 驱动（程序）<br>dynamic<code>[dai&#39;næmik]</code> binding <code>[&#39;baindiŋ]</code> 动态系结 动态绑定<br>efficiency <code>[i&#39;fiʃənsi]</code> 效率 效率<br>efficient <code>[i&#39;fiʃənt]</code>高效 高效<br>end <code>[end]</code> user <code>[&#39;ju:zə]</code>终端用户<br>entity <code>[&#39;entəti]</code> 物体 实体、物体<br>encapsulation <code>[in,-kæpsə&#39;leiʃən]</code> 封装 封装<br>enclosing <code>[in&#39;kləuz]</code> class 外围类别（与巢状类别 nested <code>[&#39;nestid]</code>( 嵌套的) class 有关）外围类<br>enum (enumeration <code>[i,nju:mə&#39;reiʃən]</code>) 枚举 列举（一种 C++ 资料型别）枚举<br>enumerators <code>[i&#39;nju:məreitə]</code>列举元（enum 型别中的成员） 枚举成员、枚举器<br>equal <code>[&#39;i:kwəl]</code> 相等 相等<br>equality <code>[i:&#39;kwɔləti]</code>相等性 相等性<br>operator <code>[&#39;ɔpəreitə]</code> equality（等号）运算子 == 等号操作符<br>equivalence <code>[i&#39;kwivələns]</code> 等价性、等同性、对等性 等价性<br>equivalent <code>[i&#39;kwivələnt]</code>等价、等同、对等 等价<br>escape <code>[i&#39;skeip]</code> code 转义码 转义码<br>evaluate <code>[i&#39;væljueit]</code> 评估、求值、核定 评估<br>application 应用程式 应用、应用程序﻿<br>application framework 应用程式框架、应用框架 应用程序框架﻿<br>architecture 架构、系统架构 体系结构﻿<br>argument 参数（传给函式的值）<br>array 阵列 数组﻿<br>arrow operator arrow（箭头）运算子 箭头操作符﻿<br>assembly 装配件﻿<br>assembly language 组合语言 汇编语言﻿<br>assert(ion) 断言﻿<br>assign 指派、指定、设值、赋值 赋值﻿<br>assignment 指派、指定 赋值、分配﻿<br>assignment operator 指派（赋值）运算子 = 赋值操作符﻿<br>associated 相应的、相关的 相关的、关联、相应的﻿<br>associative container 关联式容器（对应 sequential container）关联式容器﻿<br>atomic不可分割的 原子的﻿<br>attribute 属性 属性、特性﻿<br>audio 音讯 音频﻿<br>A.I. 人工智慧 人工智能﻿<br>background 背景 背景（用於图形着色）後台（用於行程）﻿<br>backward compatible 回溯相容 向下兼容﻿<br>bandwidth 频宽 带宽﻿<br>base class 基础类别 基类﻿<br>base type 基础型别 (等同於﻿<br>base class) batch 批次（意思是整批作业） 批处理﻿<br>benefit 利益 收益﻿<br>best viable function 最佳可行函式 最佳可行函式﻿<br>binary search 二分搜寻法 二分查找﻿<br>binary tree 二元树 二叉树﻿<br>binary function 二元函式 双叁函数﻿<br>binary operator 二元运算子 二元操作符﻿<br>binding 系结 绑定﻿<br>bit 位元 位﻿<br>bit field 位元栏 位域﻿<br>bitmap 位元图 位图﻿<br>bitwise 以 bit 为单元逐一﻿<br>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝﻿<br>block 区块,区段 块、区块、语句块﻿<br>boolean 布林值（真假值，true 或 false）布尔值<br>border 边框、框线 边框﻿<br>brace(curly brace) 大括弧、大括号 花括弧、花括号﻿<br>bracket(square bracket) 中括弧、中括号 方括弧、方括号﻿<br>breakpoint 中断点 断点﻿<br>build 建造、构筑、建置（MS 用语）﻿<br>build－in 内建 内置﻿<br>bus 汇流排 总线﻿<br>business 商务,业务 业务﻿<br>buttons 按钮 按钮﻿<br>byte 位元组（由 8 bits 组成） 字节﻿<br>cache 快取 高速缓存﻿<br>call 呼叫、叫用 调用﻿<br>callback 回呼 回调﻿<br>call operator call（函式呼叫）运算子调用操作符﻿<br>candidate function 候选函式 候选函数﻿<br>chain 串链（例 chain of function calls） 链﻿<br>character 字元 字符﻿<br>check box 核取方块 (i.e. check button) 复选框﻿<br>checked exception 可控式异常﻿<br>check button 方钮 (i.e. check box) 复选按钮﻿<br>child class 子类别（或称为derived class, subtype） 子类﻿<br>class 类别 类﻿<br>class body 类别本体 类体﻿<br>class declaration 类别宣告、类别宣告式 类声明﻿<br>class definition 类别定义、类别定义式 类定义﻿<br>class derivation list 类别衍化列 类继承列表﻿<br>class head 类别表头 类头﻿<br>class hierarchy 类别继承体系, 类别阶层 类层次体系﻿<br>class library 类别程式库、类别库 类库﻿<br>class template 类别模板、类别范本 类模板﻿<br>class template partial specializations 类别模板偏特化 类模板部分特化﻿<br>class template specializations 类别模板特化 类模板特化﻿<br>cleanup 清理、善後 清理、清除﻿<br>client 客端、客户端、客户 客户﻿<br>client－server 主从架构 客户/服务器﻿<br>clipboard 剪贴簿 剪贴板﻿<br>clone 复制 克隆﻿<br>collection 群集 集合﻿<br>combo box 复合方块、复合框 组合框﻿<br>command line 命令列 命令行(系统文字模式下的整行执行命令)﻿<br>communication 通讯 通讯﻿<br>compatible 相容 兼容﻿<br>compile time 编译期 编译期、编译时﻿<br>compiler 编译器 编译器﻿<br>component 组件 组件﻿<br>composition 复合、合成、组合 组合﻿<br>computer 电脑、计算机 计算机、电脑﻿<br>concept 概念 概念﻿<br>concrete 具象的 实在的﻿<br>concurrent 并行 并发﻿<br>configuration组态 配置﻿<br>connection 连接，连线（网络,资料库） 连接﻿<br>constraint 约束（条件）﻿<br>construct 构件 构件﻿<br>container 容器 容器(存放资料的某种结构如list, vector…）﻿<br>containment 内含 包容﻿<br>context背景关系、周遭环境、上下脉络 环境、上下文﻿<br>control 控制元件、控件 控件﻿<br>console 主控台 控制台﻿<br>const常数（constant 的缩写，C++ 关键字）﻿<br>constant 常数（相对於variable） 常量﻿<br>constructor（ctor） 建构式 构造函数（与class 同名的一种 member functions）﻿<br>copy (v) 复制、拷贝 拷贝﻿<br>copy (n) 复件, 副本﻿<br>cover 涵盖 覆盖﻿<br>create 创建、建立、产生、生成 创建﻿<br>creation 产生、生成 创建﻿<br>cursor 游标 光标custom、订制、自定 定制<br>data 资料 数据﻿<br>database 资料库 数据库﻿<br>database schema 数据库结构纲目﻿<br>data member 资料成员、成员变数 数据成员、成员变量﻿<br>data structure 资料结构 数据结构﻿<br>datagram 资料元 数据报文﻿<br>dead lock 死结 死锁﻿<br>debug 除错 调试﻿<br>debugger 除错器 调试器﻿<br>declaration 宣告、宣告式 声明﻿<br>deduction 推导（例：template argument deduction）推导、推断﻿<br>default 预设 缺省、默认﻿<br>defer 延缓 推迟﻿<br>define 定义 预定义﻿<br>definition 定义、定义区、定义式 定义﻿<br>delegate 委派、委托、代理﻿<br>delegation （同上）﻿<br>demarshal 反编列 散集﻿<br>dereference 提领（取出指标所指物体的内容） 解叁考﻿<br>derived class 衍生类别 派生类﻿<br>design by contract 契约式设计﻿<br>design pattern 设计范式、设计样式 设计模式﻿<br>destroy 摧毁、销毁﻿<br>destructor  解构式 析构函数﻿<br>device 装置、设备 设备﻿<br>dialog 对话窗、对话盒 对话框﻿<br>directive 指令（例：using directive） (编译)指示符﻿<br>directory 目录 目录﻿<br>disk 碟 盘﻿<br>dispatch 分派 分派﻿<br>distributed computing 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算)﻿<br>document 文件 文档﻿<br>dot operator dot（句点）运算子 . (圆)点操作符﻿<br>driver 驱动程式 驱动（程序）﻿<br>dynamic binding 动态系结 动态绑定﻿<br>efficiency 效率 效率﻿<br>efficient 高效 高效﻿<br>end user 终端用户﻿<br>entity 物体 实体、物体﻿<br>encapsulation 封装 封装﻿<br>enclosing class外围类别（与巢状类别 nested class有关）外围类﻿<br>enum (enumeration) 列举（一种 C++ 资料型别） 枚举﻿<br>enumerators 列举元（enum 型别中的成员） 枚举成员、枚举器﻿<br>equal 相等 相等﻿<br>equality 相等性 相等性﻿<br>equality operator equality（等号）运算子 == 等号操作符﻿<br>equivalence等价性、等同性、对等性 等价性﻿<br>equivalent 等价、等同、对等 等价﻿<br>escape code 转义码 转义码﻿<br>evaluate 评估、求值、核定 评估﻿<br>event 事件 事件﻿<br>event driven 事件驱动的 事件驱动的﻿<br>exception 异常情况 异常﻿<br>exception declaration 异常宣告（ref. C++ Primer 3/e, 11.3）异常声明﻿<br>exception handling 异常处理、异常处理机制 异常处理、异常处理机制﻿<br>exception specification 异常规格（ref. C++ Primer 3/e, 11.4）异常规范﻿<br>exit 退离（指离开函式时的那一个执行点） 退出﻿<br>explicit 明白的、明显的、显式 显式﻿<br>export 汇出 引出、导出﻿<br>facility 设施、设备 设施、设备﻿<br>feature 特性﻿<br>field 栏位,资料栏（Java） 字段, 值域（Java）﻿<br>file 档案 文件﻿<br>firmware 韧体 固件﻿<br>flag 旗标 标记﻿<br>flash memory 快闪记忆体 闪存﻿<br>flexibility 弹性 灵活性﻿<br>flush 清理、扫清 刷新﻿<br>font 字型 字体﻿<br>form 表单（programming 用语） 窗体﻿<br>formal parameter形式叁数 形式叁数<br>forward declaration 前置宣告 前置声明﻿<br>forwarding 转呼叫,转发 转发﻿<br>forwarding function 转呼叫函式,转发函式 转发函数﻿<br>fractal 碎形 分形﻿<br>framework 框架 框架﻿<br>full specialization 全特化（ref. partial specialization）﻿<br>function 函式、函数 函数﻿<br>function call operator 同﻿<br>call operator function object 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象﻿<br>function overloaded resolution 函式多载决议程序 函数重载解决（方案）﻿<br>functionality 功能、机能 功能﻿<br>function template 函式模板、函式范本 函数模板﻿<br>functor 仿函式 仿函式、函子<br>game 游戏 游戏﻿<br>generate 生成﻿<br>generic 泛型、一般化的 一般化的、通用的、泛化﻿<br>generic algorithm 泛型演算法 通用算法﻿<br>getter (相对於 setter) 取值函式﻿<br>global 全域的（对应於 local） 全局的﻿<br>global object 全域物件 全局对象﻿<br>global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符﻿<br>group 群组<br>group box 群组方块 分组框<br>guard clause 卫述句 (Refactoring, p250) 卫语句<br>GUI 图形介面 图形界面﻿<br>hand shaking握手协商﻿<br>handle 识别码、识别号、号码牌、权柄 句柄﻿<br>handler 处理常式 处理函数﻿<br>hard－coded 编死的 硬编码的﻿<br>hard－copy 硬拷图 屏幕截图﻿<br>hard disk硬碟 硬盘﻿<br>hardware 硬体 硬件﻿<br>hash table 杂凑表 哈希表、散列表﻿<br>header file 表头档、标头档 头文件﻿<br>heap堆积 堆﻿<br>hierarchy 阶层体系 层次结构（体系）﻿<br>hook 挂钩 钩子﻿<br>hyperlink 超链结 超链接﻿<br>icon 图示、图标 图标﻿<br>IDE 整合开发环境 集成开发环境﻿<br>identifier 识别字、识别符号 标识符﻿<br>if and only if 若且唯若 当且仅当﻿<br>Illinois 伊利诺 伊利诺斯﻿<br>image 影像 图象﻿<br>immediate base 直接的（紧临的）上层 base class。 直接上层基类﻿<br>immediate derived 直接的（紧临的）下层derived class。 直接下层派生类﻿<br>immutability 不变性﻿<br>immutable不可变（的）﻿<br>implement实作、实现 实现﻿<br>implementation实作品、实作体、实作码、实件 实现﻿<br>implicit 隐喻的、暗自的、隐式 隐式﻿<br>import汇入 导入﻿<br>increment operator累加运算子 ++ 增加操作符﻿<br>infinite loop 无穷回圈 无限循环﻿<br>infinite recursive 无穷递回 无限递归﻿<br>information 资讯 信息﻿<br>infrastructure 公共基础建设﻿<br>inheritance继承、继承机制 继承、继承机制﻿<br>inline 行内 内联﻿<br>inline expansion 行内展开 内联展开﻿<br>initialization 初始化（动作） 初始化﻿<br>initialization list 初值列 初始值列表﻿<br>initialize 初始化 初始化﻿<br>inner class 内隐类别 内嵌类﻿<br>instance 实体 实例（根据某种表述而实际产生的「东西」）﻿<br>instantiated 具现化、实体化（常应用於 template） 实例化﻿<br>instantiation 具现体、具现化实体（常应用於 template） 实例﻿<br>integer (integral) 整数（的） 整型（的）﻿<br>integrate 整合 集成﻿<br>interacts 交谈、互动 交互﻿<br>interface 介面 接口﻿<br>interpreter 直译器 解释器﻿<br>invariants 恒常性,约束条件 约束条件﻿<br>invoke 唤起 调用﻿<br>iterate迭代（回圈一个轮回一个轮回地进行） 迭代﻿<br>iterative 反覆的，迭代的﻿<br>iterator 迭代器（一种泛型指标） 迭代器﻿<br>iteration 迭代（回圈每次轮回称为一个 iteration） 迭代﻿<br>item 项目、条款 项、条款、项目﻿<br>laser 雷射 激光﻿<br>level 阶 层 (级) 例high level高阶 高层﻿<br>library 程式库、函式库 库、函数库﻿<br>lifetime生命期、寿命 生命期、寿命﻿<br>link联结、连结 连接,链接﻿<br>linker联结器、连结器 连接器﻿<br>literal constant 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数﻿<br>list串列（linked－list） 列表、表、链表﻿<br>list box 列表方块、列表框 列表框﻿<br>load 载入 装载﻿<br>loader 载入器 装载器、载入器﻿<br>local 区域的（对应於 global） 局部的﻿<br>local object 区域物件 局部对象﻿<br>lock机锁﻿<br>loop 回圈 循环﻿<br>lvalue左值 左值﻿<br>macro 巨集 宏﻿<br>magic number 魔术数字 魔法数﻿<br>maintain 维护 维护﻿<br>manipulator 操纵器（iostream预先定义的一种东西） 操纵器﻿<br>marshal 编列 列集叁考<br>demarshal mechanism 机制 机制﻿<br>member 成员 成员﻿<br>member access operator 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符﻿<br>member function 成员函式 成员函数﻿<br>member initialization list 成员初值列 成员初始值列表﻿<br>member wise 以 member 为单元┅、members 逐一以成员为单位﻿<br>member wise copy 以 members 为单元逐一复制﻿<br>memory 记忆体 内存﻿<br>menu 表单、选单 菜单﻿<br>message 讯息 消息<br>message based 以讯息为基础的 基於消息的﻿<br>message loop讯息回圈 消息环﻿<br>method 方法、行为、函式 方法﻿<br>meta－ 超－ 元－﻿<br>meta－programming 超编程 元编程﻿<br>micro 微 微﻿<br>middleware 中介层 中间件﻿<br>modeling 模塑﻿<br>modeling language 塑模语言，建模语言﻿<br>modem 数据机 调制解调器﻿<br>module 模组 模块﻿<br>modifier 饰词 修饰符﻿<br>most derived class 最末层衍生类别 最底层的派生类﻿<br>mouse 滑鼠 鼠标﻿<br>mutable可变的 可变的﻿<br>multi－tasking 多工 多任务﻿<br>namespace 命名空间 名字空间、命名空间﻿<br>native 原生的 本地的、固有的﻿<br>nested class 巢状类别 嵌套类﻿<br>network 网路 网络﻿<br>network card网路卡 网卡<br>object 物件 对象﻿<br>object based 以物件为基础的 基於对象的﻿<br>object file 目的档 目标文件﻿<br>object model 物件模型 对象模型﻿<br>object oriented 物件导向的 面向对象的﻿<br>online 线上 在线﻿<br>opaque不透明的﻿<br>operand 运算元 操作数﻿<br>operating system (OS) 作业系统 操作系统﻿<br>operation 操作、操作行为 操作﻿<br>operator 运算子 操作符、运算符﻿<br>option 选项，可选方案 选项﻿<br>ordinary 常规的 常规的﻿<br>overflow 上限溢位（相对於 underflow） 溢出（underflow:下溢）﻿<br>overhead 额外负担、额外开销 额外开销﻿<br>overload 多载化、多载化、重载 重载﻿<br>overloaded function 多载化函式 重载的函数﻿<br>overloaded operator 多载化运算子 被重载的操作符﻿<br>overloaded set 多载集合 重载集合﻿<br>override 改写、覆写 重载、改写、重新定义（在 derived class 中重新定义虚拟函式)<br>package套件 包<br>pair 对组﻿<br>palette 调色盘、组件盘、工具箱﻿<br>pane 窗格 窗格﻿<br>parallel平行 并行﻿<br>parameter 叁数（函式叁数列上的变数） 叁数、形式叁数、形叁﻿<br>parameter list 叁数列 叁数列表﻿<br>parent class 父类别（或称 base class） 父类﻿<br>parentheses 小括弧、小括号 圆括弧、圆括号﻿<br>parse 解析 解析﻿<br>part零件 部件﻿<br>partial specialization 偏特化（ref. C++ Primer 3/e, 16.10）局部特化﻿<br>pass by address 传址（函式引数的传递方式）（非正式用语）传地址﻿<br>pass by reference传址（函式引数的一种传递方式） 传地址, 按引用传递﻿<br>pass by value 传值（函式引数的一种传递方式） 按值传递﻿<br>pattern 范式、样式 模式﻿<br>performance 效率、性能兼而有之 性能﻿<br>persistence 永续性 持久性﻿<br>pixel 图素、像素 像素﻿<br>platform 平台 平台﻿<br>pointer指标 指针址位器（和址叁器 reference 形成对映，满好）﻿<br>poll 轮询 轮询﻿<br>polymorphism多型 多态﻿<br>pop up 冒起式、弹出式 弹出式﻿<br>port 埠 端口﻿<br>postfix 後置式、後序式 後置式﻿<br>precedence 优先序（通常用於运算子的优先执行次序）﻿<br>prefix 前置式、前序式 前置式﻿<br>preprocessor 前处理器 预处理器﻿<br>prime质数 素数﻿<br>primitive type 基本型别 (不同於 base class,基础类别)﻿<br>print 列印 打印﻿<br>printer 印表机 打印机﻿<br>priority优先权 (通常用於执行绪获得 CPU 时间的优先次序）﻿<br>procedure 程序 过程﻿<br>procedural 程序的、程序式的 过程式的、过程化的﻿<br>process 行程 进程﻿<br>profile 评测 评测﻿<br>profiler 效能（效率）评测器 效能（性能）评测器﻿<br>programmer 程式员 程序员﻿<br>programming 编程、程式设计、程式化 编程﻿<br>progress bar 进度指示器 进度指示器﻿<br>project 专案 项目、工程﻿<br>property 属性﻿<br>protocol协定 协议﻿<br>pseudo code 假码、虚拟码、伪码 伪码﻿<br>qualified 经过资格修饰（例如加上scope 运算子） 限定﻿<br>qualifier 资格修饰词、饰词 限定修饰词﻿<br>quality品质 质量﻿<br>queue 伫列 队列﻿<br>radian 径度 弧度﻿<br>radio button 圆钮 单选按钮﻿<br>raise 引发（常用来表示发出一个 exception） 引起、引发﻿<br>random number 随机数、乱数 随机数﻿<br>range范围、区间（用於 STL 时） 范围、区间﻿<br>rank 等级、分等（ref. C++Primer 3/e 9,15章） 等级﻿<br>raw 生鲜的、未经处理的 未经处理的﻿<br>record记录 记录﻿<br>recordset 记录集 记录集﻿<br>recursive 递回 递归﻿<br>re－direction重导向 重定向﻿<br>refactoring 重构、重整 重构﻿<br>refer 取用 叁考﻿<br>refer to指向、指涉、指代﻿<br>reference 引用、叁考 址叁器,﻿<br>see pointer register暂存器 寄存器﻿<br>reflection 反射 反射、映像﻿<br>relational database 关联式资料库 关系数据库﻿<br>represent 表述，表现 表述，表现﻿<br>resolve 决议（为算式中的符号名称寻找 解析对应之宣告式的过程）﻿<br>resolution 决议程序、决议过程 解析过程﻿<br>resolution 解析度 分辨率﻿<br>restriction 局限﻿<br>return 传回、回返 返回﻿<br>return type 回返型别 返回类型﻿<br>return value 回返值 返回值﻿<br>robust 强固、稳健 健壮﻿<br>robustness强固性、稳健性 健壮性﻿<br>routine常式 例程﻿<br>runtime 执行期 运行期、运行时﻿<br>common language runtime(CLR) 译为「通用语言执行层」﻿<br>rvalue 右值 右值﻿<br>save 保存﻿<br>save point 保存点﻿<br>SAX (Simple API for XML)scalable可伸缩的、可扩展的﻿<br>schedule 调度<br>scheduler 调度程序﻿<br>schema模式、纲目结构﻿<br>scroll bar 滚动条﻿<br>scope 作用域、生存空间﻿<br>scope operator 生存空间操作符﻿<br>scope resolution operator生存空间解析操作符﻿<br>screen 屏幕﻿<br>SDK (Software Development Kit) 软件开发包﻿<br>sealed class 密封类﻿<br>search 查找﻿<br>semantics 语义﻿<br>semaphore信号量﻿<br>sequential container序列式容器﻿<br>server 服务器、服务端﻿<br>serial 串行﻿<br>serialization/serialize 序列化﻿<br>server cursor服务端游标、服务器游标﻿<br>session 会话﻿<br>setter 设值函数﻿<br>shared lock 共享锁﻿<br>sibling 同级﻿<br>side effect 副作用﻿<br>signature 签名﻿<br>single-threaded 单线程﻿<br>slider滑块﻿<br>slot 槽﻿<br>smart pointer 智能指针﻿<br>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议﻿<br>snapshot 截屏图﻿<br>snapshot 快照﻿<br>specialization 特化﻿<br>specification 规范、规格﻿<br>splitter 切分窗口﻿<br>SOAP (simple object access protocol)简单对象访问协议﻿<br>software 软件﻿<br>source code 源码、源代码﻿<br>SQL (Structured Query Language) 结构化查询语言﻿<br>stack 栈、堆栈﻿<br>stack unwinding 叠辗转开解(此词用于exception主题)﻿<br>standard library 标准库﻿<br>standard template library 标准模板库﻿<br>stateless 无状态的﻿<br>statement 语句、声明﻿<br>static cursor 静态游标﻿<br>static SQL statements 静态SQL语句﻿<br>stored procedure 存储过程﻿<br>status bar 状态条﻿<br>stream 流﻿<br>string 字符串﻿<br>stub 存根﻿<br>subobject子对象﻿<br>subquery 子查询﻿<br>subroutine 子例程﻿<br>subscript operator 下标操作符﻿<br>subset 子集﻿<br>subtype 子类型﻿<br>support 支持﻿<br>suspend挂起﻿<br>symbol记号﻿<br>syntax 语法﻿<br>system databases 系统数据库﻿<br>system tables 系统表﻿<br>tag标签 标记 索引标签,页签﻿<br>target 标的（例target pointer：标的指标） 目标﻿<br>task switch 工作切换 任务切换﻿<br>template 模板、范本 模板﻿<br>template argument deduction 模板引数推导 模板叁数推导﻿<br>template explicit specialization 模板显式特化（版本） 模板显式特化﻿<br>template parameter 模板叁数 模板叁数﻿<br>temporary object 暂时物件 临时对象﻿<br>text文字 文本﻿<br>text file程式本文档（放置程式原始码的档案） 文本文件﻿<br>thread 执行绪 线程﻿<br>thread safe 多绪安全 多线程安全﻿<br>throw丢掷（常指发出一个exception） 丢掷、引发﻿<br>token 语汇单元 符号、标记﻿<br>transaction 交易 事务﻿<br>transaction log 事务日志﻿<br>transaction rollback 事务回滚﻿<br>transactional replication 事务复制﻿<br>translation unit 翻译单元﻿<br>transparent(ly) 透通的(地)﻿<br>traverse 巡访（来回走动） 遍历﻿<br>trigger 触发 触发﻿<br>type型别 类型﻿<br>table 表﻿<br>table lock 表锁﻿<br>table-level constraint表级约束﻿<br>tape backup 磁带备份﻿<br>task switch 工作切换﻿<br>TCP (Transport Control Protocol) 传输控制协议﻿<br>temporary table临时表﻿<br>thin client瘦客户端﻿<br>third-party第三方﻿<br>trace 跟踪﻿<br>traverse 遍历﻿<br>two-phase commit两阶段提交﻿<br>tupletwo-phase lookup 两阶段查找﻿<br>UML unified modeling language统一建模语言﻿<br>unary function 一元函式 单叁函数﻿<br>unary operator一元运算子 一元操作符﻿<br>underflow下限溢位（相对於overflow） 下溢﻿<br>unchecked exception 不可控异常﻿<br>unqualified 未经资格修饰（而直接取用）﻿<br>user 使用者、用户 用户﻿<br>user interface使用者界面、用户界面、人机界面﻿<br>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成﻿<br>unboxing 拆箱、拆箱转换﻿<br>Union query 联合查询﻿<br>UNIQUE constraints UNIQUE约束﻿<br>unique index 唯一索引﻿<br>unmanaged code 非受控代码、非托管代码﻿<br>unmarshal散集﻿<br>unqualified 未经限定的、未经修饰的﻿<br>URI (Uniform Resource identifier) 统一资源标识符﻿<br>URL (Uniform Resource Locator)统一资源定位器﻿<br>variable 变数（相对於常数const） 变量﻿<br>vector 向量（一种容器，有点类似array） 向量、矢量﻿<br>viable可实行的、可行的 可行的﻿<br>viable function可行函式 可行函数﻿<br>video 视讯 视频<br>view (1) 视图﻿<br>(document/view)文档/视图﻿<br>virtual function 虚拟函式 虚函数﻿<br>virtual machine虚拟机器 虚拟机﻿<br>virtual memory虚拟记忆体 虚内存, 虚存﻿<br>volatile 易挥发的、易变的﻿<br>vowel 母音 元音字母﻿<br>window 视窗 窗口﻿<br>window function 视窗函式 窗口函数﻿<br>window procedure 视窗函式 窗口过程﻿<br>word 字 单词﻿<br>word processor文书处理器 字处理器﻿<br>wrapper 外覆、外包 包装﻿<br>Web Services web 服务﻿<br>WHERE clause WHERE子句﻿<br>wildcard characters 通配符字符﻿<br>wildcard search 通配符搜索﻿<br>Windows authentication Windows 身份验证﻿<br>wizard 向导﻿<br>write enable写启用﻿<br>write-ahead log 预写日志﻿<br>write-only 只写﻿<br>WSDL (Web Service Description Language)Web Service 描述语言﻿<br>XML (eXtensible Markup Language)可扩展标记语言﻿<br>XSD (XML Schema Definition)  XML 模式定义语言﻿<br>XSL (eXtensible Stylesheet Language)可扩展样式表语言﻿<br>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换﻿<br>xxx based基于xxx的﻿<br>xxx oriented面向xxxXML (eXtensible Markup Language) 可扩展标记语言</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS字符串的强弱引用的区别]]></title>
      <url>http://yoursite.com/2014/05/17/2014/iOS%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BC%BA%E5%BC%B1%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>在声明NSString属性时，到底是选择strong还是copy，可以根据实际情况来定。不过，一般我们将对象声明为NSString时，都不希望它改变，所以大多数情况下，我们建议用copy，以免因可变字符串的修改导致的一些非预期问题。</p>
<p>上代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ExampleViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *strongStr;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *copyedStr;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>textOne<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)testOne &#123;</div><div class="line">    <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"abc"</span>];</div><div class="line">    <span class="keyword">self</span>.strongStr = string;</div><div class="line">    <span class="keyword">self</span>.copyedStr = string;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"originString1: %p, %p,%@"</span>, string,&amp;string,string);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strongString1: %p, %p,%@"</span>, _strongStr,&amp;_strongStr,<span class="keyword">self</span>.strongStr);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"copyString1:   %p, %p,%@"</span>, _copyedStr,&amp;_copyedStr,<span class="keyword">self</span>.copyedStr);</div><div class="line"></div><div class="line">    <span class="comment">//改变string的值</span></div><div class="line">    string = <span class="string">@"123"</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"originString11: %p, %p,%@"</span>, string, &amp;string,string);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strongString11: %p, %p,%@"</span>, _strongStr,&amp;_strongStr,<span class="keyword">self</span>.strongStr);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"copyString11:   %p, %p,%@"</span>, _copyedString,&amp;_copyedStr,<span class="keyword">self</span>.copyedStr);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//string创建</span></div><div class="line">originString1:  <span class="number">0xa000000006362613</span>, <span class="number">0x7fff54c687e8</span>,abc</div><div class="line">strongString1:  <span class="number">0xa000000006362613</span>, <span class="number">0x7fccb66028e8</span>,abc</div><div class="line">copyString1:    <span class="number">0xa000000006362613</span>, <span class="number">0x7fccb66028f0</span>,abc</div><div class="line"></div><div class="line"><span class="comment">//string改变</span></div><div class="line">originString11: <span class="number">0x10b12f300</span>,        <span class="number">0x7fff54c687e8</span>,<span class="number">123</span></div><div class="line">strongString11: <span class="number">0xa000000006362613</span>, <span class="number">0x7fccb66028e8</span>,abc</div><div class="line">copyString11:   <span class="number">0xa000000006362613</span>, <span class="number">0x7fccb66028f0</span>,abc</div></pre></td></tr></table></figure></p>
<p>当string为不可变字符串时,不管是strong还是copy属性的对象，其指向的地址都是同一个，即为string指向的地址。当string的值发生改变时，两个对象的值也保持原来的值,如果我们换作MRC环境，打印string的引用计数的话，会看到其引用计数值是3，即strong操作和copy操作都使原字符串对象的引用计数值加了1。</p>
<p>textTwo<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)testTwo &#123;</div><div class="line">    <span class="built_in">NSMutableString</span> *string= [[<span class="built_in">NSMutableString</span> alloc]initWithString:<span class="string">@"abc"</span>];</div><div class="line">    <span class="keyword">self</span>.strongStr = string;</div><div class="line">    <span class="keyword">self</span>.copyedStr = string;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"originString2: %p,%p,%@"</span>, string, &amp;string,string);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strongString2: %p,%p,%@"</span>, _strongStr,&amp;_strongStr,<span class="keyword">self</span>.strongStr);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"copyString2:   %p,%p,%@"</span>, _copyedStr,&amp;_copyedStr,<span class="keyword">self</span>.copyedStr);</div><div class="line"></div><div class="line">    <span class="comment">//改变string的值</span></div><div class="line">    [string appendFormat:<span class="string">@"%@"</span>,<span class="string">@"123"</span>];</div><div class="line"></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"originString2: %p,%p,%@"</span>, string, &amp;string,string);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strongString2: %p,%p,%@"</span>, _strongStr,&amp;_strongStr,<span class="keyword">self</span>.strongStr);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"copyString2:   %p,%p,%@"</span>, _copyedStr,&amp;_copyedStr,<span class="keyword">self</span>.copyedStr);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当string为可变字符串时,此时copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让_copyedStr对象指向这个字符串,_strongStr与string是指向同一对象，所以_strongString的值也会跟随着改变(需要注意的是，此时_strongStr的类型实际上是NSMutableString，而不是NSString)；而_copyedStr是指向另一个对象的，所以并不会改变。在MRC环境下，打印两者的引用计数，可以看到string对象的引用计数是2，而_copyedStr对象的引用计数是1。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS关键字const、static、extern]]></title>
      <url>http://yoursite.com/2014/05/13/2014/%20iOS%E5%85%B3%E9%94%AE%E5%AD%97const%E3%80%81static%E3%80%81extern/</url>
      <content type="html"><![CDATA[<p>const与宏的区别<br>1.const简`:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。<br>2.编译时刻:宏是预编译（编译之前处理），const是编译阶段。<br>3.编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。<br>4.宏的好处:宏能定义一些函数，方法。 const不能。<br>5.宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。<br>注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常见的常量：抽成宏</span></div><div class="line"><span class="meta">#define XMGAccount @<span class="meta-string">"account"</span></span></div><div class="line"><span class="meta">#define XMGUserDefault [NSUserDefaults standardUserDefaults]</span></div><div class="line"><span class="comment">// 字符串常量</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> account = <span class="string">@"account"</span>;</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 偏好设置存储</span></div><div class="line">    <span class="comment">// 使用宏</span></div><div class="line">    [XMGUserDefault setValue:<span class="string">@"123"</span> forKey:XMGAccount];</div><div class="line">    <span class="comment">// 使用const常量</span></div><div class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setValue:<span class="string">@"123"</span> forKey:account];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>const作用：限制类型<br>1.const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）<br>2.被const修饰的变量是只读的。</p>
<p>const基本使用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 定义变量</span></div><div class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">    <span class="comment">// 允许修改值</span></div><div class="line">    a = <span class="number">20</span>;</div><div class="line">    <span class="comment">// const两种用法</span></div><div class="line">    <span class="comment">// const:修饰基本变量p</span></div><div class="line">    <span class="comment">// 这两种写法是一样的，const只修饰右边的基本变量b</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></div><div class="line">    <span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></div><div class="line">    <span class="comment">// 不允许修改值</span></div><div class="line">    b = <span class="number">1</span>;</div><div class="line">    <span class="comment">// const:修饰指针变量*p，带*的变量，就是指针变量.</span></div><div class="line">    <span class="comment">// 定义一个指向int类型的指针变量，指向a的地址</span></div><div class="line">    <span class="keyword">int</span> *p = &amp;a;</div><div class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</div><div class="line">    p = &amp;c;</div><div class="line">    <span class="comment">// 允许修改p指向的地址，</span></div><div class="line">    <span class="comment">// 允许修改p访问内存空间的值</span></div><div class="line">    *p = <span class="number">20</span>;</div><div class="line">    <span class="comment">// const修饰指针变量访问的内存空间，修饰的是右边*p1，</span></div><div class="line">    <span class="comment">// 两种方式一样</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *p1; <span class="comment">// *p1：常量 p1:变量</span></div><div class="line">    <span class="keyword">int</span> <span class="keyword">const</span> *p1; <span class="comment">// *p1：常量 p1:变量</span></div><div class="line">    <span class="comment">// const修饰指针变量p1</span></div><div class="line">    <span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1:变量 p1:常量</span></div><div class="line">    <span class="comment">// 第一个const修饰*p1 第二个const修饰 p1</span></div><div class="line">    <span class="comment">// 两种方式一样</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1：常量 p1：常量</span></div><div class="line">    <span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p1;  <span class="comment">// *p1：常量 p1：常量</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>const开发中使用场景<br>1.当一个方法参数只读<br>2.定义只读全局变量<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"><span class="comment">// 定义只读全局常量</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> str  = <span class="string">@"123"</span>;</div><div class="line"><span class="comment">// 当一个方法的参数，只读.</span></div><div class="line">- (<span class="keyword">void</span>)test:(<span class="built_in">NSString</span> * <span class="keyword">const</span>)name&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 指针只读,不能通过指针修改值</span></div><div class="line">- (<span class="keyword">void</span>)test1:(<span class="keyword">int</span> <span class="keyword">const</span> *)a&#123;</div><div class="line">    <span class="comment">// *a = 10;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 基本数据类型只读</span></div><div class="line">- (<span class="keyword">void</span>)test2:(<span class="keyword">int</span> <span class="keyword">const</span>)a&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>static和extern简单使用(要使用一个东西，先了解其作用)<br> 1.修饰局部变量</p>
<ul>
<li>延长局部变量的生命周期,程序结束才会销毁。</li>
<li>局部变量只会生成一份内存,只会初始化一次。</li>
</ul>
<p>2.修饰全局变量</p>
<ul>
<li>只能在本文件中访问,修改全局变量的作用域,生命周期不会改</li>
<li>extern作用：只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</li>
<li>extern工作原理：先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量：只有一份内存，所有文件共享，与extern联合使用。</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</div><div class="line"><span class="comment">// static修饰全局变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</div><div class="line">- (<span class="keyword">void</span>)test&#123;</div><div class="line">    <span class="comment">// static修饰局部变量</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">0</span>;</div><div class="line">    age++;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,age);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    [<span class="keyword">self</span> test];</div><div class="line">    [<span class="keyword">self</span> test];</div><div class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>static与const联合使用<br>1.static与const作用:声明一个只读的静态变量<br>2.开发使用场景:在<code>一个文件中</code>经常使用的字符串常量，可以使用static与const组合<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开发中常用static修饰全局变量,只改变作用域</span></div><div class="line"><span class="comment">// 为什么要改变全局变量作用域，防止重复声明全局变量。</span></div><div class="line"><span class="comment">// 开发中声明的全局变量，有些不希望外界改动，只允许读取。</span></div><div class="line"><span class="comment">// 比如一个基本数据类型不希望别人改动</span></div><div class="line"><span class="comment">// 声明一个静态的全局只读常量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// staic和const联合的作用:声明一个静态的全局只读常量</span></div><div class="line"><span class="comment">// iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量.</span></div><div class="line"><span class="comment">// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。</span></div><div class="line"><span class="keyword">static</span>  <span class="built_in">NSString</span> * <span class="keyword">const</span> key = <span class="string">@"name"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。</span></div><div class="line"><span class="keyword">static</span>  <span class="built_in">NSString</span> <span class="keyword">const</span> *key1 = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure></p>
<p>3.开发中使用场景:在<code>多个文件中</code>经常使用的同一个字符串常量，可以使用extern与const组合。</p>
<p>原因:<br>1.static与const组合：在每个文件都需要定义一份静态全局变量。<br>2.extern与const组合:只需要定义一份全局变量，多个文件共享。<br>3.全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</p>
<p>GlobeConst.h<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> nameKey = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure></p>
<p>GlobeConst.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> nameKey = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS音乐锁屏键的处理]]></title>
      <url>http://yoursite.com/2014/04/21/2014/iOS%E9%9F%B3%E4%B9%90%E9%94%81%E5%B1%8F%E9%94%AE%E7%9A%84%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="完整的思路"><a href="#完整的思路" class="headerlink" title="完整的思路"></a>完整的思路</h3><p> 1.App如果需要在锁屏界面上显示相关的信息和按钮, 必须先开启远程控制事件(Remote Control Event), 否则锁屏界面只显示滑动解锁.<br> 2.实现锁屏界面信息, 将歌曲的相关信息更新到锁屏界面上<br> 3.实现锁屏界面的事件处理, 在锁屏界面和上拉的快速功能菜单中实现播放控制</p>
<h3 id="远程控制事件的实现"><a href="#远程控制事件的实现" class="headerlink" title="远程控制事件的实现"></a>远程控制事件的实现</h3><p>在iOS7.1之前, 远程控制事件主要涉及以下三个方法:<br>1.开始接收远程控制事件<br>2.结束接收远程控制事件<br>3.触发远程控制事件后的捕获处理<br>官方文档对这三个方法的描述如下, 这里做了简单的翻译</p>
<ul>
<li>开始接收远程控制事件<br>让App开始接收远程控制事件, 该方法属于UIApplication类<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)beginReceivingRemoteControlEvents;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在iOS7.1之后, 使用MPRemoteCommandCenter的共享对象来注册远程控制事件. 当使用shared command center时, 不需要再调用该方法.<br>该方法会开始使用事件响应链来传递远程控制事件. 远程控制事件是当耳机和外部附件意图控制App的多媒体表现时发出的命令. 要停止远程控制事件的接收, 必须调用endReceivingRemoteControlEvents方法</p>
<p>让App停止接收远程控制事件, 该方法属于UIApplication类<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)endReceivingRemoteControlEvents;</div></pre></td></tr></table></figure></p>
<p>在iOS7.1之前, 使用shared MPRemoteCommandCenter对象来注册远程控制事件. 当使用shared command center时, 不需要再调用该方法。该方法会停止通过事件响应链来传递远程控制事件. 远程控制事件是当耳机和外部附件意图控制App的多媒体表现时发出的命令.</p>
<ul>
<li>远程控制事件的捕获处理<br>当远程控制事件发生时触发该方法, 该方法属于UIResponder类<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>远程控制事件是由外部附件(包括耳机)所发出的命令. 应用需要响应这些命令来控制音频或视频媒体的对用户的表示. 事件响应者通过检查事件的subtype, 来判断命令的意图. 比如UIEventSubtypeRemoteControlPlay为播放操作, 然后做相关处理要允许远程控制事件的传递, 需要调用UIApplication的beginReceivingRemoteControlEvents方法; 要关闭远程控制事件的传递则调用endReceivingRemoteControlEvents</p>
<ul>
<li>项目中的代码实现<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">    <span class="comment">//在App启动后开启远程控制事件, 接收来自锁屏界面和上拉菜单的控制</span></div><div class="line">    [application beginReceivingRemoteControlEvents];</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application&#123;</div><div class="line">    <span class="comment">//在App要终止前结束接收远程控制事件, 也可以在需要终止时调用该方法终止</span></div><div class="line">    [application endReceivingRemoteControlEvents];</div><div class="line">&#125;</div><div class="line"><span class="comment">//在具体的控制器或其它类中捕获处理远程控制事件</span></div><div class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    <span class="comment">//根据事件的子类型(subtype) 来判断具体的事件类型, 并做出处理</span></div><div class="line">    <span class="keyword">switch</span> (event.subtype) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>: &#123;</div><div class="line">            <span class="comment">//执行播放或暂停的相关操作 (锁屏界面和上拉快捷功能菜单处的播放按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>: &#123;</div><div class="line">            <span class="comment">//执行上一曲的相关操作 (锁屏界面和上拉快捷功能菜单处的上一曲按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>: &#123;</div><div class="line">            <span class="comment">//执行下一曲的相关操作 (锁屏界面和上拉快捷功能菜单处的下一曲按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlTogglePlayPause</span>: &#123;</div><div class="line">            <span class="comment">//进行播放/暂停的相关操作 (耳机的播放/暂停按钮)</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="iOS7-1后-更新了远程控制事件的实现方式"><a href="#iOS7-1后-更新了远程控制事件的实现方式" class="headerlink" title="iOS7.1后, 更新了远程控制事件的实现方式"></a>iOS7.1后, 更新了远程控制事件的实现方式</h3><p>相关方法的描述中, 已经说明, iOS7.1之后使用MPRemoteCommandCenter类来进行远程控制事件的相关处理, 因此可以不再使用上面所描述的三个方法. 官方文档MPRemoteCommandCenter的描述如下:</p>
<ul>
<li><p>MPRemoteCommandCenter<br>MPRemoteCommandCenter类提供了处理远程控制事件的对象, 包括由外部附件和系统传输控制发送的远程控制事件. 不需要自己创建该类的实例. 而是使用shareCommandCenter方法获取默认的命令中心(share command center)对象. share command center对象的属性包含了MPRemoteCommand对象(表示iOS支持的每种远程控件事件). 如果要对响应的事件特殊处理, 使用适当的MPRemoteCommand对象注册一个handler即可.远程命令中心(remote command center)对象为许多不同类型的事件提供了命令(command)对象. 如果你的App不需要支持某些特定类型的事件, 可以通过设置其enabled属性为NO来禁用关联的MPRemoteCommand对象. 使用command对象注册一个handler, 以便让系统知道你的App已经做好了接收事件的准备. 只有当你的App是当前正在播放(Now Playing App)时才能接收到事件的传递。</p>
</li>
<li><p>项目中的代码实现</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在需要处理远程控制事件的具体控制器或其它类中实现</span></div><div class="line">- (<span class="keyword">void</span>)remoteControlEventHandler&#123;</div><div class="line">    <span class="comment">//直接使用sharedCommandCenter来获取MPRemoteCommandCenter的shared实例</span></div><div class="line">    <span class="built_in">MPRemoteCommandCenter</span> *commandCenter = [<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter];</div><div class="line"></div><div class="line">    <span class="comment">//启用播放命令 (锁屏界面和上拉快捷功能菜单处的播放按钮触发的命令)</span></div><div class="line">    commandCenter.playCommand.enabled = <span class="literal">YES</span>;</div><div class="line">    <span class="comment">//为播放命令添加响应事件, 在点击后触发</span></div><div class="line">    [commandCenter.playCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(playAction:)];</div><div class="line"></div><div class="line">    <span class="comment">//播放, 暂停, 上下曲的命令默认都是启用状态, 即enabled默认为YES</span></div><div class="line">    <span class="comment">//为暂停, 上一曲, 下一曲分别添加对应的响应事件</span></div><div class="line">    [commandCenter.pauseCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pauseAction:)];</div><div class="line">    [commandCenter.previousTrackCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(previousTrackAction:)];</div><div class="line">    [commandCenter.nextTrackCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(nextTrackAction:)];</div><div class="line"></div><div class="line">    <span class="comment">//启用耳机的播放/暂停命令 (耳机上的播放按钮触发的命令)</span></div><div class="line">    commandCenter.togglePlayPauseCommand.enabled = <span class="literal">YES</span>;</div><div class="line">    <span class="comment">//为耳机的按钮操作添加相关的响应事件</span></div><div class="line">    [commandCenter.togglePlayPauseCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(playOrPauseAction:)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="锁屏界面相关信息更新"><a href="#锁屏界面相关信息更新" class="headerlink" title="锁屏界面相关信息更新"></a>锁屏界面相关信息更新</h3><p>实现了远程控制事件后, App在进行音乐播放时, 上拉快捷功能菜单都会提供远程控件按钮, 锁屏界面会有改动, 出现远程控制按钮, 以及歌曲进度等信息, 接下来需要将歌曲的相关信息更新到锁屏界面上. 主要通过MPNowPlayingInfoCenter类来实现, 下面是官方文档的描述:</p>
<ul>
<li>MPNowPlayingInfoCenter<br>使用now playing info center来设置App当前正在播放的媒体文件的信息(now-playing information).系统会在设备的锁屏界面和上划的快捷控制面板的多媒体控制部分显示当前播放文件的信息. 如果用户直接通过AirPlay在Apple TV上播放媒体文件时, now-playing信息会显示在电视屏幕上. 如果用户将设备连接到iPad附件, 比如汽车(通过CarPlay连接)上, 附件上可能会显示now-playing的信息.你不能直接控制哪些信息要被显示出来, 以及这些信息显示的样式. 只需要设置now playing info center dictionary的相关value, 将这些相关信息提交给系统即可. 系统或已经连接的附件, 会用一致的方式为所有的App处理这些信息的展示。可以使用的information属性, 是定义在MPMediaItem类的General Media Item Property Keys属性中的子集(即其中的某些属性). 在iOS5.0后, now playing info center支持下列media item属性的Key: (仅列举了常用的Key!)。</li>
<li><p>MPMediaItemPropertyAlbumTitle<br>专辑的标题, value是NSString对象</p>
</li>
<li><p>MPMediaItemPropertyArtist<br>media item的创作者, value是NSString对象</p>
</li>
<li><p>MPMediaItemPropertyArtwork<br>media item的插图. value是MPMediaItemArtwork类的对象</p>
</li>
<li><p>MPMediaItemPropertyPlaybackDuration<br>media item的播放总时长. value是表示包装了时长秒数(NSTimeInterval)的NSNumber类型</p>
</li>
<li><p>MPMediaItemPropertyTitle<br>media item的名字或标题. 该属性与MPMediaItemPropertyAlbumTitle属性无关, value是NSString对象,额外添加的一些可以使用的属性在MPNowPlayingInfoCenter类的描述文档中的Additional Metadata Properties中作了声明. (仅列举了常用的Key!)</p>
</li>
<li><p>MPNowPlayingInfoPropertyElapsedPlaybackTime<br>当前播放的item所消逝的时间(歌曲当前时间), 单位为秒. value是包装了double值的NSNumber对象. elapsed time是由系统根据之前提供elapsed tiime和playback rate进行自动进行计算的. 请不要频繁的更新该属性, 这是没有必要的。</p>
</li>
<li><p>MPNowPlayingInfoPropertyPlaybackRate<br>当前播放的item的播放速率, value为1.0表示正常的播放速率. value是包装了double值的NSNumber对象. 默认值是1.0. playback rate的值为2.0表示普通播放速率的2倍; 此时media从播放到结束只需要一半时间.</p>
</li>
</ul>
<p>代码实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)updatelockScreenInfo &#123;</div><div class="line">    <span class="comment">//直接使用defaultCenter来获取MPNowPlayingInfoCenter的默认唯一实例</span></div><div class="line">    <span class="built_in">MPNowPlayingInfoCenter</span> *infoCenter = [<span class="built_in">MPNowPlayingInfoCenter</span> defaultCenter];</div><div class="line">    <span class="comment">//MPMediaItemArtwork 用来表示锁屏界面图片的类型</span></div><div class="line">    <span class="built_in">MPMediaItemArtwork</span> *artwork = [[<span class="built_in">MPMediaItemArtwork</span> alloc]     initWithImage:image];</div><div class="line">    <span class="comment">//通过配置nowPlayingInfo的值来更新锁屏界面的信息</span></div><div class="line">    infoCenter.nowPlayingInfo = @&#123;</div><div class="line">        <span class="comment">//歌曲名</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyTitle</span> : music.name,</div><div class="line">        <span class="comment">//艺术家名</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyArtist</span> : music.singer,</div><div class="line">        <span class="comment">//专辑名字</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyAlbumTitle</span> : music.album,</div><div class="line">        <span class="comment">//歌曲总时长 </span></div><div class="line">        <span class="built_in">MPMediaItemPropertyPlaybackDuration</span> : @(duration),</div><div class="line">        <span class="comment">//歌曲的当前时间</span></div><div class="line">        <span class="built_in">MPNowPlayingInfoPropertyElapsedPlaybackTime</span> : @(currentTime),</div><div class="line">        <span class="comment">//歌曲的插图, 类型是MPMeidaItemArtwork对象</span></div><div class="line">        <span class="built_in">MPMediaItemPropertyArtwork</span> : artwork,</div><div class="line">        <span class="comment">//无效的, 歌词的展示是通过图片绘制完成的, 即将歌词绘制到歌曲插图, 通过更新插图来实现歌词的更新的</span></div><div class="line">        <span class="comment">//MPMediaItemPropertyLyrics : lyric.content,</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="类似网易新闻的锁屏控制按钮实现"><a href="#类似网易新闻的锁屏控制按钮实现" class="headerlink" title="类似网易新闻的锁屏控制按钮实现"></a>类似网易新闻的锁屏控制按钮实现</h3><p>通过上述代码实现后, 锁屏界面已经可以展示出歌曲信息与控制按钮, 通过按钮或耳机的按键也可以实现相关的控制效果. 但网易的控制按钮中最左边并是上一曲, 而是列表按钮, 点击后还能在锁屏界面弹出一个ActionSheet界面. 该功能其实是通过修改MPRemoteCommandCenter的反馈功能(提供喜欢, 不喜欢, 标记(bookmark)操作)来实现的.涉及到的反馈功能, 先了解MPFeedbackCommond这个类, 以下是文档的描述</p>
<ul>
<li>MPFeedbackCommond<br>MPFeedbackCommand对象反映了当前App所播放的反馈状态. MPRemoteCommandCenter对象提供feedback对象用于对媒体文件进行喜欢, 不喜欢, 标记的操作. 使用这些对象为App支持的回馈(feedback)方式进行注册handler, 并在反馈状态修改时执行适当的任务(task). 在当前播放的item改变时, 也可以使用该对象为新的item设置反馈状态.当item的反馈状态改变时, 系统传递适当的事件到该对象注册的handler上. handler的代码必须决定哪一个media item来接收反馈, 然后再为该item执行更新反馈状态的操作. 你也可以执行与接收到反馈相关的其它任务. 比如, 当用户喜欢当前播放的歌曲时你可能要在UI上做出适当调整, 并使用该信息来进行相关歌曲的推荐.</li>
<li>MPRemoteCommandCenterr提供了相关属性(反馈按钮)<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">MPFeedbackCommand</span> *likeCommand;     <span class="comment">// 喜欢命令</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">MPFeedbackCommand</span> *dislikeCommand;  <span class="comment">// 不喜欢命令</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">MPFeedbackCommand</span> *bookmarkCommand; <span class="comment">// 标记(书签)命令</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>事实上, 系统的锁屏界面并不支持自定义. 这里边只需要添加反馈按钮, 则系统默认的锁屏界面就是网易云音乐所展示的样式. 包括点击后弹出的ActionSheet都是系统针对反馈按钮所提供了, 网易云音乐只是巧妙的将”不喜欢”按钮的标题修改成”上一曲”, 并在该按钮的响应事件里实现上一曲的代码, 即完成相关功能</p>
<p>代码实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//添加"喜欢"按钮, 需要启用, 并且设置了相关Action后才会生效</span></div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].likeCommand.enabled = <span class="literal">YES</span>;</div><div class="line">[[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].likeCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(likeItemAction)];</div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].likeCommand.localizedTitle = <span class="string">@"喜欢"</span>;</div><div class="line"></div><div class="line"><span class="comment">//添加"不喜欢"按钮</span></div><div class="line">[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].dislikeCommand.enabled = <span class="literal">YES</span>;</div><div class="line"></div><div class="line"><span class="comment">//自定义该按钮的响应事件, 实现在点击"不喜欢"时去执行上一首的功能</span></div><div class="line">[[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter].dislikeCommand addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(previousCommandAction)];</div><div class="line"></div><div class="line"><span class="comment">//自定义"不喜欢"的标题, 伪装成"上一首"</span></div><div class="line">sharedCommandCenter].dislikeCommand.localizedTitle = <span class="string">@"上一首"</span>;</div></pre></td></tr></table></figure></p>
<p>注意: 反馈按钮默认不启用, 因此需要将enabled设置为YES, 同时必须添加对应的响应事件, 按钮才会在锁屏界面显示.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS网络库AFNetworking]]></title>
      <url>http://yoursite.com/2014/04/14/2014/%20iOS%E7%BD%91%E7%BB%9C%E5%BA%93AFNetworking/</url>
      <content type="html"><![CDATA[<h3 id="为什么要用AFNetworking"><a href="#为什么要用AFNetworking" class="headerlink" title="为什么要用AFNetworking"></a>为什么要用AFNetworking</h3><p>为什么要用AFNetworking  在ios开发中，一般情况下，简单的向某个web站点简单的页面提交请求并获取服务器的响应，用xcode自带的NSURLConnection是能胜任的。但是，在绝大部分下我们所需要访问的web页面则是属于那种受到权限保护的页面，并不是有一个简单的URL可以访问的。这就涉及到了Session和Cookie的处理了，在此时使用NSURLConnection也是能够达到要求的，只是其中处理起来的复杂度和难度就提升了。  为了更好的处理向Web站点的请求，包括处理Session，Cookie等细节问题，使用AFNetworking则是更好的选择，他可以用于发送HTTP请求，接收HTTP的响应，但是不会缓存服务器的响应，不能执行HTML页面中的JAvascript代码,同时，AFNetworking还内置支持JSON，plist文件和XML文件的解析，使用比较方便。 </p>
<p> 扩展<br>1、Session：中文有译作时域的，就是只某个客户端在访问服务器起到停止访问这一段的时间间隔被称为时域。<br>2、Cookie：由服务器发送给客服端，把Cookie的key：value值储存在本地文件夹下，当下次请求的时候能够直接发送Cookie获得权限验证</p>
<p>整体架构<br>AFNetworking 3.0 实现完全基于NSURLSessionTask进行封装，NSURLSessionTask 是苹果在iOS7 推出的网络请求api。AF支持https，网络数据请求，文件上传，文件下载，监听手机网络状态。AFHttpSessionManager 继承 AFURLSessionManager 对网络请求进行管理，使用AFURLRequestSerialization 对网络请求进行封装，使用AFURLReponseSerialization 响应体进行处理，使用AFSecurityPolicy 对服务器证书进行校验。支持https协议，支持本地证书和服务器证书进行对比验证，AF要求ios7或以上系统。AF数据传递主要使用block 和 notifacation的方式。</p>
<h3 id="AFURLSessionManager-使用方法"><a href="#AFURLSessionManager-使用方法" class="headerlink" title="AFURLSessionManager 使用方法"></a>AFURLSessionManager 使用方法</h3><p>请求服务器数据<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure></p>
<p> 上传数据<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure></p>
<p> 多线程下载数据<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:<span class="string">@"POST"</span> URLString:<span class="string">@"http://example.com/upload"</span> parameters:<span class="literal">nil</span> constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;</div><div class="line">    [formData appendPartWithFileURL:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.jpg"</span>] name:<span class="string">@"file"</span> fileName:<span class="string">@"filename.jpg"</span> mimeType:<span class="string">@"image/jpeg"</span> error:<span class="literal">nil</span>];</div><div class="line">&#125; error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</div><div class="line">    <span class="built_in">NSURLSessionUploadTask</span> *uploadTask;</div><div class="line">    uploadTask = [manager</div><div class="line">    uploadTaskWithStreamedRequest:request</div><div class="line"></div><div class="line">    progress:^(<span class="built_in">NSProgress</span> * _Nonnull uploadProgress) &#123;</div><div class="line">        <span class="comment">// This is not called back on the main queue.</span></div><div class="line">        <span class="comment">// You are responsible for dispatching to the main queue for UI updates</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//Update the progress view</span></div><div class="line">        [progressView setProgress:uploadProgress.fractionCompleted];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">    completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure></p>
<h3 id="AFHttpSessionManager-使用方法"><a href="#AFHttpSessionManager-使用方法" class="headerlink" title="AFHttpSessionManager 使用方法"></a>AFHttpSessionManager 使用方法</h3><p>1.post请求<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure DEPRECATED_ATTRIBUTE;</div></pre></td></tr></table></figure></p>
<p> 2.get请求<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</div><div class="line">parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure</div></pre></td></tr></table></figure></p>
<p>3.上传<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</div><div class="line">success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure DEPRECATED_ATTRIBUTE;</div></pre></td></tr></table></figure></p>
<h3 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *googleCertificateURL = [[<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]] URLForResource:<span class="string">@"google.com"</span> withExtension:<span class="string">@"cer"</span>];</div><div class="line"><span class="built_in">NSData</span> *googleCertificateData = [<span class="built_in">NSData</span> dataWithContentsOfURL:googleCertificateURL];</div><div class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://apple.com/"</span>]];</div><div class="line"></div><div class="line">[manager setResponseSerializer:[AFHTTPResponseSerializer serializer]];</div><div class="line">manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:[<span class="built_in">NSSet</span> setWithObject:googleCertificateData]];</div></pre></td></tr></table></figure>
<p>证书文件放在应用bundle 中 ，会把服务器证书和本地证书对比认证，加强网络通信的安全性，判断是否信任服务器证书过程<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</div><div class="line">    <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></div><div class="line">    <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></div><div class="line">    <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></div><div class="line">    <span class="comment">//  there is nothing to evaluate against.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  From Apple Docs:</span></div><div class="line">    <span class="comment">//          "Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></div><div class="line">    <span class="comment">//           Instead, add your own (self-signed) CA certificate to the list of trusted anchors."</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"In order to validate a domain name for self signed certificates, you MUST use pinning."</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</div><div class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</div><div class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</div><div class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</div><div class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</div><div class="line">            &#125;</div><div class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</div><div class="line">                <span class="comment">//服务器证书和存储在应用中的证书进行对比验证</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</div><div class="line">        <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</div><div class="line">            <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</div><div class="line">                trustedPublicKeyCount += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div></pre></td></tr></table></figure></p>
<h3 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h3><p>AFURLSessionManager管理所有的请求，session 设置了NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate 实现证书合法性校验，数据传输进度检测，数据请求成功或失败的回调。<br>使用runtime 用af_supend 替换 suspend,用af_resume 替换了resume 当调用这两个方法的时候往上层发送通知AFNetworkingTaskDidSuspendNotification AFNetworkingTaskDidResumeNotification</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Method afResumeMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_resume));</div><div class="line">Method afSuspendMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_suspend));</div><div class="line"></div><div class="line"><span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_resume), afResumeMethod)) &#123;</div><div class="line">    af_swizzleSelector(theClass, <span class="keyword">@selector</span>(resume), <span class="keyword">@selector</span>(af_resume));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_suspend), afSuspendMethod)) &#123;</div><div class="line">    af_swizzleSelector(theClass, <span class="keyword">@selector</span>(suspend), <span class="keyword">@selector</span>(af_suspend));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="AFNetworking-3-0迁移指南"><a href="#AFNetworking-3-0迁移指南" class="headerlink" title="AFNetworking 3.0迁移指南"></a>AFNetworking 3.0迁移指南</h3><p><code>新设备要求:</code> iOS 7, Mac OS X 10.9, watchOS 2, tvOS 9, &amp; Xcode 7</p>
<p> NSURLConnection的API已废弃<br>AFNetworking 1.0建立在NSURLConnection的基础API之上 ，AFNetworking 2.0开始使用NSURLConnection的基础API ，以及较新基于NSURLSession的API的选项。 AFNetworking 3.0现已完全基于NSURLSession的API，这降低了维护的负担，同时支持苹果增强关于NSURLSession提供的任何额外功能。由于Xcode 7中，NSURLConnection的API已经正式被苹果弃用。虽然该API将继续运行，但将没有新功能将被添加，并且苹果已经通知所有基于网络的功能，以充分使NSURLSession向前发展。AFNetworking 2.X将继续获得关键的隐患和安全补丁，但没有新的功能将被添加。Alamofire(Swift下的网络请求)软件基金会建议，所有的项目迁移到基于NSURLSession的API。</p>
<p>弃用的类<br>下面的类已从AFNetworking 3.0中废弃</p>
<ul>
<li>AFURLConnectionOperation</li>
<li>AFHTTPRequestOperation</li>
<li><p>AFHTTPRequestOperationManager</p>
<p>修改的类<br>下面的类包含基于NSURLConnection的API的内部实现。他们已经被使用NSURLSession重构</p>
</li>
<li>UIImageView+AFNetworking</li>
<li>UIWebView+AFNetworking</li>
<li>UIButton+AFNetworking</li>
</ul>
<h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><p>AFHTTPRequestOperationManager 核心代码<br>如果你以前使用 AFHTTPRequestOperationManager ， 你将需要迁移去使用 AFHTTPSessionManager。 以下的类在两者过渡间并没有变化</p>
<ul>
<li>securityPolicy</li>
<li>requestSerializer</li>
<li>responseSerializer<br>接下来举一个关于AFHTTPSessionManager的简单例子。注意HTTP网络请求返回的不再是AFHTTPRequestOperation, 修改成为了NSURLSessionTask，并且成功和失败的Block块中的参数也变更为了NSURLSessionTask，而不再是AFHTTPRequestOperation。</li>
</ul>
<p>AFNetworking 2.x<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</div><div class="line">[manager GET:<span class="string">@"请求的url"</span> parameters:<span class="literal">nil</span> success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"成功"</span>);</div><div class="line">&#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span>*error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"失败"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">AFNetworking <span class="number">3.0</span></div><div class="line">AFHTTPSessionManager *session = [AFHTTPSessionManager manager];</div><div class="line">[session GET:<span class="string">@"请求的url"</span> parameters:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"成功"</span>);</div><div class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"失败"</span>);        </div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h3 id="AFHTTPRequestOperation-核心代码"><a href="#AFHTTPRequestOperation-核心代码" class="headerlink" title="AFHTTPRequestOperation 核心代码"></a>AFHTTPRequestOperation 核心代码</h3><p>与NSURLConnection对象不同，每个共享应用范围的设置如会话管理、缓存策略、Cookie存储以及URL协议等，这些NSURLSession对象都可以单独进行配置。使用特定的配置来初始化会话，它可以发送任务来获取数据，并上传或下载文件。在AFNetworking 2.0中，使用AFHTTPRequestOperation，有可能创建一个没有额外开销的独立的网络请求来获取数据。NSURLSession则需要更多的开销，为了获得所要请求的数据。接下来，将要通过AFHTTPSessionManager创建一个对象，并创建一个任务和启动它。</p>
<p>AFNetworking 2.x<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line">AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];</div><div class="line">op.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line"></div><div class="line">[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JSON: %@"</span>, responseObject);</div><div class="line">&#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">&#125;];</div><div class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperation:op];</div></pre></td></tr></table></figure></p>
<p>AFNetworking 3.0<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</div><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line">[manager GET:URL.absoluteString parameters:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JSON: %@"</span>, responseObject);</div><div class="line">&#125; failure:^(<span class="built_in">NSURLSessionTask</span> *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h3 id="UIKit的迁移"><a href="#UIKit的迁移" class="headerlink" title="UIKit的迁移"></a>UIKit的迁移</h3><p>图片下载已经被重构，以遵循AlamofireImage架构与新的AFImageDownloader类。这个类的图片下载职责的代理人是UIButton与UIImageView的类目，并且提供了一些方法，在必要时可以自定义。类别中，下载远程图片的实际方法没有改变。UIWebView的类目被重构为使用AFHTTPSessionManager作为其网络请求。</p>
<h3 id="UIAlertView的类目被废弃"><a href="#UIAlertView的类目被废弃" class="headerlink" title="UIAlertView的类目被废弃"></a>UIAlertView的类目被废弃</h3><p>从AFNetworking 3.0后UIAlertView的类目因过时而被废弃。并没有提供UIAlertController类目的计划，因为这是应用程序应处理的逻辑，而不是这个库。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS图片缓存的优化]]></title>
      <url>http://yoursite.com/2014/04/08/2014/iOS%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="图片缓存的优化"><a href="#图片缓存的优化" class="headerlink" title="图片缓存的优化"></a>图片缓存的优化</h3><p>从图片入手<br>内存占用大原因是图片太大，所以想到对图片进行压缩。找了好多压缩工具，最后发现一款比较好用的，名字是ppDuck（pp鸭），这里是<a href="http://ppduck.com/" target="_blank" rel="external">下载地址</a>,图片压缩后，内存确实是暂用较少了，但还没有根本结局。从加载图片的方式考虑 ,正确选择图片加载方式能够对内存优化起到很大的作用，常见的图片加载方式有下面三种。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法1  </span></div><div class="line"><span class="built_in">UIImage</span> *imag1 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>];  </div><div class="line"><span class="comment">//方法2  </span></div><div class="line"><span class="built_in">UIImage</span> *image2 = [<span class="built_in">UIImage</span> imageWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image@2x"</span> ofType:.png]];  </div><div class="line"><span class="comment">//方法3  </span></div><div class="line"><span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image@2x"</span> ofType:png]];  </div><div class="line"><span class="built_in">UIImage</span> *image3 = [<span class="built_in">UIImage</span> imageWithData:imageData]；</div></pre></td></tr></table></figure></p>
<p>第一种方法:imageNamed:<br>为什么有两种方法完成同样的事情呢？imageNamed的优点在于可以缓存已经加载的图片。苹果的文档中有如下说法：这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回。对于同一个图像，系统只会把它Cache到内存一次，这对于图像的重复利用是非常有优势的。例如：你需要在 一个TableView里重复加载同样一个图标，那么用imageNamed加载图像，系统会把那个图标Cache到内存，在Table里每次利用那个图 像的时候，只会把图片指针指向同一块内存。这种情况使用imageNamed加载图像就会变得非常有效。</p>
<p>第二种方法和第三种方法本质是一样的:imageWithContentsOfFile:和imageWithData:<br>而imageWithContentsOfFile方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当你不需要重用该图像，或者你需要将</p>
<p> 如何选择<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法1 cach  </span></div><div class="line"><span class="built_in">UIImage</span> *imag1 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>];  </div><div class="line"><span class="comment">//方法2 no cach  </span></div><div class="line"><span class="built_in">UIImage</span> *image2 = [<span class="built_in">UIImage</span> imageWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image.png"</span> ofType:<span class="literal">nil</span>]];</div></pre></td></tr></table></figure></p>
<p>如果加载一张很大的图片，并且只使用一次，那么就不需要缓存这个图片。这种情况imageWithContentsOfFile比较合适,系统不会浪费内存来缓存图片。然而，如果在程序中经常需要重用的图片，那么最好是选择imageNamed方法。这种方法可以节省出每次都从磁盘加载图片的时间。</p>
<h3 id="Ios圆角图片的优化"><a href="#Ios圆角图片的优化" class="headerlink" title="Ios圆角图片的优化"></a>Ios圆角图片的优化</h3><p>原理<br>上面拖慢帧率的原因其实都是Off-Screen Rendering（离屏渲染）的原因。离屏渲染是个好东西，但是频繁发生离屏渲染是非常耗时的。</p>
<p>Off-Screen Rendering<br>离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。由上面的一个结论视图和圆角的大小对帧率并没有什么卵影响，数量才是伤害的核心输出啊。可以知道离屏渲染耗时是发生在离屏这个动作上面，而不是渲染。为什么离屏这么耗时？原因主要有创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。</p>
<p>上下文切换<br>上下文切换，不管是在GPU渲染过程中，还是一直所熟悉的进程切换，上下文切换在哪里都是一个相当耗时的操作。首先我要保存当前屏幕渲染环境，然后切换到一个新的绘制环境，申请绘制资源，初始化环境，然后开始一个绘制，绘制完毕后销毁这个绘制环境，如需要切换到On-Screen,Rendering或者再开始一个新的离屏渲染重复之前的操作。 下图描述了一次mask的渲染操作。</p>
<p>一次mask发生了两次离屏渲染和一次主屏渲染。即使忽略昂贵的上下文切换，一次mask需要渲染三次才能在屏幕上显示，这已经是普通视图显示3陪耗时，若再加上下文环境切换，一次mask就是普通渲染的30倍以上耗时操作。问我这个30倍以上这个数据怎么的出来的？当我在cell的UIImageView的实例增加到150个，并去掉圆角的时候，帧数才跌至28帧每秒。虽然不是甚准确，但至少反映mask这个耗时是无mask操作的耗时的数十倍的。</p>
<p> 第一种:设置CALayer的cornerRadius<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"img"</span>];</div><div class="line">imageView.image.layer.cornerRadius = <span class="number">5</span>;</div><div class="line">imageView.image.layer.masksToBounds = <span class="literal">YES</span>;</div></pre></td></tr></table></figure></p>
<p>这样设置会触发离屏渲染，比较消耗性能。比如当一个页面上有十几头像这样设置了圆角会明显感觉到卡顿。这种就是最常用的，也是最耗性能的。注意：ios9.0之后对UIImageView的圆角设置做了优化，UIImageView这样设置圆角不会触发离屏渲染，ios9.0之前还是会触发离屏渲染。而UIButton还是都会触发离屏渲染。</p>
<p>第二种<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">imageView.clipsToBounds = <span class="literal">YES</span>;</div><div class="line">imageView.layer setCornerRadius:<span class="number">50</span>];</div><div class="line">imageView.layer.shouldRasterize = <span class="literal">YES</span>;</div></pre></td></tr></table></figure></p>
<p>shouldRasterize=YES设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图， 使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新 创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</p>
<p>第三种:通过Core Graphics重新绘制带圆角的视图<br>这种方式性能最好，但是UIButton上不知道怎么绘制，可以用UIimageView添加个 点击手势当做UIButton使用<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">CircleImage</span>)</span></div><div class="line">- (<span class="built_in">UIImage</span> *)drawCircleImage &#123;</div><div class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size, <span class="literal">NO</span>, [<span class="built_in">UIScreen</span> mainScreen].scale); </div><div class="line">    [[<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span>.bounds cornerRadius:<span class="number">50</span>] addClip]; </div><div class="line">    [<span class="keyword">self</span> drawInRect:<span class="keyword">self</span>.bounds]; </div><div class="line">    <span class="built_in">UIImage</span> *output = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    <span class="keyword">return</span> output; </div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">//在需要圆角时调用如下</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="built_in">UIImage</span> *img = [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>] drawCircleImage];</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        imageView.image = img;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>第四种: 通过混合图层<br>此方法就是在要添加圆角的视图上再叠加一个部分透明的视图，只对圆角部分进行遮挡。图层混合的透明度处理方式与mask正好相反。此方法虽然是最优解，没有离屏渲染，没有额外的CPU计算，但是应用范围有限。</p>
<p>总结<br>在可以使用混合图层遮挡的场景下，优先使用第四种方法。即使是非iOS9以上系统，第一种方法在综合性能上依然强于后两者，iOS9以上由于没有了离屏渲染更是首选。方法三由于需要大量计算和增加部分内存，需要实际情况各自取舍。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[苹果的内存管理]]></title>
      <url>http://yoursite.com/2014/04/04/2014/%E8%8B%B9%E6%9E%9C%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="苹果是如何“收垃圾”的"><a href="#苹果是如何“收垃圾”的" class="headerlink" title="苹果是如何“收垃圾”的?"></a>苹果是如何“收垃圾”的?</h3><p>不管搭载的iOS还是Android，设备的运行内存都是有限的。在你开了一大堆应用程序，快要把内存占满的时候，为了维持正常运行，iOS和Android都会Kill掉一些后台进程，这个行为也称为“垃圾回收机制”。但需要注意的是，iOS和Android“收垃圾”的方式不甚相同。iOS会依次把最老的应用直接关闭掉，所以时候在切换到很老的后台App时会发现，它们都会从标题界面重新启动。相比之下，Android的胆子则要小得多，它不会直接关掉App，而是筛选出其中的一些无用对象，率先把它们Kill掉，从而释放部分内存。但只要你不手动关，这些后台程序都不会自动消失。因此，苹果设备就算只有1GB运行内存，你正在用的App也绝对不会卡，而Android后台程序不会自动被关闭，需要提供更多的内存(2GB、3GB甚至更多)才能保证系统流畅运行。内存需求小不是苹果牛掰的意思，虽然1GB用着也很舒坦，但说“苹果优化好”似乎不太准确，因为iOS和Android的垃圾处理方法并不是一个高端、一个土鳖，而是各有利弊。</p>
<p>iOS会无差别地关掉老应用，这意味着如果你正在玩一个大型游戏，那么可能微信、微博、QQ这些软件就全都被关掉了。你若想切换回这些软件，就要经历一个相当闹心的启动过程。朋友圈发完了、微博也玩够了，这回天下该太平了吧?等等，但愿你的游戏还能回到刚才暂停的位置……另外一个比较闹心的场景就是你在Safari浏览器里开了N个标签，1GB运存承受不住那么多的内容，于是非常自觉地把最老的几个网页给挂起了。如果那几个页面刚好是你填了一半的付款界面或者是写了一半的文章，那么……那Android又是怎么坑爹的呢? 想必用家们都深有感触：切换界面会卡、接电话会卡、解锁会卡，连看个照片都得等半天。但是，Android的大内存也有得天独厚的好处，那就是不管你想开什么后台应用，它们都会把你上次干半截的事情完整地带到前台，不会连个招呼都不打就关了它们。尤其目前市面上具备3GB运行内存的Android手机，它们既能够保证大量应用同时运行，也能保持整个系统处在一个比较流畅的状态，整体的体验也还是可以的(开好几十个应用不关的除外)。所以，iOS的“霸道型小内存”和Android的“人文关怀型大内存”其实都是各有利弊的，并不是简单的一个比另一个好的关系。</p>
<h3 id="运存那么小，你以为苹果真的很满足"><a href="#运存那么小，你以为苹果真的很满足" class="headerlink" title="运存那么小，你以为苹果真的很满足?"></a>运存那么小，你以为苹果真的很满足?</h3><p>苹果在iPhone 6和6 Plus上保持1GB运行内存，不单单是因为用起来不卡，其实也基于以下一些问题进行了考量：内存耗电：更多的内存会消耗更多的电能，iPhone6内存仅1GB，而且采用了LPDDR3低电压版模块，节能效果相当可观;成本问题：升级到2GB或者更高，单台手机的制造成本并不会提高多少，但是对于一个出货量动辄好几千万的产品来说，那算下来可得损失不少钱呢!用户需求问题：虽然存在着一些略显坑爹的关后台问题，但是果粉们早就习惯了，就算加大内存容量，整体体验的提升也不见得多明显。对于追求各方面性能均衡的苹果来说，单个指标不突出不算是缺憾。其实说到底，在理想状态下，苹果也非常想让内存更大一些，毕竟用户运行多任务的时候，谁都希望能多开几个应用。苹果也意识到随着用户需求的提高，内存问题势必变得愈加尖锐，他们已然开始行动了：iPad Air 2升级到了2GB内存，这样一来，相信下一代的iPhone离大运存也不会太远了。</p>
<h3 id="那么1G的内存是如何分配给各个App的嘞"><a href="#那么1G的内存是如何分配给各个App的嘞" class="headerlink" title="那么1G的内存是如何分配给各个App的嘞?"></a>那么1G的内存是如何分配给各个App的嘞?</h3><p>苹果给每个应用程序设置20M的内存警告量，<code>30M的闪退量</code>，游戏会略微放款10~20M，需要向系统申请。这一条说明除了系统本身占用内存以外，任何程序几乎都不可能占用超过50M内存。实际上，不是单个程序存在50M的内存使用上限，而是单线程使用上限是50M，同一个程序可以加载多个线程，同一个程序可以使用多个线程。</p>
<ul>
<li><p>关于后台:<br>苹果设计本身就没有后台，当你把程序最小化的时候程序就暂停了一切活动。如果应用想继续运行一部分功能的话，必须向系统申请运行时长，或者调用系统功能，比如音乐播放。由此跟安卓需要大内存来支持后台运行的区别就显而易见了，因为安卓是在Linux上跑的Java虚拟机，他的内存管理机制是申请之后就一直在那放着，等一个Runtime周期结束之后会自动收回不必要的内存。</p>
</li>
<li><p>关于内存：<br>个人认为，IOS只要不彻底重新编写的话，苹果几乎不可能开放海量内存，因为它既不支持真后台，又给APP设置了50M的内存使用上限。打个比方：你开法拉利（超大内存），我开QQ（1G内存），咱俩一起在路上跑（使用内存），但是限速50（内存使用限制），只要超过限速就扣车（超过限制即强行释放内存），你开再好的车也不可能比我快多少，因为苹果不让，除非苹果放开限速让你随便跑（开放内存配额上限）。但是不把路挖掉重新铺的话（系统限制，除非大刀阔斧的做改造，否则开放意义也不大，主要是苹果公司认为没意义……），就不能开放限速，所以现阶段只能限速50.这就是IPHONE只用1G内存的原因。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS静态库的制作]]></title>
      <url>http://yoursite.com/2014/03/20/2014/iOS%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="一、什么是库？"><a href="#一、什么是库？" class="headerlink" title="一、什么是库？"></a>一、什么是库？</h3><p>库是共享程序代码的方式，一般分为静态库和动态库。<br><code>静态库</code>：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。<br><code>动态库</code>：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</p>
<h3 id="二、静态库和动态库的好处"><a href="#二、静态库和动态库的好处" class="headerlink" title="二、静态库和动态库的好处"></a>二、静态库和动态库的好处</h3><p>1.使用静态库的好处</p>
<ul>
<li>模块化，分工合作</li>
<li>避免少量改动经常导致大量的重复编译连接</li>
<li>也可以重用，注意不是共享使用<br>2 动态库使用有如下好处</li>
<li>使用动态库，可以将最终可执行文件体积缩小</li>
<li>使用动态库，多个应用程序共享内存中得同一份库文件，节省资源</li>
<li>使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。</li>
</ul>
<p>从1可以得出，将整个应用程序分模块，团队合作，进行分工，影响比较小。<br>从2可以看出，其实动态库应该叫共享库，那么从这个意义上来说，苹果禁止iOS开发中使用动态库就可以理解了：<br>因为在现在的iPhone，iPodTouch，iPad上面程序都是单进程的，也就是某一时刻只有一个进程在运行，那么你写个共享库，<br>—-共享给谁？（你使用的时候只有你一个应用程序存在，其他的应该被挂起了，即便是可以同时多个进程运行，别人能使用你的共享库里的东西吗？你这个是给你自己的程序定制的。）<br>—-目前苹果的AppStore不支持模块更新，无法更新某个单独文件(除非自己写一个更新机制：有自己的服务端放置最新动态库文件)<br>至于苹果为啥禁止ios开发使用动态库我就猜到上面俩原因</p>
<h3 id="三、iOS里静态库和动态库形式？"><a href="#三、iOS里静态库和动态库形式？" class="headerlink" title="三、iOS里静态库和动态库形式？"></a>三、iOS里静态库和动态库形式？</h3><p>静态库：.a和.framework<br>动态库：.dylib和.framework</p>
<h3 id="四、framework为什么既是静态库又是动态库？"><a href="#四、framework为什么既是静态库又是动态库？" class="headerlink" title="四、framework为什么既是静态库又是动态库？"></a>四、framework为什么既是静态库又是动态库？</h3><p>系统的.framework是动态库，我们自己建立的.framework是静态库。</p>
<h3 id="五、a与-framework有什么区别？"><a href="#五、a与-framework有什么区别？" class="headerlink" title="五、a与.framework有什么区别？"></a>五、a与.framework有什么区别？</h3><p>.a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。<br>.a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用。<br>.a + .h + sourceFile = .framework。<br>建议用.framework.</p>
<h3 id="六、为什么要使用静态库？"><a href="#六、为什么要使用静态库？" class="headerlink" title="六、为什么要使用静态库？"></a>六、为什么要使用静态库？</h3><p>国内的企业，掌握有核心技术，同时是又希望更多的程序员来使用其技术，因此采用”闭源”的方式开发使用。例如：百度地图，友盟，JPush等。在企业开发中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，也会提供静态库给程序员使用。方便共享代码，便于合理使用。实现iOS程序的模块化。可以把固定的业务模块化成静态库。和别人分享你的代码库，但不想让别人看到你代码的实现。开发第三方sdk的需要。</p>
<h3 id="七、静态库的种类"><a href="#七、静态库的种类" class="headerlink" title="七、静态库的种类"></a>七、静态库的种类</h3><p>1.静态库文件的版本(4种)</p>
<ul>
<li>真机-Debug版本</li>
<li>真机-Release版本</li>
<li>模拟器-Debug版本</li>
<li>模拟器-Release版本</li>
</ul>
<p>2.调试版本(Debug版本) VS 发布版本(Release版本)</p>
<ul>
<li>调试版本会包含完整的符号信息，以方便调试</li>
<li>调试版本不会对代码进行优化</li>
<li>发布版本不会包含完整的符号信息</li>
<li>发布版本的执行代码是进行过优化的</li>
<li>发布版本的大小会比调试版本的略小</li>
<li>在执行速度方面，调试版本会更快些，但不意味着会有显著的提升</li>
</ul>
<h3 id="八、制作静态库时的几点注意："><a href="#八、制作静态库时的几点注意：" class="headerlink" title="八、制作静态库时的几点注意："></a>八、制作静态库时的几点注意：</h3><p>1 注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本        身已经包含了.h和其它文件，可以直接使用。<br>2 图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。<br>3 category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。<br>4 如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。</p>
<h3 id="九、关于静态库的报错"><a href="#九、关于静态库的报错" class="headerlink" title="九、关于静态库的报错"></a>九、关于静态库的报错</h3><p>Undefined symbols for architecture i386:  i386可以理解为制作CPU的时候的CPU的种类<br>报上面的错表示:静态库不能在使用i386架构的cpu设备上面运行</p>
<p>i386 : iPhone模拟器 3gs-&gt;iPhone5<br>x86_64 : iPhone模拟器 5s-&gt;6plus</p>
<p>lipo -info 静态库:查看该静态库支持哪些架构<br>armv7 : iPhone 3gs-&gt;4s<br>armv7s : iPhone 5-&gt;5c<br>arm64 : iPhone 5s-&gt;6plus</p>
<h3 id="合并-a"><a href="#合并-a" class="headerlink" title="合并.a"></a>合并.a</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo -create Debug-iphoneos/libTools.a Debug-iphonesimulator/libTools.a -output libTools.a</div></pre></td></tr></table></figure>
<ul>
<li>合并.a的好处，开发过程中既可以在真机上调试，也可以在模拟器上调试</li>
<li>合并.a的坏处，如果静态库太大，合并打包后，会非常大，因此很多第三方的静态库的.a是区分版本的</li>
<li>今后在使用.a时一定注意版本</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS静态库的制作ARM细节]]></title>
      <url>http://yoursite.com/2014/03/13/2014/iOS%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9CARM%E7%BB%86%E8%8A%82/</url>
      <content type="html"><![CDATA[<h3 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h3><p>平时项目开发中，可能使用第三方提供的静态库.a，如果.a提供方技术不成熟，使用的时候就会出现问题，例如：<br>在真机上编译报错：<code>No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=i386).</code><br>在模拟器上编译报错：<code>No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 armv6).</code><br>要解决以上问题，就要了解一下Apple移动设备处理器指令集相关的一些细节知识。</p>
<h3 id="二、几个重要概念"><a href="#二、几个重要概念" class="headerlink" title="二、几个重要概念"></a>二、几个重要概念</h3><p>1、ARM<br>ARM处理器，特点是体积小、低功耗、低成本、高性能，所以几乎所有手机处理器都基于<code>ARM</code>，在嵌入式系统中应用广泛。</p>
<p>2、ARM处理器指令集<br><code>armv6｜armv7｜armv7s｜arm64</code>都是ARM处理器的指令集，这些指令集都是向下兼容的，例如<code>armv7</code>指令集兼容armv6，只是使用<code>armv6</code>的时候无法发挥出其性能，无法使用<code>armv7</code>的新特性，从而会导致程序执行效率没那么高。<br>还有两个我们也很熟悉的指令集：<code>i386｜x86_64</code> 是Mac处理器的指令集，<code>i386</code>是针对<code>intel</code>通用微处理器<code>32架构</code>的。<code>x86_64</code>是针对<code>x86架构</code>的<code>64位处理器</code>。所以当使用iOS模拟器的时候会遇到<code>i386｜x86_64</code>，iOS模拟器没有arm指令集。</p>
<p>3、目前iOS移动设备指令集<br>arm64：iPhone5S｜ iPad Air｜ iPad mini2(iPad mini with Retina Display)<br>armv7s：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)<br>armv7：iPhone3GS｜iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4<br>armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch（一般不需要去支持）</p>
<p>4、Xcode中指令集相关选项（Build Setting中）<br>Architectures<br><code>Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures.</code><br>指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。</p>
<p>Valid Architectures<br><code>Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary.</code><br>限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由<code>Architectures</code>与<code>Valid Architectures</code>（因此这个不能为空）的交集来确定，例如：<br>比如，你的<code>Valid Architectures</code>设置的支持arm指令集版本有：<code>armv7/armv7s/arm64</code>，对应的<code>Architectures</code>设置的支持arm指令集版本有：<code>armv7s</code>，这时Xcode只会生成一个armv7s指令集的二进制包。<br>再比如：将<code>Architectures</code>支持<code>arm</code>指令集设置为：<code>armv7,armv7s</code>，对应的<code>Valid Architectures</code>的支持的指令集设置为：<code>armv7s,arm64</code>，那么此时，XCode生成二进制包所支持的指令集只有armv7s</p>
<p>在Xcode6.1.1里的 <code>Valid Architectures</code>  设置里， 默认为 <code>Standard architectures(armv7,arm64)</code>,如果你想改的话，自己在other中更改。<br>原因解释如下：<br>使用 <code>standard architectures (including 64-bit)(armv7,arm64)</code> 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。 这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。 而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。</p>
<p>所以总结如下：<br>要发挥iPhone5s的64位性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。</p>
<p>Build Active Architecture Only<br>指定是否只对当前连接设备所支持的指令集编译<br>当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低<code>（arm64 &gt; armv7s &gt; armv7）</code>依次匹配的。比如你设置此值为yes，用<code>iphone4</code>编译出来的是<code>armv7</code>版本的，iphone5也可以运行，但是<code>armv6</code>的设备就不能运行。  所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。 </p>
<p>Architectures:  armv7, armv7s, arm64<br>ValidArchitectures:  armv6, armv7s, arm64<br>生成二进制包支持的指令集： <code>arm64</code></p>
<p>Architectures: armv6, armv7, armv7s<br>Valid Architectures:  armv6, armv7s, arm64<br>生成二进制包支持的指令集： <code>armv7s</code> </p>
<p>Architectures: armv7, armv7s, arm64<br>Valid Architectures: armv7，armv7s<br>这种情况是报错的，因为允许使用指令集中没有<code>arm64</code><br>注：如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。</p>
<h3 id="三、制作静态库-a是指令集选择"><a href="#三、制作静态库-a是指令集选择" class="headerlink" title="三、制作静态库.a是指令集选择"></a>三、制作静态库.a是指令集选择</h3><p>现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，<code>Build Active Architecture Only</code>设置成YES，<code>Architectures</code>按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。<br>ValidArchitectures设置为：<code>armv7｜armv7s｜arm64｜i386｜x86_64</code><br>Architectures设置不变（或根据你需要）:  <code>armv7｜arm64</code><br>然后分别选择iOS设备和模拟器进行编译，最后找到相关的.a进行合包，使用<code>lipo -create</code> 真机库.a的路径 模拟器库.a的的路径 －output 合成库的名字.a。这样就制作了一个通用的静态库.a。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS常见的储存方案]]></title>
      <url>http://yoursite.com/2014/03/10/2014/%20iOS%E5%B8%B8%E8%A7%81%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>概念问题<br>首先要明确区分两个概念，数据结构和储存方式。所谓数据结构就是数据存在的形式。除了基本的<code>NSDictionary</code>、<code>NSArray</code>和<code>NSSet</code>这些对象，还有更复杂的如：关系模型、对象图和属性列表多种结构。而存储方式则简单的分为两种：内存与闪存。内存存储是临时的，运行时有效的，但效率高，而闪存则是一种持久化存储，但产生I/O消耗，效率相对低。把内存数据转移到闪存中进行持久化的操作称成为归档。二者结合起来才是完整的数据存储方案，我们最常谈起的那些：SQLite、CoreData、NSUserDefaults等都是数据存储方案。当然在这些框架提供的方案之外，我们自己也可以按照个性化需求订制方案。这些存储方案侧重不同，支持的形式和方式也各不相同，在不同的使用场景下表现也是各有优劣。但万变不离其宗。</p>
<ul>
<li>1.以下将对四种存储方式进行详细的介绍</li>
<li>2.NSUserDefaults 用于存储配置信息</li>
<li>3.SQLite 用于存储查询需求较多的数据</li>
<li>4.CoreData，用于规划应用中的对象</li>
<li>5.使用基本对象类型定制的个性化缓存方案</li>
</ul>
<p>1.用NSUserDefaults存储配置信息<br>NSUserDefaults被设计用来存储设备和应用的配置信息，它通过一个工厂方法返回默认的、也是最常用到的实例对象。这个对象中储存了系统中用户的配置信息，开发者可以通过这个实例对象对这些已有的信息进行修改，也可以按照自己的需求创建新的配置项。<br>NSUserDefaults把配置信息以字典的形式组织起来，支持字典的项包括：字符串或者是数组，除此之外还支持数字等基本格式。一句话概括就是：基础类型的小数据的字典。操作方法几乎与NSDictionary的操作方法无异，另外还可以通过指定返回类型的方法获取到指定类型的返回值。<br>NSUserDefaults的所有数据都放在内存里，因此操作速度很快，并还提供一个归档方法：+ (void)synchronize。开发者自定义的配置项（如图2中的最后一项 key:alkdjfkladsjfmm）会以plist格式的文件归档在相应应用目录的/Library/Preferences/[App_Bundle_Identifier].plist文件。再次初始化获得实例对象后，框架会把用户自定义的这个配置和系统配置合并得到完整数据。</p>
<p>2.用SQLite存储查询需求较多的数据<br>iOS的SDK里预置了SQLite的库，开发者可以自建SQLite数据库。SQLite每次写入数据都会产生IO消耗，把数据归档到相应的文件。SQLite擅长处理的数据类型其实与NSUserDefaults差不多，也是基础类型的小数据，只是从组织形式上不同。开发者可以以关系型数据库的方式组织数据，使用SQL DML来管理数据。 一般来说应用中的格式化的文本类数据可以存放在数据库中，尤其是类似聊天记录、Timeline等这些具有条件查询和排序需求的数据。每一个数据库的句柄都会在内存中都会被分配一段缓存，用于提高查询效率。另一个方面，由于查询缓存，当产生大量句柄或数据量较大时，会出现缓存过大，造成内存浪费。SQLite的使用起来要比NSUserDefaults复杂的多，因此建议开发者使用SQLite要搭配一个操作控件使用，可以简化操作。笔者开发的SQLight是一款对SQLite操作的封装，把相对复杂的SQLite命令封装成对象和方法，可以供大家参考。大家可以在Github上获取这个工程的代码进一步了解。</p>
<p>3.用CoreData规划应用中对象<br>官方给出的定义是，一个支持持久化的，对象图和生命周期的自动化管理方案。严格意义上说CoreData是一个管理方案，他的持久化可以通过SQLite、XML或二进制文件储存。如官方定义所说，CoreData的作用远远不止储存数据这么简单，它可以把整个应用中的对象建模并进行自动化的管理。<br>MyDocument是一个对象实例，有两个Collection：Employee和Department，存放各自的对象列表。MyDocument、Employee和Department三个对象以及他们之间的关系都通过CoreData建模，并可以通过save方法进行持久化。<br>从归档文件还原模型时CoreData并不是一次性把整个模型中的所有数据都载入内存，而是根据运行时状态，把被调用到的对象实例载入内存。框架会自动控制这个过程，从而达到控制内存消耗，避免浪费。<br>无论从设计原理还是使用方法上看，CoreData都比较复杂。因此，如果仅仅是考虑缓存数据这个需求，CoreData绝对不是一个优选方案。CoreData的使用场景在于：整个应用使用CoreData规划，把应用内的数据通过CoreData建模，完全基于CoreData架构应用。<br>之前提到的NSUserDefaults和SQLite适合存储基础类型的小数据，而CoreData则不适合存储单一的数据</p>
<h2 id="iOS四种储存方案的使用"><a href="#iOS四种储存方案的使用" class="headerlink" title="iOS四种储存方案的使用"></a>iOS四种储存方案的使用</h2><p>持久化：所谓的持久化，就是将数据保存到硬盘中，使得在应用程序或机器重启后可以继续访问之前保存的数据。</p>
<h3 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h3><p>在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p>
<p>沙盒的目录结构</p>
<ul>
<li>1.Documents</li>
<li>2.Library</li>
<li>3.Caches</li>
<li>4.Preferences</li>
<li>5.tmp</li>
</ul>
<p>目录特性：虽然沙盒中有这么多文件夹，但是没有文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</p>
<ul>
<li><p>1.应用程序包</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里面存放的是应用程序的源文件，包括资源文件和可执行文件。</span></div><div class="line"><span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] bundlePath];</div></pre></td></tr></table></figure>
</li>
<li><p>2.Documents</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。</span></div><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure>
</li>
<li><p>3.Library/Caches</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。</span></div><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure>
</li>
<li><p>4.Library/Preferences<br>iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</p>
</li>
<li><p>5.tmp<br>iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSTemporaryDirectory</span>();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>plist文件是将某些特定的类，通过XML文件的方式保存在目录中，可以被序列化的类型只有如下几种：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span>;</div><div class="line"><span class="built_in">NSMutableArray</span>;</div><div class="line"><span class="built_in">NSDictionary</span>;</div><div class="line"><span class="built_in">NSMutableDictionary</span>;</div><div class="line"><span class="built_in">NSData</span>;</div><div class="line"><span class="built_in">NSMutableData</span>;</div><div class="line"><span class="built_in">NSString</span>;</div><div class="line"><span class="built_in">NSMutableString</span>;</div><div class="line"><span class="built_in">NSNumber</span>;</div><div class="line"><span class="built_in">NSDate</span>;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>1.获得文件路径</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</div><div class="line"><span class="built_in">NSString</span> *fileName = [path stringByAppendingPathComponent:<span class="string">@"123.plist"</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>2.存储</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"123"</span>, <span class="string">@"456"</span>, <span class="string">@"789"</span>];</div><div class="line">[array writeToFile:fileName atomically:<span class="literal">YES</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>3.读取</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *result = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:fileName];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意<br>只有以上列出的类型才能使用plist文件存储。存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。读取时使用arrayWithContentsOfFile:方法。</p>
<h3 id="Preference-偏好设置"><a href="#Preference-偏好设置" class="headerlink" title="Preference(偏好设置)"></a>Preference(偏好设置)</h3><ul>
<li><p>使用方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获得NSUserDefaults文件</span></div><div class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div></pre></td></tr></table></figure>
</li>
<li><p>向文件中写入内容</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[userDefaults setObject:<span class="string">@"AAA"</span> forKey:<span class="string">@"a"</span>];</div><div class="line">[userDefaults setBool:<span class="literal">YES</span> forKey:<span class="string">@"sex"</span>];</div><div class="line">[userDefaults setInteger:<span class="number">21</span> forKey:<span class="string">@"age"</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>立即同步</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[userDefaults synchronize];</div></pre></td></tr></table></figure>
</li>
<li><p>读取文件</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *name = [userDefaults objectForKey:<span class="string">@"a"</span>];</div><div class="line"><span class="built_in">BOOL</span> sex = [userDefaults boolForKey:<span class="string">@"sex"</span>];</div><div class="line"><span class="built_in">NSInteger</span> age = [userDefaults integerForKey:<span class="string">@"age"</span>];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意<br>偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</p>
<p>5.NSKeyedArchiver<br>归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。<br>遵循NSCoding协议:NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p>
<ul>
<li><p>1.遵循协议和设置属性</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.遵循NSCoding协议 </span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//2.设置属性</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIImage</span> *avatar;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>2.实现协议方法<br>解档</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="keyword">self</span>.avatar = [aDecoder decodeObjectForKey:<span class="string">@"avatar"</span>];</div><div class="line">        <span class="keyword">self</span>.name = [aDecoder decodeObjectForKey:<span class="string">@"name"</span>];</div><div class="line">        <span class="keyword">self</span>.age = [aDecoder decodeIntegerForKey:<span class="string">@"age"</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>归档<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.avatar forKey:<span class="string">@"avatar"</span>];</div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.name forKey:<span class="string">@"name"</span>];</div><div class="line">    [aCoder encodeInteger:<span class="keyword">self</span>.age forKey:<span class="string">@"age"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>特别注意</code>如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder] 方法;</p>
<ul>
<li>3.使用<br>需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *file = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.data"</span>];</div><div class="line">Person *person = [[Person alloc] init];</div><div class="line">person.avatar = <span class="keyword">self</span>.avatarView.image;</div><div class="line">person.name = <span class="keyword">self</span>.nameField.text;</div><div class="line">person.age = [<span class="keyword">self</span>.ageField.text integerValue];</div><div class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:person toFile:file];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法unarchiveObjectWithFile: 即可<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *file = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.data"</span>];</div><div class="line">Person *person = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:file];</div><div class="line"><span class="keyword">if</span> (person) &#123;</div><div class="line">    <span class="keyword">self</span>.avatarView.image = person.avatar;</div><div class="line">    <span class="keyword">self</span>.nameField.text = person.name;</div><div class="line">    <span class="keyword">self</span>.ageField.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, person.age];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意<br>1.必须遵循并实现NSCoding协议<br>2.保存文件的扩展名可以任意指定<br>3.继承时必须先调用父类的归档解档方法</p>
<h3 id="SQLite3"><a href="#SQLite3" class="headerlink" title="SQLite3"></a>SQLite3</h3><p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p>
<p>1.字段类型<br>表面上SQLite将数据分为以下几种类型：</p>
<ul>
<li>integer : 整数</li>
<li>real : 实数（浮点数）</li>
<li>text : 文本字符串</li>
<li>blob : 二进制数据，比如文件，图片之类的<br>实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！主键必须设置成integer</li>
</ul>
<p>2.准备工作<br>准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。</p>
<p>3.使用,创建数据库并打开<br>操作数据库之前必须先指定数据库文件和要操作的表，所以使用SQLite3，首先要打开数据库文件，然后指定或创建一张表。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*  打开数据库并创建一个表</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)openDatabase &#123;</div><div class="line">    <span class="comment">//1.设置文件名</span></div><div class="line">    <span class="built_in">NSString</span> *filename = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.db"</span>];</div><div class="line">    <span class="comment">//2.打开数据库文件，如果没有会自动创建一个文件</span></div><div class="line">    <span class="built_in">NSInteger</span> result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);</div><div class="line">    <span class="keyword">if</span> (result == SQLITE_OK) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"打开数据库成功！"</span>);</div><div class="line">        <span class="comment">//3.创建一个数据库表</span></div><div class="line">        <span class="keyword">char</span> *errmsg = <span class="literal">NULL</span>;</div><div class="line">        sqlite3_exec(_sqlite3, <span class="string">"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg);</div><div class="line">        <span class="keyword">if</span> (errmsg) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"错误：%s"</span>, errmsg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"创表成功！"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"打开数据库失败！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.执行指令<br>使用 sqlite3_exec() 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*  往表中插入1000条数据</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)insertData &#123;</div><div class="line">    <span class="built_in">NSString</span> *nameStr;</div><div class="line">    <span class="built_in">NSInteger</span> age;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">        nameStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Bourne-%d"</span>, arc4random_uniform(<span class="number">10000</span>)];</div><div class="line">        age = arc4random_uniform(<span class="number">80</span>) + <span class="number">20</span>;</div><div class="line">        <span class="built_in">NSString</span> *sql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"INSERT INTO t_person (name, age) VALUES('%@', '%ld')"</span>, nameStr, age];</div><div class="line">        <span class="keyword">char</span> *errmsg = <span class="literal">NULL</span>;</div><div class="line">        sqlite3_exec(_sqlite3, sql.UTF8String, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg);</div><div class="line">        <span class="keyword">if</span> (errmsg) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"错误：%s"</span>, errmsg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"插入完毕！"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.查询指令<br>前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：</p>
<ul>
<li>sqlite3_prepare_v2() : 检查sql的合法性</li>
<li>sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录</li>
<li>sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。</li>
<li>sqlite3_finalize() : 释放stmt<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*  从表中读取数据到数组中</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)readData &#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> *mArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1000</span>];</div><div class="line">    <span class="keyword">char</span> *sql = <span class="string">"select name, age from t_person;"</span>;</div><div class="line">    sqlite3_stmt *stmt;</div><div class="line">    <span class="built_in">NSInteger</span> result = sqlite3_prepare_v2(_sqlite3, sql, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (result == SQLITE_OK) &#123;</div><div class="line">        <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">char</span> *name = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">0</span>);</div><div class="line">            <span class="built_in">NSInteger</span> age = sqlite3_column_int(stmt, <span class="number">1</span>);</div><div class="line"></div><div class="line">            <span class="comment">//创建对象</span></div><div class="line">            Person *person = [Person personWithName:[<span class="built_in">NSString</span> stringWithUTF8String:name] Age:age];</div><div class="line">            [mArray addObject:person];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">self</span>.dataList = mArray;</div><div class="line">    &#125;</div><div class="line">    sqlite3_finalize(stmt);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 FMDB，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。</p>
<h3 id="FMDB"><a href="#FMDB" class="headerlink" title="FMDB"></a>FMDB</h3><p>1.简介<br>FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:</p>
<ul>
<li>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</li>
<li>对比苹果自带的Core Data框架，更加轻量级和灵活</li>
<li>提供了多线程安全的数据库操作方法，有效地防止数据混乱</li>
</ul>
<p>2.核心类<br>FMDB有三个主要的类:</p>
<ul>
<li><p>FMDatabase<br>一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</p>
</li>
<li><p>FMResultSet<br>使用FMDatabase执行查询后的结果集</p>
</li>
<li><p>FMDatabaseQueue<br>用于在多线程中执行多个查询或更新，它是线程安全的</p>
<p>3.打开数据库<br>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.db"</span>];</div><div class="line">FMDatabase *database = [FMDatabase databaseWithPath:path];    </div><div class="line"><span class="keyword">if</span> (![database open]) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"数据库打开失败！"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>值得注意的是，Path的值可以传入以下三种情况：</p>
<ul>
<li>具体文件路径，如果不存在会自动创建</li>
<li>空字符串@””，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除</li>
<li>nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</li>
</ul>
<p>4.更新<br>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//常用方法有以下3种：   </span></div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdate:(<span class="built_in">NSString</span>*)sql, ...</div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdateWithFormat:(<span class="built_in">NSString</span>*)format, ...</div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdate:(<span class="built_in">NSString</span>*)sql withArgumentsInArray:(<span class="built_in">NSArray</span> *)arguments</div><div class="line"><span class="comment">//示例</span></div><div class="line">[database executeUpdate:<span class="string">@"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)"</span>];   </div><div class="line"><span class="comment">//或者  </span></div><div class="line">[database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES(?, ?)"</span>, <span class="string">@"Bourne"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">42</span>]];</div></pre></td></tr></table></figure></p>
<p>5.查询<br>查询方法也有3种，使用起来相当简单：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (FMResultSet *)executeQuery:(<span class="built_in">NSString</span>*)sql, ...</div><div class="line">- (FMResultSet *)executeQueryWithFormat:(<span class="built_in">NSString</span>*)format, ...</div><div class="line">- (FMResultSet *)executeQuery:(<span class="built_in">NSString</span> *)sql withArgumentsInArray:(<span class="built_in">NSArray</span> *)arguments</div></pre></td></tr></table></figure></p>
<p>查询示例<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.执行查询</span></div><div class="line">FMResultSet *result = [database executeQuery:<span class="string">@"SELECT * FROM t_person"</span>];</div><div class="line"><span class="comment">//2.遍历结果集</span></div><div class="line"><span class="keyword">while</span> ([result next]) &#123;</div><div class="line">    <span class="built_in">NSString</span> *name = [result stringForColumn:<span class="string">@"name"</span>];</div><div class="line">    <span class="keyword">int</span> age = [result intForColumn:<span class="string">@"age"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6.线程安全<br>在多个线程中同时使用一个FMDatabase实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法：</p>
<p>创建队列<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</div></pre></td></tr></table></figure></p>
<p>使用队列<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[queue inDatabase:^(FMDatabase *database) &#123;    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_1"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]];    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_2"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>]];    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_3"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>]];      </div><div class="line">    FMResultSet *result = [database executeQuery:<span class="string">@"select * from t_person"</span>];    </div><div class="line">    <span class="keyword">while</span>([result next]) &#123;   </div><div class="line"></div><div class="line">    &#125;    </div><div class="line">&#125;];</div><div class="line"><span class="comment">//而且可以轻松地把简单任务包装到事务里：</span></div><div class="line">[queue inTransaction:^(FMDatabase *database, <span class="built_in">BOOL</span> *rollback) &#123;    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_1"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]];    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_2"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>]];    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_3"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>]];      </div><div class="line">    FMResultSet *result = [database executeQuery:<span class="string">@"select * from t_person"</span>];    </div><div class="line">    <span class="keyword">while</span>([result next]) &#123;   </div><div class="line">    &#125;   </div><div class="line">    <span class="comment">// 回滚</span></div><div class="line">    *rollback = <span class="literal">YES</span>;  </div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>FMDatabaseQueue 后台会建立系列化的G-C-D队列，并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GDC也会按它接收的块的顺序来执行。</p>
<h3 id="CoreData的基本使用"><a href="#CoreData的基本使用" class="headerlink" title="CoreData的基本使用"></a>CoreData的基本使用</h3><p>准备工作</p>
<ul>
<li>创建数据库<br>新建文件，选择CoreData -&gt; DataModel，添加实体（表）Add Entity，给表中添加属性，点击Attributes下方的‘+’号</li>
<li>创建模型文件<br>新建文件，选择CoreData -&gt; NSManaged Object subclass，根据提示，选择实体</li>
<li>通过代码，关联数据库和实体<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">/*</span></div><div class="line">    * 关联的时候，如果本地没有数据库文件，Ｃoreadata自己会创建</div><div class="line">    */</div><div class="line">    <span class="comment">// 1. 上下文</span></div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</div><div class="line">    <span class="comment">// 2. 上下文关连数据库</span></div><div class="line">    <span class="comment">// 2.1 model模型文件</span></div><div class="line">    <span class="built_in">NSManagedObjectModel</span> *model = [<span class="built_in">NSManagedObjectModel</span> mergedModelFromBundles:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 持久化存储调度器</span></div><div class="line">    <span class="comment">// 持久化，把数据保存到一个文件，而不是内存</span></div><div class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *store = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 设置CoreData数据库的名字和路径</span></div><div class="line">    <span class="built_in">NSString</span> *doc = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="built_in">NSString</span> *sqlitePath = [doc stringByAppendingPathComponent:<span class="string">@"company.sqlite"</span>];</div><div class="line">    [store addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:sqlitePath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line">    context.persistentStoreCoordinator = store;</div><div class="line">    _context = context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>CoreData的基本操作（CURD）<br>添加元素 - Create<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">IBAction</span>)addEmployee&#123;</div><div class="line">    <span class="comment">// 创建一个员工对象 </span></div><div class="line">    <span class="comment">//Employee *emp = [[Employee alloc] init]; 不能用此方法创建</span></div><div class="line">    Employee *emp = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_context];</div><div class="line">    emp.name = <span class="string">@"wangwu"</span>;</div><div class="line">    emp.height = @<span class="number">1.80</span>;</div><div class="line">    emp.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">// 直接保存数据库</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读取数据 - Read<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">IBAction</span>)readEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 1.FetchRequest 获取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.设置过滤条件</span></div><div class="line">    <span class="comment">// 查找zhangsan</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>,</div><div class="line">    <span class="string">@"zhangsan"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 3.设置排序</span></div><div class="line">    <span class="comment">// 身高的升序排序</span></div><div class="line">    <span class="built_in">NSSortDescriptor</span> *heigtSort = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"height"</span> ascending:<span class="literal">NO</span>];</div><div class="line">    request.sortDescriptors = @[heigtSort];</div><div class="line"></div><div class="line">    <span class="comment">// 4.执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//NSLog(@"%@",emps);</span></div><div class="line"></div><div class="line">    <span class="comment">//遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 身高 %@ 生日 %@"</span>,emp.name,emp.height,emp.birthday);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改数据 - Update<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">IBAction</span>)updateEmployee&#123;</div><div class="line">    <span class="comment">// 改变zhangsan的身高为2m</span></div><div class="line"></div><div class="line">    <span class="comment">// 1.查找到zhangsan</span></div><div class="line">    <span class="comment">// 1.1FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 1.2设置过滤条件</span></div><div class="line">    <span class="comment">// 查找zhangsan</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>, <span class="string">@"zhangsan"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 1.3执行请求</span></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.更新身高</span></div><div class="line">    <span class="keyword">for</span> (Employee *e <span class="keyword">in</span> emps) &#123;</div><div class="line">        e.height = @<span class="number">2.0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 3.保存</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除数据 - Delete<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">IBAction</span>)deleteEmployee&#123;</div><div class="line">    <span class="comment">// 删除 lisi</span></div><div class="line">    <span class="comment">// 1.查找lisi</span></div><div class="line">    <span class="comment">// 1.1FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 1.2设置过滤条件</span></div><div class="line">    <span class="comment">// 查找zhangsan</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>,</div><div class="line">    <span class="string">@"lisi"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 1.3执行请求</span></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.删除</span></div><div class="line">    <span class="keyword">for</span> (Employee *e <span class="keyword">in</span> emps) &#123;</div><div class="line">    [_context deleteObject:e];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 3.保存</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CoreData的表关联<br>准备工作</p>
<ul>
<li>创建数据库<br>新建文件，选择CoreData -&gt; DataModel，添加实体（表），Add Entity ， 注意：这里根据关联添加多个实体，给表中添加属性，点击Attributes下方的‘+’号</li>
<li>创建模型文件<br>新建文件，选择CoreData -&gt; NSManaged Object subclass， 根据提示，选择实体，注意：这里先选择被关联的实体，最后添加最上层的实体,  通过代码，关联数据库和实体<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">/*</span></div><div class="line">    * 关联的时候，如果本地没有数据库文件，Ｃoreadata自己会创建</div><div class="line">    */</div><div class="line">    <span class="comment">// 1. 上下文</span></div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 上下文关连数据库</span></div><div class="line"></div><div class="line">    <span class="comment">// 2.1 model模型文件</span></div><div class="line">    <span class="built_in">NSManagedObjectModel</span> *model = [<span class="built_in">NSManagedObjectModel</span> mergedModelFromBundles:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 持久化存储调度器</span></div><div class="line">    <span class="comment">// 持久化，把数据保存到一个文件，而不是内存</span></div><div class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *store = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 设置CoreData数据库的名字和路径</span></div><div class="line">    <span class="built_in">NSString</span> *doc = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="built_in">NSString</span> *sqlitePath = [doc stringByAppendingPathComponent:<span class="string">@"company.sqlite"</span>];</div><div class="line">    </div><div class="line">    [store addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:sqlitePath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line">    context.persistentStoreCoordinator = store;</div><div class="line">    _context = context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>基本操作<br>添加元素 - Create<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">IBAction</span>)addEmployee&#123;</div><div class="line">    <span class="comment">// 1. 创建两个部门 ios android</span></div><div class="line">    <span class="comment">//1.1 iOS部门</span></div><div class="line">    Department *iosDepart = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Department"</span> inManagedObjectContext:_context];</div><div class="line">    iosDepart.name = <span class="string">@"ios"</span>;</div><div class="line">    iosDepart.departNo = <span class="string">@"0001"</span>;</div><div class="line">    iosDepart.createDate = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">//1.2 Android部门</span></div><div class="line">    Department *andrDepart = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Department"</span> inManagedObjectContext:_context];</div><div class="line">    andrDepart.name = <span class="string">@"android"</span>;</div><div class="line">    andrDepart.departNo = <span class="string">@"0002"</span>;</div><div class="line">    andrDepart.createDate = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">//2. 创建两个员工对象 zhangsan属于ios部门 lisi属于android部门</span></div><div class="line">    <span class="comment">//2.1 zhangsan</span></div><div class="line">    Employee *zhangsan = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_context];</div><div class="line">    zhangsan.name = <span class="string">@"zhangsan"</span>;</div><div class="line">    zhangsan.height = @(<span class="number">1.90</span>);</div><div class="line">    zhangsan.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line">    zhangsan.depart = iosDepart;</div><div class="line"></div><div class="line">    <span class="comment">//2.2 lisi</span></div><div class="line">    Employee *lisi = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_context];</div><div class="line">    lisi.name = <span class="string">@"lisi"</span>;</div><div class="line">    lisi.height = @<span class="number">2.0</span>;</div><div class="line">    lisi.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line">    lisi.depart = andrDepart;</div><div class="line"></div><div class="line">    <span class="comment">//3. 保存数据库</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读取信息 - read<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">IBAction</span>)readEmployee&#123;</div><div class="line">    <span class="comment">// 读取ios部门的员工</span></div><div class="line">    <span class="comment">// 1.FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.设置过滤条件</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"depart.name = %@"</span>,<span class="string">@"android"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 4.执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 部门 %@"</span>,emp.name,emp.depart.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>CoreData的模糊查询<br>模糊查询<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">IBAction</span>)readEmployee&#123;</div><div class="line">    <span class="comment">// 1.FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.设置排序</span></div><div class="line">    <span class="comment">// 按照身高的升序排序</span></div><div class="line">    <span class="built_in">NSSortDescriptor</span> *heigtSort = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"height"</span> ascending:<span class="literal">NO</span>];</div><div class="line">    request.sortDescriptors = @[heigtSort];</div><div class="line"></div><div class="line">    <span class="comment">// 3.模糊查询</span></div><div class="line">    <span class="comment">// 3.1 名字以"wang"开头</span></div><div class="line">    <span class="comment">//    NSPredicate *pre = [NSPredicate predicateWithFormat:@"name BEGINSWITH %@",@"wangwu1"];</span></div><div class="line">    <span class="comment">//    request.predicate = pre;</span></div><div class="line"></div><div class="line">    <span class="comment">// 名字以"1"结尾</span></div><div class="line">    <span class="comment">//    NSPredicate *pre = [NSPredicate predicateWithFormat:@"name ENDSWITH %@",@"1"];</span></div><div class="line">    <span class="comment">//    request.predicate = pre;</span></div><div class="line"></div><div class="line">    <span class="comment">// 名字包含"wu1"</span></div><div class="line">    <span class="comment">//    NSPredicate *pre = [NSPredicate predicateWithFormat:@"name CONTAINS %@",@"wu1"];</span></div><div class="line">    <span class="comment">//    request.predicate = pre;</span></div><div class="line"></div><div class="line">    <span class="comment">// like 匹配</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name like %@"</span>,<span class="string">@"*wu12"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 4.执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 身高 %@ 生日 %@"</span>,emp.name,emp.height,emp.birthday);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分页查询<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)pageSeacher&#123;</div><div class="line">    <span class="comment">// 1. FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 设置排序</span></div><div class="line">    <span class="comment">// 身高的升序排序</span></div><div class="line">    <span class="built_in">NSSortDescriptor</span> *heigtSort = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"height"</span> ascending:<span class="literal">NO</span>];</div><div class="line">    request.sortDescriptors = @[heigtSort];</div><div class="line"></div><div class="line">    <span class="comment">// 3. 分页查询</span></div><div class="line">    <span class="comment">// 总有共有15数据</span></div><div class="line">    <span class="comment">// 每次获取6条数据</span></div><div class="line">    <span class="comment">// 第一页 0,6</span></div><div class="line">    <span class="comment">// 第二页 6,6</span></div><div class="line">    <span class="comment">// 第三页 12,6 3条数据</span></div><div class="line"></div><div class="line">    <span class="comment">// 3.1 分页的起始索引</span></div><div class="line">    request.fetchOffset = <span class="number">12</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 3.2 分页的条数</span></div><div class="line">    request.fetchLimit = <span class="number">6</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 4. 执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 5. 遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 身高 %@ 生日 %@"</span>,emp.name,emp.height,emp.birthday);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>多个数据库的使用<br>创建多个数据库，即创建多个DataModel,一个数据库对应一个上下文,需要根据bundle名创建上下文。添加或读取信息，需要根据不同的上下文，访问不同的实体。</p>
<p>关联数据库和实体<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 一个数据库对应一个上下文</span></div><div class="line">    _companyContext = [<span class="keyword">self</span> setupContextWithModelName:<span class="string">@"Company"</span>];</div><div class="line">    _weiboContext = [<span class="keyword">self</span> setupContextWithModelName:<span class="string">@"Weibo"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*  根据模型文件，返回一个上下文</div><div class="line">*/</div><div class="line">-(<span class="built_in">NSManagedObjectContext</span> *)setupContextWithModelName:(<span class="built_in">NSString</span> *)modelName&#123;</div><div class="line">    <span class="comment">// 1. 上下文</span></div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 上下文关连数据库</span></div><div class="line">    <span class="comment">// 2.1 model模型文件</span></div><div class="line"></div><div class="line">    <span class="comment">// 注意：如果使用下面的方法，如果 bundles为nil 会把bundles里面的所有模型文件的表放在一个数据库</span></div><div class="line">    <span class="comment">//NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:nil];</span></div><div class="line"></div><div class="line">    <span class="comment">// 改为以下的方法获取：</span></div><div class="line">    <span class="built_in">NSURL</span> *companyURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:modelName withExtension:<span class="string">@"momd"</span>];</div><div class="line">    <span class="built_in">NSManagedObjectModel</span> *model = [[<span class="built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:companyURL];</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 持久化存储调度器</span></div><div class="line">    <span class="comment">// 持久化，把数据保存到一个文件，而不是内存</span></div><div class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *store = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 告诉Coredata数据库的名字和路径</span></div><div class="line">    <span class="built_in">NSString</span> *doc = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="built_in">NSString</span> *sqliteName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.sqlite"</span>,modelName];</div><div class="line">    <span class="built_in">NSString</span> *sqlitePath = [doc stringByAppendingPathComponent:sqliteName];</div><div class="line"></div><div class="line">    [store addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:sqlitePath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line">    context.persistentStoreCoordinator = store;</div><div class="line"></div><div class="line">    <span class="comment">// 3. 返回上下文</span></div><div class="line">    <span class="keyword">return</span> context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加元素<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">IBAction</span>)addEmployee&#123;</div><div class="line">    <span class="comment">// 1. 添加员工</span></div><div class="line">    Employee *emp = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_companyContext];</div><div class="line">    emp.name = <span class="string">@"zhagsan"</span>;</div><div class="line">    emp.height = @<span class="number">2.3</span>;</div><div class="line">    emp.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">// 直接保存数据库</span></div><div class="line">    [_companyContext save:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 发微博</span></div><div class="line">    Status *status =[<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Status"</span> inManagedObjectContext:_weiboContext];</div><div class="line">    status.text = <span class="string">@"发了一条微博！"</span>;</div><div class="line">    status.createDate = [<span class="built_in">NSDate</span> date];</div><div class="line">    [_weiboContext save:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
  
  
</search>
