<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><title>专用图层 - CATiledLayer - zhuimar</title><link type="text/css" rel="stylesheet" href="/css/pure.css?v=0.0.1"><link type="text/css" rel="stylesheet" href="/css/style.css?v=0.0.1"><script type="text/javascript" src="//cdn.bootcss.com/jquery/1.11.0/jquery.min.js"></script></head></html><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">专用图层 - CATiledLayer</h1><a id="logo" href="/.">zhuimar</a></div><div id="nav-menu"><div class="bitcron_nav"><div class="site_nav_wrap"><div class="site_nav"><span class="a_container"><a href="/." class="selected active current">首页</a></span><span class="a_container"><a href="/archives/">归档</a></span><span class="a_container"><a href="/about/">关于</a></span><span class="a_container"><a href="/blog/">博客</a></span><span class="a_container"><a href="/music/">音乐</a></span><span class="a_container"><a href="/video/">视频</a></span><span class="a_container"><a href="/atom.xml">订阅</a></span></div></div></div></div></div><div id="layout" class="pure-g"><div class="pure-u-1"><div class="content_container"><div class="post"><h1 class="post-title">专用图层 - CATiledLayer</h1><div class="post-content"><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。<br>能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048<em>2048，或4096</em>4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU。</p>
<p>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。让我们用实验来证明一下。</p>
<h3 id="小片裁剪"><a href="#小片裁剪" class="headerlink" title="小片裁剪"></a>小片裁剪</h3><p>这个示例中，我们将会从一个2048*2048分辨率的雪人图片入手。为了能够从CATiledLayer中获益，我们需要把这个图片裁切成许多小一些的图片。你可以通过代码来完成这件事情，但是如果你在运行时读入整个图片并裁切，那CATiledLayer这些所有的性能优点就损失殆尽了。理想情况下来说，最好能够逐个步骤来实现。</p>
<p>下面代码演示了一个简单的Mac OS命令行程序，它用CATiledLayer将一个图片裁剪成小图并存储到不同的文件中。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])&#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span>&#123;</div><div class="line">        ￼<span class="comment">//handle incorrect arguments</span></div><div class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"TileCutter arguments: inputfile"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//input file</span></div><div class="line">            <span class="built_in">NSString</span> *inputFile = [<span class="built_in">NSString</span> stringWithCString:argv[<span class="number">1</span>] encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"></div><div class="line">            <span class="comment">//tile size</span></div><div class="line">            <span class="built_in">CGFloat</span> tileSize = <span class="number">256</span>; <span class="comment">//output path</span></div><div class="line">            <span class="built_in">NSString</span> *outputPath = [inputFile stringByDeletingPathExtension];</div><div class="line"></div><div class="line">            <span class="comment">//load image</span></div><div class="line">            <span class="built_in">NSImage</span> *image = [[<span class="built_in">NSImage</span> alloc] initWithContentsOfFile:inputFile];</div><div class="line">            <span class="built_in">NSSize</span> size = [image size];</div><div class="line">            <span class="built_in">NSArray</span> *representations = [image representations];</div><div class="line">            <span class="keyword">if</span> ([representations count])&#123;</div><div class="line">                <span class="built_in">NSBitmapImageRep</span> *representation = representations[<span class="number">0</span>];</div><div class="line">                size.width = [representation pixelsWide];</div><div class="line">                size.height = [representation pixelsHigh];</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSRect</span> rect = <span class="built_in">NSMakeRect</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, size.width, size.height);</div><div class="line">            <span class="built_in">CGImageRef</span> imageRef = [image <span class="built_in">CGImageForProposedRect</span>:&amp;rect context:<span class="literal">NULL</span> hints:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">            <span class="comment">//calculate rows and columns</span></div><div class="line">            <span class="built_in">NSInteger</span> rows = ceil(size.height / tileSize);</div><div class="line">            <span class="built_in">NSInteger</span> cols = ceil(size.width / tileSize);</div><div class="line"></div><div class="line">            <span class="comment">//generate tiles</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; rows; ++y) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; cols; ++x) &#123;</div><div class="line">                <span class="comment">//extract tile image</span></div><div class="line">                <span class="built_in">CGRect</span> tileRect = <span class="built_in">CGRectMake</span>(x*tileSize, y*tileSize, tileSize, tileSize);</div><div class="line">                <span class="built_in">CGImageRef</span> tileImage = <span class="built_in">CGImageCreateWithImageInRect</span>(imageRef, tileRect);</div><div class="line"></div><div class="line">                <span class="comment">//convert to jpeg data</span></div><div class="line">                <span class="built_in">NSBitmapImageRep</span> *imageRep = [[<span class="built_in">NSBitmapImageRep</span> alloc] initWithCGImage:tileImage];</div><div class="line">                <span class="built_in">NSData</span> *data = [imageRep representationUsingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];</div><div class="line">                <span class="built_in">CGImageRelease</span>(tileImage);</div><div class="line"></div><div class="line">                <span class="comment">//save file</span></div><div class="line">                <span class="built_in">NSString</span> *path = [outputPath stringByAppendingFormat: <span class="string">@"_%02i_%02i.jpg"</span>, x, y];</div><div class="line">                [data writeToFile:path atomically:<span class="literal">NO</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个程序将2048<em>2048分辨率的图片裁剪成了64个不同的256</em>256的小图。（256*256是CATiledLayer的默认小图大小，默认大小可以通过tileSize属性更改）。程序接受一个图片路径作为命令行的第一个参数。我们可以在编译的scheme将路径参数硬编码然后就可以在Xcode中运行了，但是以后作用在另一个图片上就不方便了。所以，我们编译了这个程序并把它保存到敏感的地方，然后从终端调用，如下面所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; path/to/TileCutterApp path/to/Snowman.jpg</div></pre></td></tr></table></figure>
<font color="##DC143C" size="3">The app is very basic, but could easily be extended to support additional arguments such as tile size, or to export images in formats other than JPEG. The result of running it is a sequence of 64 new images, named as follows:</font>

<p>这个程序相当基础，但是能够轻易地扩展支持额外的参数比如小图大小，或者导出格式等等。运行结果是64个新图的序列，如下面命名:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Snowman_00_00.jpg</div><div class="line">Snowman_00_01.jpg</div><div class="line">Snowman_00_02.jpg</div><div class="line">...</div><div class="line">Snowman_07_07.jpg</div></pre></td></tr></table></figure></p>
<p>既然我们有了裁切后的小图，我们就要让iOS程序用到他们。CATiledLayer很好地和UIScrollView集成在一起。除了设置图层和滑动视图边界以适配整个图片大小，我们真正要做的就是实现-drawLayer:inContext:方法，当需要载入新的小图时，CATiledLayer就会调用到这个方法。</p>
<p>一个简单的滚动CATiledLayer实现。代码如下<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIScrollView</span> *scrollView;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">//add the tiled layer</span></div><div class="line">    <span class="built_in">CATiledLayer</span> *tileLayer = [<span class="built_in">CATiledLayer</span> layer];￼</div><div class="line">    tileLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2048</span>, <span class="number">2048</span>);</div><div class="line">    tileLayer.delegate = <span class="keyword">self</span>; [<span class="keyword">self</span>.scrollView.layer addSublayer:tileLayer];</div><div class="line"></div><div class="line">    <span class="comment">//configure the scroll view</span></div><div class="line">    <span class="keyword">self</span>.scrollView.contentSize = tileLayer.frame.size;</div><div class="line"></div><div class="line">    <span class="comment">//draw layer</span></div><div class="line">    [tileLayer setNeedsDisplay];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CATiledLayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</div><div class="line">    <span class="comment">//determine tile coordinate</span></div><div class="line">    <span class="built_in">CGRect</span> bounds = <span class="built_in">CGContextGetClipBoundingBox</span>(ctx);</div><div class="line">    <span class="built_in">NSInteger</span> x = floor(bounds.origin.x / layer.tileSize.width);</div><div class="line">    <span class="built_in">NSInteger</span> y = floor(bounds.origin.y / layer.tileSize.height);</div><div class="line"></div><div class="line">    <span class="comment">//load tile image</span></div><div class="line">    <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat: <span class="string">@"Snowman_%02i_%02i"</span>, x, y];</div><div class="line">    <span class="built_in">NSString</span> *imagePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:imageName ofType:<span class="string">@"jpg"</span>];</div><div class="line">    <span class="built_in">UIImage</span> *tileImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:imagePath];</div><div class="line"></div><div class="line">    <span class="comment">//draw tile</span></div><div class="line">    <span class="built_in">UIGraphicsPushContext</span>(ctx);</div><div class="line">    [tileImage drawInRect:bounds];</div><div class="line">    <span class="built_in">UIGraphicsPopContext</span>();</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>当你滑动这个图片，你会发现当CATiledLayer载入小图的时候，他们会淡入到界面中。这是CATiledLayer的默认行为。（你可能已经在iOS 6之前的苹果地图程序中见过这个效果）你可以用fadeDuration属性改变淡入时长或直接禁用掉。CATiledLayer（不同于大部分的UIKit和Core Animation方法）支持多线程绘制，-drawLayer:inContext:方法可以在多个线程中同时地并发调用，所以请小心谨慎地确保你在这个方法中实现的绘制代码是线程安全的。</p>
<h3 id="Retina小图"><a href="#Retina小图" class="headerlink" title="Retina小图"></a>Retina小图</h3><p>你也许已经注意到了这些小图并不是以Retina的分辨率显示的。为了以屏幕的原生分辨率来渲染CATiledLayer，我们需要设置图层的contentsScale来匹配UIScreen的scale属性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tileLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div></pre></td></tr></table></figure></p>
<p>有趣的是，tileSize是以像素为单位，而不是点，所以增大了contentsScale就自动有了默认的小图尺寸（现在它是128<em>128的点而不是256</em>256）.所以，我们不需要手工更新小图的尺寸或是在Retina分辨率下指定一个不同的小图。我们需要做的是适应小图渲染代码以对应安排scale的变化，然而：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//determine tile coordinate</span></div><div class="line"><span class="built_in">CGRect</span> bounds = <span class="built_in">CGContextGetClipBoundingBox</span>(ctx);</div><div class="line"><span class="built_in">CGFloat</span> scale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line"><span class="built_in">NSInteger</span> x = floor(bounds.origin.x / layer.tileSize.width * scale);</div><div class="line"><span class="built_in">NSInteger</span> y = floor(bounds.origin.y / layer.tileSize.height * scale);</div></pre></td></tr></table></figure></p>
<p>通过这个方法纠正scale也意味着我们的雪人图将以一半的大小渲染在Retina设备上（总尺寸是1024<em>1024，而不是2048</em>2048）。这个通常都不会影响到用CATiledLayer正常显示的图片类型（比如照片和地图，他们在设计上就是要支持放大缩小，能够在不同的缩放条件下显示），但是也需要在心里明白。</p>
</div></div><div id="disqus_thread"><script>var disqus_shortname = 'zhuimar';
var disqus_identifier = '2014/11/29/2014/专用图层 - CATiledLayer/';
var disqus_title = '专用图层 - CATiledLayer';
var disqus_url = 'http://yoursite.com/2014/11/29/2014/专用图层 - CATiledLayer/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><!--script(id='dsq-count-scr', src='//#{theme.disqus}.disqus.com/count.js', async)--></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">zhuimar.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> Theme<a target="_blank" href="https://github.com/7ye/maupassant-hexo"> Maupassant.</a></div><a id="back_to_top" href="javascript:void(0)" class="back_to_top"><span>△</span></a><script type="text/javascript" src="/js/totop.js?v=0.0.1"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>function auto_code_fit(){
  if($(".highlight").length != 0){
    var pc_width = $(".post-content").width();
    $(".highlight .code").find("pre").width((pc_width-70)+"px");
  }
}
window.onresize = function(){
  auto_code_fit();
}
auto_code_fit();</script></div></body>