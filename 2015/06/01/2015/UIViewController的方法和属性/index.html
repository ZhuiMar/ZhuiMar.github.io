<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>UIViewController的生命周期和属性 | 追马</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">UIViewController的生命周期和属性</h1><a id="logo" href="/.">追马</a><p class="description">心有猛虎 细嗅蔷薇</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">UIViewController的生命周期和属性</h1><div class="post-meta">Jun 1, 2015<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h4 id="一、UIViewController的生命周期和属性"><a href="#一、UIViewController的生命周期和属性" class="headerlink" title="一、UIViewController的生命周期和属性"></a>一、UIViewController的生命周期和属性</h4><p> 要了解UIViewController，先要弄清楚其生命周期。在面向对象的语言中，是对象，就一定要有生命周期，UIViewController也不例外，生命周期管理Controller的作用范围和时间，也管理其内对象的作用范围和时间。首先，UIViewController中与其生命周期有关的几个函数如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类的初始化方法  </span></div><div class="line">+ (<span class="keyword">void</span>)initialize;  </div><div class="line"><span class="comment">//对象初始化方法  </span></div><div class="line">- (<span class="keyword">instancetype</span>)init;  </div><div class="line"><span class="comment">//从归档初始化  </span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)coder;  </div><div class="line"><span class="comment">//加载视图  </span></div><div class="line">-(<span class="keyword">void</span>)loadView;  </div><div class="line"><span class="comment">//将要加载视图  </span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad;  </div><div class="line"><span class="comment">//将要布局子视图  </span></div><div class="line">-(<span class="keyword">void</span>)viewWillLayoutSubviews;  </div><div class="line"><span class="comment">//已经布局子视图  </span></div><div class="line">-(<span class="keyword">void</span>)viewDidLayoutSubviews;  </div><div class="line"><span class="comment">//内存警告  </span></div><div class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning;  </div><div class="line"><span class="comment">//已经展示  </span></div><div class="line">-(<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//将要展示  </span></div><div class="line">-(<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//将要消失  </span></div><div class="line">-(<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//已经消失  </span></div><div class="line">-(<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated;  </div><div class="line"><span class="comment">//被释放  </span></div><div class="line">-(<span class="keyword">void</span>)dealloc;</div></pre></td></tr></table></figure></p>
<p>上面这么多的函数，乍一看什么复杂，其实关系什么明朗，除了initialize,init和initWithCoder不是存在所有对象的声明周期中，其他函数都会在UIViewController的声明周期中有序的被调用。那么具体的调用顺序是怎样的呢，最好的办法是实践一下，通过编号打印，结果如下：<br>这是一个ViewController完整的声明周期，其实里面还有好多地方需要我们注意一下：</p>
<p>1：initialize函数并不会每次创建对象都调用，只有在这个类第一次创建对象时才会调用，做一些类的准备工作，再次创建这个类的对象，initalize方法将不会被调用，对于这个类的子类，如果实现了initialize方法，在这个子类第一次创建对象时会调用自己的initalize方法，之后不会调用，如果没有实现，那么它的父类将替它再次调用一下自己的initialize方法，以后创建也都不会再调用。因此，如果我们有一些和这个相关的全局变量，可以在这里进行初始化。<br>2：init方法和initCoder方法相似，只是被调用的环境不一样，如果用代码进行初始化，会调用init，从nib文件或者归档进行初始化，会调用initCoder。<br>3：loadView方法是开始加载视图的起始方法，除非手动调用，否则在ViewController的生命周期中没特殊情况只会被调用一次。<br>4：viewDidLoad方法是我们最常用的方法的，类中成员对象和变量的初始化我们都会放在这个方法中，在类创建后，无论视图的展现或消失，这个方法也是只会在将要布局时调用一次。<br>5：viewWillAppare：视图将要展现时会调用。<br>6：viewWillLayoutSubviews：在viewWillAppare后调用，将要对子视图进行布局。<br>7：viewDidLayoutSubviews：已经布局完成子视图。<br>8：viewDidAppare：视图完成显示时调用。<br>9：viewWillDisappare：视图将要消失时调用。<br>10：viewDidDisappare：视图已经消失时调用。<br>11：dealloc：controller被释放时调用。</p>
<p>注意：经过测试，从nib文件加载的controller，只要不释放，在每次viewWillAppare时都会调用layoutSubviews方法，有时甚至会在viewDidAppare后在调用一次layoutSubviews，而重点是从代码加载的则只会在开始调用一次，之后都不会，所以注意，在layoutSubviews中写相关的布局代码十分危险。</p>
<h4 id="二、从storyBoard加载UIViewController实例的传值陷阱"><a href="#二、从storyBoard加载UIViewController实例的传值陷阱" class="headerlink" title="二、从storyBoard加载UIViewController实例的传值陷阱"></a>二、从storyBoard加载UIViewController实例的传值陷阱</h4><p>我们知道，当我们从StoryBoard中加载ViewController时，我们在Controller中拖拽的视图是可以被初始化的，这里面有一点需要我们注意，如果我们需要向controller中视图进行传值设置，通过以下方法得到的Controller中，视图还没有被初始化创建出来：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ViewController2 * viewController2 = [[<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:[<span class="built_in">NSBundle</span> mainBundle]] instantiateViewControllerWithIdentifier:<span class="string">@"ViewController2"</span>];</div></pre></td></tr></table></figure></p>
<p>我们可以在ViewController2的storyBoard中拉一个label，然后关联到头文件中，如下打印，会发现我们得到controller时，里面的视图对象并没有进行创建:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ViewController2 * viewController2 = [[<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Main"</span> bundle:[<span class="built_in">NSBundle</span> mainBundle]] instantiateViewControllerWithIdentifier:<span class="string">@"ViewController2"</span>];  </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,viewController2.label);  </div><div class="line">[<span class="keyword">self</span> presentViewController:viewController2 animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></p>
<p>可以想象，如果我们这时候需要对label进行一些属性设置，必然失败。有人提出可以在创建后，手动调以下loadView方法，我们试一下，结果如下：<br>可以看到，手动调用loadView后，label是被创建了出来，但是暴漏了一个更严重的问题，系统不在调用ViewDidLoad方法，这是十分有风险的，因为我们大部分的初始化代码都会放在这个方法里，所以手动调用loadView是一种错误的方法，apple文档声明对于loadView方法，我们从来都不要手动直接调用，那么我们如何实现创建后对成员对象进行传值设置呢，iOS9中增加了这样一个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadViewIfNeeded <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</div></pre></td></tr></table></figure></p>
<p>这个方法十分有用，调用这个方法，会将视图创建出来，并且不会忽略viewDidLoad的调用。<br>在iOS9中，UIViewController还增加了下面一个布尔值的属性，可以同来判断controller的view是否已经加载完成<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *viewIfLoaded <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</div></pre></td></tr></table></figure></p>
<h4 id="三、UIViewController与StroyBoard的相关相互方法"><a href="#三、UIViewController与StroyBoard的相关相互方法" class="headerlink" title="三、UIViewController与StroyBoard的相关相互方法"></a>三、UIViewController与StroyBoard的相关相互方法</h4><p>对于ViewConroller，我们一般有两种方式创建，一种是用纯代码的方式，一种是与StoryBoard关联，在UIViewController中，有许多方法方便我们与StoryBoard进行交互联系。</p>
<ul>
<li>ViewController直接在StoryBoard中进行跳转的传值<br>在StoryBoard中进行界面跳转是十分方便的，我们在StoryBoard中拉入两个ViewController，在一个上面添加一个按钮，点住按钮按住control，将鼠标拉到第二个controller上，会出现如下的跳转选项：<br>我们选择一个后，就会在两个controller之间建立一个跳转连接。当我们运行点击按钮后，会自动从第一个controller跳转到第二个controller。在UIViewController中有如下方法可以对是否跳转进行控制：<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)shouldPerformSegueWithIdentifier:(<span class="built_in">NSString</span> *)identifier sender:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">6</span>_0);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这个方法如果返回NO，自动跳转将不能进行，会被拒绝，需要注意的是，这个方法只会在自动的跳转时被调用，我们手动使用代码跳转StoryBoard中的连接关系时是不会被调用的，我们后面讨论。<br>在执行过上述方法后，如果返回YES，系统还会在执行如下一个方法，作为跳转前的准备，我们可以在这个方法中进行一些传值操作，这个方法无论使我们手动进行跳转还是storyboard中自动跳转，都会被执行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">nullable</span> <span class="keyword">id</span>)sender <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure></p>
<p>sugur对象中封装了相关的ViewController，可以使用segue.destinationViewController获取。<br>segue在StoryBoard中除了用来自动正向跳转外，我们还可以进行反向的跳转，类似pop和dismiss方法，这种segue被称为unwind sugue。例如，我们有一个controller1和一个controllert2，要使用unwind segue从2返回1，我们需要在2中实现如下格式的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)unwindSegueToViewController:(<span class="built_in">UIStoryboardSegue</span> *)segue &#123;  </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"unwindSegueToViewController"</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法中的返回值必须为IBAction，参数必须是UIStoryboardSegue，方法名我们可以自己定义，之后在StoryBoard中的ViewController1中的Exit选项中，我们会发现多了一个这样的方法：<br>这样，当我们点击viewController2中的按钮时，就会返回到我们第一个ViewController1中了。<br>当然，在使用unwind segue方法时，也是会有一些回调帮助我们进行跳转前的设置和传值，UIViewController如下方法会在跳转前调用，返回NO，则不能进行跳转：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)canPerformUnwindSegueAction:(SEL)action fromViewController:(<span class="built_in">UIViewController</span> *)fromViewController withSender:(<span class="keyword">id</span>)sender&#123;  </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"canPerformUnwindSegueAction"</span>);  </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后会执行我们自定义的unwindSegue方法，这个方法中我们可以什么都不写，模式是会进行跳转的。</p>
<ul>
<li>使用代码跳转Storyboard中的controller<br>我们除了在Storyboard中拉拉扯扯可以进行控制器的跳转外，我们也可以使用代码来跳转Storyboard中segue连接关系。<br>在Storyboard中两个控制器间建立一个segue联系，我们可以取一个名字：在触发跳转的方法中，使用如下方法进行跳转，这里面的参数id就是我们取得segue的id：</li>
</ul>
<ul>
<li>(void)performSegueWithIdentifier:(NSString <em>)identifier sender:(nullable id)sender NS_AVAILABLE_IOS(5_0);<br>下面三个属性我们可以获取controller的nib文件名，其storyBoard和其Bundle:<br>@property(nullable, nonatomic, readonly, copy) NSString </em>nibName;<br>@property(nullable, nonatomic, readonly, strong) NSBundle <em>nibBundle;<br>@property(nullable, nonatomic, readonly, strong) UIStoryboard </em>storyboard NS_AVAILABLE_IOS(5_0);<h4 id="UIViewController之间的一些从属关系"><a href="#UIViewController之间的一些从属关系" class="headerlink" title="UIViewController之间的一些从属关系"></a>UIViewController之间的一些从属关系</h4>这部分的内容和方法可能我们接触用到的并不多，但是在某些情况下，使用这些方法可以大大的方便某些逻辑。</li>
</ul>
<ul>
<li><p>parentViewController<br>UIViewController里面封装了一个数组，可以存放其子ViewController，系统中使用的例子就是导航和tabBar这类的控制器，我们使用如下方法可以直接访问这些父的controller：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>,<span class="keyword">readonly</span>) <span class="built_in">UIViewController</span> *parentViewController;</div></pre></td></tr></table></figure>
</li>
<li><p>模态跳转中Controller的从属<br>在我们进行控制器的跳转时，只要控制器没有被释放，我们都可以顺藤摸瓜的找到它，使用如下两个方法：<br>//其所present的contller，比如，A和B两个controller，A跳转到B，那么A的presentedViewController就是B<br>@property(nullable, nonatomic,readonly) UIViewController <em>presentedViewController  NS_AVAILABLE_IOS(5_0);<br>//和上面的方法刚好相反，比如，A和B两个controller，A跳转到B，那么B的presentingViewController就是A<br>@property(nullable, nonatomic,readonly) UIViewController </em>presentingViewController NS_AVAILABLE_IOS(5_0);<br>了解了上面方法我们可以知道，对于反向传值这样的问题，我们根本不需要代理，block，通知等这样的复杂手段，只需要获取跳转到它的Controller，直接设置即可。举个例子，我们需要在第二个界面消失后，改变第一个界面的颜色，在第二个controller中只需要下面的代码即可实现 ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.presentingViewController.view.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:arc4random()%<span class="number">255</span>/<span class="number">255.0</span> green:arc4random()%<span class="number">255</span>/<span class="number">255.0</span> blue:arc4random()%<span class="number">255</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];  </div><div class="line">[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>UIViewController的模态跳转及动画特效<br>单纯的UIViewController中，我们使用最多的是如下的两个方法，一个向前跳转，一个向后返回:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)presentViewController:(<span class="built_in">UIViewController</span> *)viewControllerToPresent animated: (<span class="built_in">BOOL</span>)flag completion:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="keyword">void</span>))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);  </div><div class="line">- (<span class="keyword">void</span>)dismissViewControllerAnimated: (<span class="built_in">BOOL</span>)flag completion: (<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="keyword">void</span>))completion <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">5</span>_0);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从方法中，我们可以看到，有animated这个参数，来选择是否有动画特效，默认的动画特效是像抽屉一样从手机屏幕的下方向上弹起，当然，这个效果我们可以进行设置，UIViewController有如下一个属性来设置动画特效：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">UIModalTransitionStyle</span> modalTransitionStyle <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0);</div></pre></td></tr></table></figure></p>
<p>注意，这个要设置的是将要跳转到的controller，枚举如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIModalTransitionStyle</span>) &#123;  </div><div class="line">    <span class="built_in">UIModalTransitionStyleCoverVertical</span> = <span class="number">0</span>,<span class="comment">// 默认的，从下向上覆盖  </span></div><div class="line">    <span class="built_in">UIModalTransitionStyleFlipHorizontal</span> ,  <span class="comment">// 水平翻转  </span></div><div class="line">    <span class="built_in">UIModalTransitionStyleCrossDissolve</span>,    <span class="comment">// 溶解  </span></div><div class="line">    <span class="built_in">UIModalTransitionStylePartialCurl</span> ,     <span class="comment">// 从下向上翻页  </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>除了跳转的效果，还有一个属性可以设置弹出的controler的填充效果，但是这个属性只在pad上有效，在iphone上无效，都是填充到整个屏幕：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">UIModalPresentationStyle</span> modalPresentationStyle <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_2);  </div><div class="line"><span class="comment">// 枚举如下  </span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIModalPresentationStyle</span>) &#123;  </div><div class="line">    <span class="built_in">UIModalPresentationFullScreen</span> = <span class="number">0</span>,                   <span class="comment">// 填充整个屏幕  </span></div><div class="line">    <span class="built_in">UIModalPresentationPageSheet</span>,                        <span class="comment">// 留下状态栏  </span></div><div class="line">    <span class="built_in">UIModalPresentationFormSheet</span>,                        <span class="comment">// 四周留下变暗的空白  </span></div><div class="line">    <span class="built_in">UIModalPresentationCurrentContext</span>,                   <span class="comment">// 和跳转到它的控制器保持一致  </span></div><div class="line">    <span class="built_in">UIModalPresentationCustom</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0),<span class="comment">// 自定义  </span></div><div class="line">    <span class="built_in">UIModalPresentationOverFullScreen</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),  </div><div class="line">    <span class="built_in">UIModalPresentationOverCurrentContext</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),  </div><div class="line">    <span class="built_in">UIModalPresentationPopover</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0) __TVOS_PROHIBITED,  </div><div class="line">    <span class="built_in">UIModalPresentationNone</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0) = <span class="number">-1</span>,           </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2015/06/01/2015/UIViewController的方法和属性/" data-id="cj7mm1pud0004hlwlkusm5dcb" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2015/08/03/2015/NSString为什么用copy修饰/" class="pre">copy修饰NSString的原因</a><a href="/2015/05/21/2015/住房/" class="next">租房网站备注</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Ios/">Ios</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/20/2017/音乐锁屏键的处理/">音乐锁屏键的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/11/2017/Runtime/">Ios运行时Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/10/2017/IOS开发的知名大牛博客/">IOS开发的知名大牛博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/05/2017/IosQuestions - 3/">IosQuestions - 3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/04/2017/IosQuestions - 2/">IosQuestions - 2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/03/2017/IosQuestions - 1/">IosQuestions - 1</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/17/2016/网络库的详解/">Ios网络库AFNetworking详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/30/2016/图片缓存的优化/">Ios图片缓存的优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/13/2016/Ios的储存方案/">Ios常见的储存方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/25/2016/Ios精度/">Ios高精度NSDecimalNumber</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/leixiaohua1020" title="雷霄骅" target="_blank">雷霄骅</a><ul></ul><a href="http://blog.devtang.com/" title="唐巧" target="_blank">唐巧</a><ul></ul><a href="http://casatwy.com" title="田伟宇" target="_blank">田伟宇</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">追马.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>