<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><title>zhuimar</title><link type="text/css" rel="stylesheet" href="/css/pure.css?v=0.0.1"><link type="text/css" rel="stylesheet" href="/css/style.css?v=0.0.1"><script type="text/javascript" src="//cdn.bootcss.com/jquery/1.11.0/jquery.min.js"></script></head></html><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">zhuimar</h1><a id="logo" href="/.">zhuimar</a></div><div id="nav-menu"><div class="bitcron_nav"><div class="site_nav_wrap"><div class="site_nav"><span class="a_container"><a href="/." class="selected active current">首页</a></span><span class="a_container"><a href="/archives/">归档</a></span><span class="a_container"><a href="/about/">关于</a></span><span class="a_container"><a href="/blog/">博客</a></span><span class="a_container"><a href="/music/">音乐</a></span><span class="a_container"><a href="/video/">视频</a></span><span class="a_container"><a href="/atom.xml">订阅</a></span></div></div></div></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/2014/05/13/2014/ iOS关键字const、static、extern/">iOS关键字const、static、extern</a></h2><div class="post-meta">2014-05-13</div><div class="post-content"><p>const与宏的区别<br>1.const简`:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。<br>2.编译时刻:宏是预编译（编译之前处理），const是编译阶段。<br>3.编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。<br>4.宏的好处:宏能定义一些函数，方法。 const不能。<br>5.宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。<br>注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常见的常量：抽成宏</span></div><div class="line"><span class="meta">#define XMGAccount @<span class="meta-string">"account"</span></span></div><div class="line"><span class="meta">#define XMGUserDefault [NSUserDefaults standardUserDefaults]</span></div><div class="line"><span class="comment">// 字符串常量</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> account = <span class="string">@"account"</span>;</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 偏好设置存储</span></div><div class="line">    <span class="comment">// 使用宏</span></div><div class="line">    [XMGUserDefault setValue:<span class="string">@"123"</span> forKey:XMGAccount];</div><div class="line">    <span class="comment">// 使用const常量</span></div><div class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setValue:<span class="string">@"123"</span> forKey:account];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></div></div><div class="post"><h2 class="post-title"><a href="/2014/04/21/2014/iOS音乐锁屏键的处理/">iOS音乐锁屏键的处理</a></h2><div class="post-meta">2014-04-21</div><div class="post-content"><h3 id="完整的思路"><a href="#完整的思路" class="headerlink" title="完整的思路"></a>完整的思路</h3><p> 1.App如果需要在锁屏界面上显示相关的信息和按钮, 必须先开启远程控制事件(Remote Control Event), 否则锁屏界面只显示滑动解锁.<br> 2.实现锁屏界面信息, 将歌曲的相关信息更新到锁屏界面上<br> 3.实现锁屏界面的事件处理, 在锁屏界面和上拉的快速功能菜单中实现播放控制</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/04/14/2014/ iOS网络库AFNetworking/">iOS网络库AFNetworking</a></h2><div class="post-meta">2014-04-14</div><div class="post-content"><h3 id="为什么要用AFNetworking"><a href="#为什么要用AFNetworking" class="headerlink" title="为什么要用AFNetworking"></a>为什么要用AFNetworking</h3><p>为什么要用AFNetworking  在ios开发中，一般情况下，简单的向某个web站点简单的页面提交请求并获取服务器的响应，用xcode自带的NSURLConnection是能胜任的。但是，在绝大部分下我们所需要访问的web页面则是属于那种受到权限保护的页面，并不是有一个简单的URL可以访问的。这就涉及到了Session和Cookie的处理了，在此时使用NSURLConnection也是能够达到要求的，只是其中处理起来的复杂度和难度就提升了。  为了更好的处理向Web站点的请求，包括处理Session，Cookie等细节问题，使用AFNetworking则是更好的选择，他可以用于发送HTTP请求，接收HTTP的响应，但是不会缓存服务器的响应，不能执行HTML页面中的JAvascript代码,同时，AFNetworking还内置支持JSON，plist文件和XML文件的解析，使用比较方便。 </p></div></div><div class="post"><h2 class="post-title"><a href="/2014/04/08/2014/iOS图片缓存的优化/">iOS图片缓存的优化</a></h2><div class="post-meta">2014-04-08</div><div class="post-content"><h3 id="图片缓存的优化"><a href="#图片缓存的优化" class="headerlink" title="图片缓存的优化"></a>图片缓存的优化</h3><p>从图片入手<br>内存占用大原因是图片太大，所以想到对图片进行压缩。找了好多压缩工具，最后发现一款比较好用的，名字是ppDuck（pp鸭），这里是<a href="http://ppduck.com/" target="_blank" rel="external">下载地址</a>,图片压缩后，内存确实是暂用较少了，但还没有根本结局。从加载图片的方式考虑 ,正确选择图片加载方式能够对内存优化起到很大的作用，常见的图片加载方式有下面三种。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法1  </span></div><div class="line"><span class="built_in">UIImage</span> *imag1 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>];  </div><div class="line"><span class="comment">//方法2  </span></div><div class="line"><span class="built_in">UIImage</span> *image2 = [<span class="built_in">UIImage</span> imageWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image@2x"</span> ofType:.png]];  </div><div class="line"><span class="comment">//方法3  </span></div><div class="line"><span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image@2x"</span> ofType:png]];  </div><div class="line"><span class="built_in">UIImage</span> *image3 = [<span class="built_in">UIImage</span> imageWithData:imageData]；</div></pre></td></tr></table></figure></p></div></div><div class="post"><h2 class="post-title"><a href="/2014/04/04/2014/苹果的内存管理/">苹果的内存管理</a></h2><div class="post-meta">2014-04-04</div><div class="post-content"><h3 id="苹果是如何“收垃圾”的"><a href="#苹果是如何“收垃圾”的" class="headerlink" title="苹果是如何“收垃圾”的?"></a>苹果是如何“收垃圾”的?</h3><p>不管搭载的iOS还是Android，设备的运行内存都是有限的。在你开了一大堆应用程序，快要把内存占满的时候，为了维持正常运行，iOS和Android都会Kill掉一些后台进程，这个行为也称为“垃圾回收机制”。但需要注意的是，iOS和Android“收垃圾”的方式不甚相同。iOS会依次把最老的应用直接关闭掉，所以时候在切换到很老的后台App时会发现，它们都会从标题界面重新启动。相比之下，Android的胆子则要小得多，它不会直接关掉App，而是筛选出其中的一些无用对象，率先把它们Kill掉，从而释放部分内存。但只要你不手动关，这些后台程序都不会自动消失。因此，苹果设备就算只有1GB运行内存，你正在用的App也绝对不会卡，而Android后台程序不会自动被关闭，需要提供更多的内存(2GB、3GB甚至更多)才能保证系统流畅运行。内存需求小不是苹果牛掰的意思，虽然1GB用着也很舒坦，但说“苹果优化好”似乎不太准确，因为iOS和Android的垃圾处理方法并不是一个高端、一个土鳖，而是各有利弊。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/03/20/2014/iOS静态库的制作/">iOS静态库的制作</a></h2><div class="post-meta">2014-03-20</div><div class="post-content"><h3 id="一、什么是库？"><a href="#一、什么是库？" class="headerlink" title="一、什么是库？"></a>一、什么是库？</h3><p>库是共享程序代码的方式，一般分为静态库和动态库。<br><code>静态库</code>：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。<br><code>动态库</code>：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/03/13/2014/iOS静态库的制作ARM细节/">iOS静态库的制作ARM细节</a></h2><div class="post-meta">2014-03-13</div><div class="post-content"><h3 id="一、概要"><a href="#一、概要" class="headerlink" title="一、概要"></a>一、概要</h3><p>平时项目开发中，可能使用第三方提供的静态库.a，如果.a提供方技术不成熟，使用的时候就会出现问题，例如：<br>在真机上编译报错：<code>No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=i386).</code><br>在模拟器上编译报错：<code>No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 armv6).</code><br>要解决以上问题，就要了解一下Apple移动设备处理器指令集相关的一些细节知识。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/03/10/2014/ iOS常见的储存方案/">iOS常见的储存方案</a></h2><div class="post-meta">2014-03-10</div><div class="post-content"><p>概念问题<br>首先要明确区分两个概念，数据结构和储存方式。所谓数据结构就是数据存在的形式。除了基本的<code>NSDictionary</code>、<code>NSArray</code>和<code>NSSet</code>这些对象，还有更复杂的如：关系模型、对象图和属性列表多种结构。而存储方式则简单的分为两种：内存与闪存。内存存储是临时的，运行时有效的，但效率高，而闪存则是一种持久化存储，但产生I/O消耗，效率相对低。把内存数据转移到闪存中进行持久化的操作称成为归档。二者结合起来才是完整的数据存储方案，我们最常谈起的那些：SQLite、CoreData、NSUserDefaults等都是数据存储方案。当然在这些框架提供的方案之外，我们自己也可以按照个性化需求订制方案。这些存储方案侧重不同，支持的形式和方式也各不相同，在不同的使用场景下表现也是各有优劣。但万变不离其宗。</p></div></div><div class="paginator pager pagination"><div class="paginator_container pagination_container"><a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" id="search" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"> 分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端开发/">前端开发</a><span class="category-list-count">36</span></li></ul></div><div class="widget"><div class="widget-title"> 标签</div><div class="tagcloud"><a href="/tags/iOS/" style="font-size: 12px;">iOS</a></div></div><div class="widget"><div class="widget-title"> 最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2014/12/08/2014/组透明/">组透明</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/07/2014/专用图层 - CATransformLayer/">专用图层 - CATransformLayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/29/2014/专用图层 - CATiledLayer/">专用图层 - CATiledLayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/23/2014/专用图层 - CATextLayer/">专用图层 - CATextLayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/21/2014/专用图层 - CAShapeLayer/">专用图层 - CAShapeLayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/11/05/2014/专用图层 - CAScrollLayer/">专用图层 - CAScrollLayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/19/2014/专用图层 - CAEAGLLayer/">专用图层 - CAEAGLLayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/19/2014/专用图层 - CAEmitterLayer/">专用图层 - CAEmitterLayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/14/2014/专用图层 - AVPlayerLayer/">专用图层 - AVPlayerLayer</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/08/2014/专用图层  - CAShapeLayer/">专用图层 - CAShapeLayer</a></li></ul></div><div class="widget"><div class="widget-title"> 友情链接</div><ul class="links-list"><li class="links-list-item"><a href="http://blog.csdn.net/leixiaohua1020" title="雷霄骅" target="_blank">雷霄骅</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="http://blog.devtang.com/" title="唐巧" target="_blank">唐巧</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="http://casatwy.com" title="田伟宇" target="_blank">田伟宇</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="http://sevennight.cc" title="sevennight" target="_blank">sevennight</a></li></ul><ul class="links-list"><li class="links-list-item"><a href="https://mrlichangming.github.io" title="小明" target="_blank">小明</a></li></ul></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">zhuimar.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> Theme<a target="_blank" href="https://github.com/7ye/maupassant-hexo"> Maupassant.</a></div><a id="back_to_top" href="javascript:void(0)" class="back_to_top"><span>△</span></a><script type="text/javascript" src="/js/totop.js?v=0.0.1"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1"></script><script>function auto_code_fit(){
  if($(".highlight").length != 0){
    var pc_width = $(".post-content").width();
    $(".highlight .code").find("pre").width((pc_width-70)+"px");
  }
}
window.onresize = function(){
  auto_code_fit();
}
auto_code_fit();</script></div></body>