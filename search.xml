<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[英文面试]]></title>
      <url>http://yoursite.com/2017/08/15/%E8%8B%B1%E6%96%87%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>1.Difference between shallow copy and deep copy?<br>浅复制和深复制的区别？</p>
<p>答案：浅层复制：只复制指向对象的指针，而不复制引用对象本身。<br>深层复制：复制引用对象本身。<br>意思就是说我有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源<br>还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了<br>两份独立对象本身。<br>用网上一哥们通俗的话将就是：<br>浅复制好比你和你的影子，你完蛋，你的影子也完蛋<br>深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。</p>
<p>2.What is advantage of categories? What is difference between implementing a category and inheritance?<br>类别的作用？继承和类别在实现中有何区别？<br>答案：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。<br>并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。</p>
<p>类别主要有3个作用：</p>
<p>(1)将类的实现分散到多个不同文件或多个不同框架中。</p>
<p>(2)创建对私有方法的前向引用。</p>
<p>(3)向对象添加非正式协议。</p>
<p>继承可以增加，修改方法，并且可以增加属性。</p>
<p>3.Difference between categories and extensions?<br>类别和类扩展的区别。<br>答案：category和extensions的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。<br>extensions可以认为是一个私有的Category。</p>
<p>4.Difference between protocol in objective c and interfaces in java?<br>obc中的协议和java中的接口概念有何不同？</p>
<p>答案：OBC中的代理有2层含义，官方定义为 formal和informal protocol。前者和Java接口一样。<br>informal protocol中的方法属于设计模式考虑范畴，不是必须实现的，但是如果有实现，就会改变类的属性。<br>其实关于正式协议，类别和非正式协议我很早前学习的时候大致看过，也写在了学习教程里<br>“非正式协议概念其实就是类别的另一种表达方式“这里有一些你可能希望实现的方法，你可以使用他们更好的完成工作”。<br>这个意思是，这些是可选的。比如我门要一个更好的方法，我们就会申明一个这样的类别去实现。然后你在后期可以直接使用这些更好的方法。<br>这么看，总觉得类别这玩意儿有点像协议的可选协议。”<br>现在来看，其实protocal已经开始对两者都统一和规范起来操作，因为资料中说“非正式协议使用interface修饰“，<br>现在我们看到协议中两个修饰词：“必须实现(@requied)”和“可选实现(@optional)”。</p>
<p>5.What are KVO and KVC?</p>
<p>答案：kvc:键 - 值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。<br>很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。<br>kvo:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。<br>具体用看到嗯哼用到过的一个地方是对于按钮点击变化状态的的监控。<br>比如我自定义的一个button<br>[cpp]<br>[self addObserver:self forKeyPath:@”highlighted” options:0 context:nil]; </p>
<p>#pragma mark KVO </p>
<ul>
<li>(void)observeValueForKeyPath:(NSString <em>)keyPath ofObject:(id)object change:(NSDictionary </em>)change context:(void *)context<br>{<br>if ([keyPath isEqualToString:@”highlighted”] ) {<br>[self setNeedsDisplay];<br>}<br>}<br>对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。<br>对于kvc机制如何通过key寻找到value：<br>“当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量（iVar），如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。</li>
</ul>
<p>(cocoachina.com注：Key-Value Coding查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以及_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。）</p>
<p>设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。“<br>来至cocoa，这个说法应该挺有道理。<br>因为我们知道button却是存在一个highlighted实例变量.因此为何上面我们只是add一个相关的keypath就行了，<br>可以按照kvc查找的逻辑理解，就说的过去了。</p>
<p>6.What is purpose of delegates?<br>代理的作用？<br>答案：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。<br>另外一点，代理可以理解为java中的回调监听机制的一种类似。</p>
<p>7.What are mutable and immutable types in Objective C?<br>obc中可修改和不可以修改类型。</p>
<p>答案：可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。<br>比如NSArray和NSMutableArray。前者在初始化后的内存控件就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。</p>
<p>8.When we call objective c is runtime language what does it mean?<br>我们说的obc是动态运行时语言是什么意思？</p>
<p>答案：多态。 主要是将数据类型的确定由编译时，推迟到了运行时。<br>这个问题其实浅涉及到两个概念，运行时和多态。<br>简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。<br>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat;<br>那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。<br>也就是不同的对象以自己的方式响应了相同的消息（响应了eat这个选择器）。<br>因此也可以说，运行时机制是多态的基础？~~~</p>
<p>9.what is difference between NSNotification and protocol?<br>通知和协议的不同之处？</p>
<p>答案：协议有控制链(has-a)的关系，通知没有。<br>首先我一开始也不太明白，什么叫控制链（专业术语了~）。但是简单分析下通知和代理的行为模式，我们大致可以有自己的理解<br>简单来说，通知的话，它可以一对多，一条消息可以发送给多个消息接受者。<br>代理按我们的理解，到不是直接说不能一对多，比如我们知道的明星经济代理人，很多时候一个经济人负责好几个明星的事务。<br>只是对于不同明星间，代理的事物对象都是不一样的，一一对应，不可能说明天要处理A明星要一个发布会，代理人发出处理发布会的消息后，别称B的<br>发布会了。但是通知就不一样，他只关心发出通知，而不关心多少接收到感兴趣要处理。<br>因此控制链（has-a从英语单词大致可以看出，单一拥有和可控制的对应关系。</p>
<p>10.What is push notification?<br>什么是推送消息？</p>
<p>11.Polymorphism？<br>关于多态性</p>
<p>答案：多态，子类指针可以赋值给父类。<br>这个题目其实可以出到一切面向对象语言中，<br>因此关于多态，继承和封装基本最好都有个自我意识的理解，也并非一定要把书上资料上写的能背出来。<br>最重要的是转化成自我理解。</p>
<p>12.Singleton?<br>对于单例的理解</p>
<p>答案：11，12题目其实出的有点泛泛的感觉了，可能说是编程语言需要或是必备的基础。<br>基本能用熟悉的语言写出一个单例，以及可以运用到的场景或是你编程中碰到过运用的此种模式的框架类等。<br>进一步点，考虑下如何在多线程访问单例时的安全性。</p>
<p>13.What is responder chain?<br>说说响应链</p>
<p>答案： 事件响应链。包括点击事件，画面刷新事件等。在视图栈内从上至下，或者从下之上传播。<br>可以说点事件的分发，传递以及处理。具体可以去看下touch事件这块。因为问的太抽象化了<br>严重怀疑题目出到越后面就越笼统。</p>
<p>14.Difference between frame and bounds?<br>frame和bounds有什么不同？</p>
<p>答案:frame指的是：该view在父view坐标系统中的位置和大小。（参照点是父亲的坐标系统）<br>bounds指的是：该view在本身坐标系统中 的位置和大小。（参照点是本身坐标系统）</p>
<p>15.Difference between method and selector?<br>方法和选择器有何不同？</p>
<p>答案：selector是一个方法的名字，method是一个组合体，包含了名字和实现.<br>详情可以看apple文档。</p>
<p>16.Is there any garbage collection mechanism in Objective C.?<br>OBC的垃圾回收机制？</p>
<p>答案： OBC2.0有Garbage collection，但是iOS平台不提供。<br>一般我们了解的objective-c对于内存管理都是手动操作的，但是也有自动释放池。<br>但是差了大部分资料，貌似不要和arc机制搞混就好了。<br>求更多~~</p>
<p>17.NSOperation queue?</p>
<p>答案：存放NSOperation的集合类。<br>操作和操作队列，基本可以看成java中的线程和线程池的概念。用于处理ios多线程开发的问题。<br>网上部分资料提到一点是，虽然是queue，但是却并不是带有队列的概念，放入的操作并非是按照严格的先进现出。<br>这边又有个疑点是，对于队列来说，先进先出的概念是Afunc添加进队列，Bfunc紧跟着也进入队列，Afunc先执行这个是必然的，<br>但是Bfunc是等Afunc完全操作完以后，B才开始启动并且执行，因此队列的概念离乱上有点违背了多线程处理这个概念。<br>但是转念一想其实可以参考银行的取票和叫号系统。<br>因此对于A比B先排队取票但是B率先执行完操作，我们亦然可以感性认为这还是一个队列。<br>但是后来看到一票关于这操作队列话题的文章，其中有一句提到<br>“因为两个操作提交的时间间隔很近，线程池中的线程，谁先启动是不定的。”<br>瞬间觉得这个queue名字有点忽悠人了，还不如pool~<br>综合一点，我们知道他可以比较大的用处在于可以帮组多线程编程就好了。</p>
<p>18.What is lazy loading?</p>
<p>答案：懒汉模式，只在用到的时候才去初始化。<br>也可以理解成延时加载。<br>我觉得最好也最简单的一个列子就是tableView中图片的加载显示了。<br>一个延时载，避免内存过高，一个异步加载，避免线程堵塞。</p>
<p>19.Can we use two tableview controllers on one viewcontroller?<br>是否在一个视图控制器中嵌入两个tableview控制器？</p>
<p>答案：一个视图控制只提供了一个View视图，理论上一个tableViewController也不能放吧，<br>只能说可以嵌入一个tableview视图。当然，题目本身也有歧义，如果不是我们定性思维认为的UIViewController，<br>而是宏观的表示视图控制者，那我们倒是可以把其看成一个视图控制者，它可以控制多个视图控制器，比如TabbarController<br>那样的感觉。</p>
<p>20.Can we use one tableview with two different datasources? How you will achieve this?<br>一个tableView是否可以关联两个不同的数据源？你会怎么处理？</p>
<p>答案：首先我们从代码来看，数据源如何关联上的，其实是在数据源关联的代理方法里实现的。<br>因此我们并不关心如何去关联他，他怎么关联上，方法只是让我返回根据自己的需要去设置如相关的数据源。<br>因此，我觉得可以设置多个数据源啊，但是有个问题是，你这是想干嘛呢？想让列表如何显示，不同的数据源分区块显示？</p>
<p>21.Object－c的类可以多重继承么？可以实现多个接口么？重写一个类的方式用继承好还是分类好？为什么？<br>Objective-c只支持单继承，如果要实现多继承的话，可以通过类别和协议的方式来实现，cocoa 中所有的类都是NSObject 的子类，多继承在这里是用protocol 委托代理 来实现的。</p>
<p>22.#import 跟#include 又什么区别 ＃import&lt;&gt; 跟 #import””又什么区别？<br>答案：@class一般用于头文件中需要声明该类的某个实例变量的时候用到，在m文 件中还是需要使用#import而#import比起#include的好处就是不会引起交叉编译。</p>
<p>23.类变量的@protected ,@private,@public,@package声明各有什么含义？</p>
<p>24.id 声明的对象有什么特性？<br>答案：id是个很重要的类型，是个可以指向任何类型的指针或者可以理解为指向任何未知类型的指针。</p>
<p>25.MVC是什么？有什么特性？为什么在iPhone上被广泛运用？<br>答案：MVC设计模式考虑三种对象：模型对象、视图对象、和控制器对象。模型对象代表 特别的知识和专业技能，它们负责保有应用程序的数据和定义操作数据的逻辑。视图对象知道如何显示应用程序的模型数据，而且可能允许用户对其进行编辑。控制 器对象是应用程序的视图对象和模型对象之间的协调者。</p>
<p>26.对于语句NSString* testObject = [[NSData alloc] init];testObject 在编译时和运行时分别是什么类型的对象？</p>
<p>27.什么是安全释放？</p>
<p>28.为什么有些4.0独有的objective－c 函数在3.1上运行时会报错.而4.0独有的类在3.1上分配内存时不会报错？分配的结果是什么？</p>
<p>29.为什么4.0独有的c函数在3.1的机器上运行不会报错（在没有调用的情况下？）而4.0独有的类名在3.1的机器上一运行就报错？</p>
<p>30.异常exception 怎么捕获？不同的CPU结构上开销怎样？C中又什么类似的方法？</p>
<p>31.property中属性retain,copy,assgin的含义分别是什么？有什么区别？将其转换成get／set方法怎么做？有什么注意事项？</p>
<p>32.委托是什么？委托的property声明用什么属性？为什么？</p>
<p>34.Cocoa中有虚基类的概念么？怎么简洁的实现？</p>
<p>35.自动释放池跟GC（垃圾回收）有什么区别？iPhone上有GC么？［pool release］ 和［pool drain］有什么区别？<br>iPhone上没有GC。iPhone开发的时候没有垃圾回收机制。<br>在垃圾回收环境中，release是一个空操作。因此，NSAutoreleasePool提供了drain方法，在引用计数环境中，该方法的作用等同于调用release，但在垃圾回收环境中，它会触发垃圾回收（如果自上次垃圾回收以来分配的内存大于当前的阈值）。因此，在通常情况下，您应该使用drain而不是release来销毁自动释放池。</p>
<p>36.<br>for(int index = 0; index &lt; 20; index ++){<br>NSString <em>tempStr = @”tempStr”;<br>NSLog(tempStr);<br>NSNumber </em>tempNumber = [NSNumber numberWithInt:2];<br>NSLog(tempNumber);<br>}<br>这段代码有什么问题.？会不会造成内存泄露（多线程）？在内存紧张的设备上做大循环时自动释放池是写在循环内好还是循环外好？为什么？</p>
<p>37.内存管理的几条原则时什么？按照默认法则.那些关键字生成的对象需要手动释放？在和property结合的时候怎样有效的避免内存泄露？</p>
<p>38.在一个对象释放前.如果他被加到了notificationCenter 中.不在notificationcenter中remove这个对象可能会出现什么问题？</p>
<p>39.怎样实现一个 singleton的类.给出思路。</p>
<p>40.什么是序列化或者Acrchiving,可以用来做什么,怎样与copy结合,原理是什么?.</p>
<ol>
<li>线程与进程的区别和联系?<br>答案: 进程和线程都是由操作系统所体会的程序运行的基本 单元，系统利用该基本单元实现系统对应用的并发性。<br>程和线程的主要差别在于它们是不同的操作系统资源 管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变 量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一 些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</li>
</ol>
<p>42.在iphone上有两件事情要做,请问是在一个线程里按顺序做效率高还是两个线程里做效率高？为什么？</p>
<p>43.runloop是什么？在主线程中的某个函数里调用了异步函数，怎么样block当前线程,且还能响应当前线程的timer事件，touch事件等.</p>
<p>44.ios平台怎么做数据的持久化?coredata和sqlite有无必然联系？coredata是一个关系型数据库吗？<br>iOS中可以有四种持久化数据的方式： 属性列表、对象归档、SQLite3和Core Data；core data可以使你以图形界面的方式快速的定义app的数据模型，同时在你的代码中容易获取到它。core data提供了基础结构去处理常用的功能，例如保存，恢复，撤销和重做，允许你在app中继续创建新的任务。在使用core data的时候，你不用安装额外的数据库系统，因为core data使用内置的sqlite数据库。core data将你app的模型层放入到一组定义在内存中的数据对象。core data会追踪这些对象的改变，同时可以根据需要做相反的改变，例如用户执行撤销命令。当core data在对你app数据的改变进行保存的时候，core data会把这些数据归档，并永久性保存。<br>mac os x中sqlite库，它是一个轻量级功能强大的关系数据引擎，也很容易嵌入到应用程序。可以在多个平台使用，sqlite是一个轻量级的嵌入式sql数据库编程。与core data框架不同的是，sqlite是使用程序式的，sql的主要的API来直接操作数据表。<br>Core Data不是一个关系型数据库，也不是关系型数据库管理系统(RDBMS)。虽然Core Dta支持SQLite作为一种存储类型，但它不能使用任意的SQLite数据库。Core Data在使用的过程种自己创建这个数据库。Core Data支持对一、对多的关系。</p>
<p>45.阐述一个nil对象从interface bulider产生，到载入程序运行空间，最后被释放时所经历的生命周期.</p>
<p>46.notification是同步还是异步? kvo是同步还是异步？notification是全进程空间的通知吗？kvo呢？</p>
<p>47.kvc是什么?kvo是什么?有什么特性？<br>48.响应者链是什么？<br>49.unix上进程怎么通信？<br>UNIX主要支持三种通信方式：</p>
<ol>
<li>基本通信：主要用来协调进程间的同步和互斥<br>(1)锁文件通信<br>通信的双方通过查找特定目录下特定类型的文件(称锁文件)来完成进程间  对临界资源访问时的互斥；例如进程p1访问一个临界资源，首先查看是否有一个特定类型文件，若有，则等待一段时间再查找锁文件。<br>(2)记录锁文件</li>
<li>管道通信：适应大批量的数据传递</li>
<li>IPC：适应大批量的数据传递</li>
</ol>
<p>50.timer的间隔周期准吗？为什么？怎样实现一个精准的timer?</p>
<p>51.UIscrollVew用到了什么设计模式？还能再foundation库中找到类似的吗？（答案众多，不知道哪个是对的～～）<br>模板(Template)模式，所有datasource和delegate接口都是模板模式的典型应用，<br>组合模式composition，所有的containerview都用了这个模式<br>观察者模式observer，所有的UIResponder都用了这个模式。</p>
<p>52如果要开发一个类似eclipse的软件，支持插件结构。且开放给第三方开发。你会怎样去设计它？（大概思路）</p>
<ol>
<li><p>main()<br>{<br>int a[5]={1,2,3,4,5};<br>int <em>ptr=(int </em>)(&amp;a+1);<br>printf(“%d,%d”,<em>(a+1),</em>(ptr-1));<br>}<br>答：2,5<br><em>(a+1)就是a[1]，</em>(ptr-1)就是a[4],执行结果是2.5<br>，&amp;a+1不是首地址+1，系统会认为加一个a数组的偏 移，是偏移了一个数组的大小（本例是5个int，int <em>ptr=(int </em>)(&amp;a+1);<br>则ptr实际 是&amp;(a[5]),也就是a+5<br>原因如下：<br>　　&amp;a是数组指针，其类型为 int (<em>)[5];<br>而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同。a是长度为5的int数组指针，所以要加 5</em>sizeof(int)所以ptr实际是a[5]，但是prt与(&amp;a+1)类型是不一样的(这点很重要)，所以prt-1只会减去sizeof(int*)，a,&amp;a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&amp;a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&amp;a+1是下一个对象的地址，即a[5].</p>
</li>
<li><p>以下为Windows NT下的32位C++程序，请计算sizeof的值</p>
</li>
</ol>
<p>voidFunc ( char str[100] )<br>{<br>sizeof( str ) =?<br>}<br>void *p = malloc( 100 );<br>sizeof ( p ) = ?<br>答案：这题 很常见了,Func( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。Windows NT 32位平台下，指针的长度（占用内存的大小）为4字节，故sizeof( str ) 、sizeof( p ) 都为4。</p>
<p>55.- （void）<em>getNSString(const NSString </em>inputString)<br>{inputString =@”This is a main test\n”;<br>return ;}<br>-main(void)<br>{NSString <em>a=@”Main”;<br>NSString </em>aString = [NSStringstringWithString:@”%@”,getNSString(a)];<br>NSLog(@”%@\n”, aString);}<br>最后问输出的字符串:NULL,output在 函数返回后，内存已经被释放。</p>
<p>56.列举几种进程的同步机制，并比较其优缺点。<br>答案：  原子操作信号量机制    自旋锁    管程，会合，分布式系统 </p>
<p>进程之间通信的途径<br>答案：共享存储系统消息传递系统管道：以文件系统为基础<br>进程死锁的原因<br>答案：资源竞争及进程推进顺序非法<br>死锁的4个必要条 件<br>答案：互斥、请求保持、不可剥夺、环路<br>死锁的处理<br>答案：鸵鸟策略、预防策略、避免策略、检测与解除死锁</p>
<p>57.堆和栈的区别<br>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br>申请大小：<br>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。<br>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<br>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个 问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出<br>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。</p>
<p>58.什么是键-值,键路径是什么?<br>模型的性质是通过一个简单的键（通常是个字符串）来指定的。视图和控制器通过键来查找相应的属性值。在一个给定的实体中，同一个属性的所有值具有相同的数据类型。键-值编码技术用于进行这样的查找—它是一种间接访问对象属性的机制。<br>键路径是一个由用点作分隔符的键组成的字符串，用于指定一个连接在一起的对象性质序列。第一个键的<br>性质是由先前的性质决定的，接下来每个键的值也是相对于其前面的性质。键路径使您可以以独立于模型<br>实现的方式指定相关 对象的性质。通过键路径，您可以指定对象图中的一个任意深度的路径，使其指向相<br>关对象的特定属性。</p>
<p>59.c和obj-c如何混用<br>1）obj-c的编译器处理后缀为m的文件时，可以识别obj-c和c的代码，处理mm文件可以识别obj-c,c,c++代码，但cpp文件必须只能用c/c++代码，而且cpp文件include的头文件中，也不能出现obj- c的代码，因为cpp只是cpp<br>2) 在mm文件中混用cpp直接使用即可，所以obj-c混cpp不是问题<br>3）在cpp中混用obj- c其实就是使用obj-c编写的模块是我们想要的。<br>如果模块以类实现，那么要按照cpp class的标准写类的定义，头文件中不能出现obj-c的东西，包括#import cocoa的。实现文件中，即类的实现代码中可以使用obj-c的东西，可以import,只是后缀是mm。<br>如果模块以函数实现，那么头文件要按 c的格式声明函数，实现文件中，c++函数内部可以用obj-c，但后缀还是mm或m。</p>
<p>总结：只要cpp文件和cpp include的文件中不包含obj-c的东西就可以用了，cpp混用obj-c的关键是使用接口，而不能直接使用实现代码，实际上cpp混用的是 obj-c编译后的o文件，这个东西其实是无差别的，所以可以用。obj-c的编译器支持cpp.</p>
<p>60.目标-动作机制<br>目标是动作消息的接收者。一个控件，或者更为常见的是它的单元，以插座变量（参见”插座变量”部分）<br>的形式保有其动作消息的目标。<br>动作是控件发送给目标的消息，或者从目标的角度看，它是目标为了响应动作而实现的方法。<br>程序需要某些机制来进行事件和指令的翻译。这个机制就是目标-动作机制。</p>
<p>61.cocoatouch框架<br>iPhoneOS 应用程序的基础Cocoa Touch 框架重用了许多 Mac 系统的成熟模式，但是它更多地专注于触摸的接口和优化。UIKit 为您提供了在 iPhone OS 上实现图形，事件驱动程序的基本工具，其建立在和 Mac OS X 中一样的 Foundation 框架上，包括文件处理，网络，字符串操作等。<br>CocoaTouch 具有和 iPhone 用户接口一致的特殊设计。有了 UIKit，您可以使用 iPhone OS 上的独特的图形接口控件，按钮，以及全屏视图的功能，您还可以使用加速仪和多点触摸手势来控制您的应用。<br>各色俱全的框架 除了UIKit 外，Cocoa Touch 包含了创建世界一流iPhone 应用程序需要的所有框架，从三维图形，到专业音效，甚至提供设备访问 API 以控制摄像头，或通过 GPS 获知当前位置。Cocoa Touch 既包含只需要几行代码就可以完成全部任务的强大的 Objective-C 框架，也在需要时提供基础的 C 语言 API 来直接访问系统。这些框架包括：<br>CoreAnimation<br>通过 CoreAnimation，您就可以通过一个基于组合独立图层的简单的编程模型来创建丰富的用户体验。<br>CoreAudio<br>CoreAudio 是播放，处理和录制音频的专业技术，能够轻松为您的应用程序添加强大的音频功能。<br>CoreData<br>提供了一个面向对象的数据管理解决方案，它易于使用和理解，甚至可处理任何应用或大或小的数据模型。<br>功能列表：框架分类<br>下面是 CocoaTouch 中一小部分可用的框架：<br>•   音频和视频<br>•   Core Audio<br>•   OpenAL<br>•   Media Library<br>•   AV Foundation<br>•   数据管理<br>•   Core Data<br>•   SQLite<br>•   图形和动画<br>•   Core Animation<br>•   OpenGL ES<br>•   Quartz 2D<br>•   网络/li&gt;<br>•   Bonjour<br>•   WebKit<br>•   BSD Sockets<br>•   用户应用<br>•   Address Book<br>•   Core Location<br>•   Map Kit<br>•   Store Kit</p>
<p>62.objc的内存管理<br>如果您通过分配和初始化（比如[[MyClass alloc] init]）的方式来创建对象，您就拥<br>有这个对象，需要负责该对象的释放。这个规则在使用NSObject的便利方法new 时也同样适用.<br>如果您拷贝一个对象，您也拥有拷贝得到的对象，需要负责该对象的释放.<br>如果您保持一个对象，您就部分拥有这个对象，需要在不再使用时释放该对象。<br>如果您从其它对象那里接收到一个对象，则您不拥有该对象，也不应该释放它（这个规则有少数<br>的例外，在参考文档中有显式的说明）。</p>
<p>63.自动释放池是什么,如何工作<br>当您向一个对象发送一个autorelease消息时，Cocoa就会将该对 象的一个引用放入到最新的自动释放池。它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。</p>
<ol>
<li>ojc-c 是通过一种”referringcounting”(引用计数)的方式来管理内存的, 对象在开始分配内存(alloc)的时候引用计数为一,以后每当碰到有copy,retain的时候引用计数都会加一, 每当碰到release和autorelease的时候引用计数就会减一,如果此对象的计数变为了0, 就会被系统销毁.</li>
<li>NSAutoreleasePool 就是用来做引用计数的管理工作的,这个东西一般不用你管的.</li>
<li>autorelease和release没什么区别,只是引用计数减一的时机不同而已,autorelease会在对象的使用真正结束的时候才做引用计数减一.</li>
</ol>
<p>64.类工厂方法是什么<br>类工厂方法的实现是为了向客户提供方便，它们将分配和初始化合在一个步骤中， 返回被创建的对象，并<br>进行自动释放处理。这些方法的形式是+ (type)className…（其中 className不包括任何前缀）。<br>工厂方法可能不仅仅为了方便使用。它们不但可以将分配和初始化合在一起，还可以为初始化过程提供对<br>象的分配信息。<br>类工厂方法的另一个目的是使类（比如NSWorkspace）提供单件实例。虽 然init…方法可以确认一<br>个类在每次程序运行过程只存在一个实例，但它需要首先分配一个“生的”实例，然后还必须释放该实例。<br>工厂 方法则可以避免为可能没有用的对象盲目分配内存。</p>
<p>65.单件实例是什么<br>Foundation和Application Kit 框架中的一些类只允许创建单件对象，即这些类在当前进程中的唯一实例。举例来说，NSFileManager和NSWorkspace 类在使用时都是基于进程进行单件对象的实例化。当向这些类请求实例的时候，它们会向您传递单一实例的一个引用，如果该实例还不存在，则首先进行实例的分配和初始化。 单件对象充当控制中心的角色，负责指引或协调类的各种服务。如果类在概念上只有一个实例（比如<br>NSWorkspace），就应该产生一个单件实例，而不是多个实例；如果将来某一天可能有多个实例，您可<br>以使用单件实例机制，而不是工厂方法或函数。</p>
<p>66.动态绑定—在运行时确定要调用的方法<br>动态绑定将调用方法的确定也推迟到运行时。在编译时，方法的调用并不和代码绑定在一起，只有在消实发送出来之后，才确定被调用的代码。通过动态类型和动态绑定技术，您的代码每次执行都可以得到不同的结果。运行时因子负责确定消息的接 收者和被调用的方法。运行时的消息分发机制为动态绑定提供支持。当您向一个动态类型确定了的对象发送消息时，运行环境系统会通过接收者的isa指针定位对象的类，并以此为起点确定被调用的方法，方法和消息是动态绑定的。而且，您不必在Objective-C 代码中做任何工作，就可以自动获取动态绑定的好处。您在每次发送消息时，</p>
<p>特别是当消息的接收者是动态类型已经确定的对象时，动态绑定就会例行而 透明地发生。</p>
<p>67.obj-c的优缺点<br>objc优点：</p>
<p>1)Cateogies </p>
<p>2) Posing </p>
<p>3) 动态识别</p>
<p>4) 指标计算 </p>
<p>5）弹性讯息传递</p>
<p>6) 不是一个过度复杂的 C 衍生语言</p>
<p>7) Objective-C 与 C++ 可混合编程</p>
<p>缺点: </p>
<p>1) 不支援命名空間 </p>
<p>2) 不支持运算符重载<br>3） 不支持多重继承<br>4） 使用动态运行时类型，所有的方法都是函数调用，所以很多编译时优化方法都用不到。（如内联函数等），性能低劣。</p>
<p>68.readwrite，readonly，assign，retain，copy，nonatomic 属性的作用？<br>@property是 一个属性访问声明，扩号内支持以下几个属性：<br>1，getter=getterName，setter=setterName，设置setter与 getter的方法名<br>2，readwrite,readonly，设置可供访问级别<br>2，assign，setter方法直接赋值，不进行 任何retain操作，为了解决原类型与环循引用问题<br>3，retain，setter方法对参数进行release旧值再retain新值，所有实现都是这个顺序(CC上有相关资料)<br>4，copy，setter方法进行Copy操作，与retain处理流程一样，先旧值release，再 Copy出新的对象，retainCount为1。这是为了减少对上下文的依赖而引入的机制。<br>5，nonatomic，非原子性访问，不加同步， 多线程并发访问会提高性能。注意，如果不加此属性，则默认是两个访问方法都为原子型事务访问。锁被加到所属对象实例级(我是这么理解的…)。</p>
<p>69.ViewController的 didReceiveMemoryWarning 是在什么时候被调用的？（87题）<br>70.谈谈你对ARC 的认识和理解？</p>
<ol>
<li>ObjC中，与alloc语义相反的方法是dealloc还是release？与retain语义相反的方法是dealloc还是release，为什么？需要与alloc配对使用的方法是dealloc还是release，为什么？<br>alloc与dealloc语意相反，alloc是创建变量，dealloc是释放变量。 retain 对应release,retain 保留一个对象。调用之后，变量的计数加1。或许不是很明显，在这有例为证：                 </li>
</ol>
<ul>
<li>(void)setName : (NSString<em>) name {<br>[name retain];<br>[myname release];<br>myname = name; }<br>我们来解释一下：设想，用户在调用这个函数的时候，他注意了内存的管理，所以他小心的写了如下代码：<br>NSString</em> newname = [[NSString alloc] initWithString: @”John”];<br>[aClasssetName: newname];<br>[newnamerelease];<br>我们来看一看newname的计数是怎么变化的。首先，它被alloc，count = 1; 然后，在setName中，它被retain，count = 2; 最后，用户自己释放newname，count= 1，myname指向了newname。这也解释了为什么需要调用[myname release]。我们需要在给myname赋新值的时候，释放掉以前老的变量。retain 之后直接dealloc对象计数器没有释放。alloc 需要与release配对使用，因为alloc 这个函数调用之后，变量的计数加1。所以在调用alloc 之后，一定要调用对应的release。另外，在release一个变量之后，他的值仍然有效，所以最好是后面紧接着再var = nil。</li>
</ul>
<ol>
<li><p>在一个对象的方法里面:<br>self.name<a href="http://self.name/" target="_blank" rel="external">http://self.name/</a> = “object”;<br>和<br>name ＝”object”<br>有什么不同?</p>
</li>
<li><p>这段代码有什么问题:<br>@implementation Person</p>
</li>
</ol>
<ul>
<li>(void)setAge:(int)newAge {<br>self.age = newAge;<br>}<br>@end</li>
</ul>
<ol>
<li>什么是retaincount?</li>
</ol>
<p>75.以下每行代码执行后，person对象的retain count分别是多少<br>Person *person = [[Person alloc] init];<br>[person retain];<br>[person release];<br>[person release];</p>
<p>76.为什么很多内置类如UITableViewController的delegate属性都是assign而不是retain的？</p>
<p>77.定义属性时，什么情况使用copy，assign，和retain？<br>assign用于简单数据类型，如NSInteger,double,bool,retain和copy用户对象，copy用于当 a指向一个对象，b也想指向同样的对象的时候，如果用assign，a如果释放，再调用b会crash,如果用copy 的方式，a和b各自有自己的内存，就可以解决这个问题。retain 会使计数器加一，也可以解决assign的问题。另外：atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。加了atomic，setter函数会变成下面这样：<br>if(property != newValue) {<br>[propertyrelease];<br>property = [newValueretain];<br>} </p>
<ol>
<li><p>autorelease的对象是在什么时候被release的？<br>答：autorelease实际上只是把对release的调用延迟了，对于每一个Autorelease，系统只是把该Object放入了当前的Autoreleasepool中，当该pool被释放时，该pool中的所有Object会被调用Release。对于每一个Runloop，系统会隐式创建一个Autoreleasepool，这样所有的releasepool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autoreleasepool会被销毁，这样这个pool里的每个Object（就是autorelease的对象）会被release。那什么是一个Runloop呢？一个UI事件，Timer call，delegate call， 都会是一个新的Runloop。那什么是一个Runloop呢？一个UI事件，Timer call，delegate call， 都会是一个新的Runloop。</p>
</li>
<li><p>这段代码有什么问题,如何修改<br>for (int i = 0; i &lt; someLargeNumber; i++)<br>{<br>NSString *string = @”Abc”;<br>string = [string lowercaseString];<br>string = [stringstringByAppendingString:@”xyz”];<br>NSLog(@“%@”, string);<br>}</p>
</li>
<li><p>autorelease和垃圾回收机制(gc)有什么关系？IPhone OS有没有垃圾回收（gc）？</p>
</li>
<li><p>Objective C中的protocal是什么？<br>@protocal obj里面的协议就如同java里面的interface。</p>
</li>
<li><p>Objective C中的selector 是什么？<br>你可以理解 @selector()就是取类方法的编号,他的行为基本可以等同C语言的中函数指针,只不过C语言中，可以把函数名直接赋给一个函数指针，而Objective-C的类不能直接应用函数指针，这样只能做一个@selector语法来取.它的结果是一个SEL类型。这个类型本质是类方法的编号(函数地址)。</p>
</li>
<li><p>Objective C中的category是什么?<br>Objective-C提供了一个非常灵活的类(Class)扩展机制－类别(Category)。类别用于对一个已经存在的类添加方法(Methods)。你只需要知道这个类的公开接口，不需要知道类的源代码。需要注意的是，类别不能为已存在的类添加实例变量(Instance Variables)。<br>子类(subclassing)是进行类扩展的另一种常用方法。与子类相比，类别最主要的优点是：系统中已经存在的类可以不需修改就可使用类别的扩展功能。<br>类别的第二大优点是实现了功能的局部化封装。类别定义可以放在一个已存在的类(类A)的定义文件中(.h)。这意味着这个类别只有在类A被引用的前提下才会被外部看到。如果另一个类(类B)不需要用到类A的功能(没有包含类A的.h文件)，也就不会看到依附类A存在的类别。iOS SDK中广泛运用这种类别定义法来封装功能。</p>
</li>
<li><p>什么是Notification？什么时候用delegate，什么时候用Notification？<br>观察者模式，controller向defaultNotificationCenter添加自己的notification，其他类注册这个notification就可以收到通知，这些类可以在收到通知时做自己的操作（多观察者默认随机顺序发通知给观察者们，而且每个观察者都要等当前的某个观察者的操作做完才能轮到他来操作，可以用NotificationQueue的方式安排观察者的反应顺序，也可以在添加观察者中设定反映时间，取消观察需要在viewDidUnload跟dealloc中都要注销）。<br>delegate针对one-to-one关系，并且reciever可以返回值给sender，notification可以针对one-to-one/many/none,reciever无法返回值给sender.所以，delegate用于sender希望接受到reciever的某个功能反馈值，<br>notification用于通知多个object某个事件。</p>
</li>
<li><p>什么是KVC和KVO？Notification和KVO有什么不同？KVO在ObjC中是怎么实现的？</p>
</li>
<li><p>ViewController 的 loadView,viewDidLoad, viewDidUnload 分别是在什么时候调用的？在自定义ViewController的时候这几个函数里面应该做什么工作？<br>答：viewDidLoad在view 从nib文件初始化时调用，loadView在controller的view为nil时调用。此方法在编程实现view时调用,view 控制器默认会注册memory warning notification,当view controller的任何view 没有用的时候，viewDidUnload会被调用，在这里实现将retain 的view release,如果是retain的IBOutlet view 属性则不要在这里release,IBOutlet会负责release 。</p>
</li>
<li><p>ViewController 的didReceiveMemoryWarning 是在什么时候被调用的？UIViewController类中didReceiveMemoryWarning默认的操作是什么？<br>答：默认调用[superdidReceiveMemoryWarning]</p>
</li>
<li><p>UITableViewController 中，创建UITableViewCell时，initWithSytle:resuseIdentifier中，reuseIdentifier有什么用？简述UITableViewCell的复用原理.<br>复用队列的元素增加：只有在cell被滑动出界面的时候，此cell才会被加入到复用队列中。每次在创建cell的时候，程序会首先通过调用dequeueReusableCellWithIdentifier:cellType方法，到复用队列中去寻找标示符为“cellType”的cell，如果找不到，返回nil，然后程序去通过调用[[[UITableViewCell alloc]initWithStyle:style reuseIdentifier:cellType] autorelease]来创建标示符为“cellType”的cell。</p>
</li>
<li><p>UIView 和CALayer 有什么区别?<br>两者最大的区别是，图层不会直接渲染到屏幕上。</p>
</li>
<li><p>以 UIView 类animateWithDuration:animations: 为例，简述UIView动画原理。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[重视法抗lds]]></title>
      <url>http://yoursite.com/2017/07/24/%E9%87%8D%E8%A7%86%E6%B3%95%E6%8A%97lds/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios静态库的制作]]></title>
      <url>http://yoursite.com/2017/03/16/%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="一、什么是库？"><a href="#一、什么是库？" class="headerlink" title="一、什么是库？"></a>一、什么是库？</h3><p>库是共享程序代码的方式，一般分为静态库和动态库。<br><code>静态库：</code>链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。<br><code>动态库：</code>链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</p>
<h3 id="二、静态库和动态库的好处"><a href="#二、静态库和动态库的好处" class="headerlink" title="二、静态库和动态库的好处"></a>二、静态库和动态库的好处</h3><ul>
<li>使用静态库的好处：<br>1、模块化，分工合作<br>2、避免少量改动经常导致大量的重复编译连接<br>3、也可以重用，注意不是共享使用</li>
<li>动态库使用有如下好处：<br>1、使用动态库，可以将最终可执行文件体积缩小<br>2、使用动态库，多个应用程序共享内存中得同一份库文件，节省资源<br>3、使用动态库，可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。<br>从1可以得出，将整个应用程序分模块，团队合作，进行分工，影响比较小。<br>从2可以看出，其实动态库应该叫共享库，那么从这个意义上来说，苹果禁止iOS开发中使用动态库就可以理解了：<br>因为在现在的iPhone，iPodTouch，iPad上面程序都是单进程的，也就是某一时刻只有一个进程在运行，那么你写个共享库，<br>—-共享给谁？（你使用的时候只有你一个应用程序存在，其他的应该被挂起了，即便是可以同时多个进程运行，别人能使用你的共享库里的东西吗？你这个是给你自己的程序定制的。）<br>—-目前苹果的AppStore不支持模块更新，无法更新某个单独文件(除非自己写一个更新机制：有自己的服务端放置最新动态库文件)<br>至于苹果为啥禁止ios开发使用动态库我就猜到上面俩原因</li>
</ul>
<h3 id="三、iOS里静态库和动态库形式？"><a href="#三、iOS里静态库和动态库形式？" class="headerlink" title="三、iOS里静态库和动态库形式？"></a>三、iOS里静态库和动态库形式？</h3><p>静态库：.a和.framework<br>动态库：.dylib和.framework</p>
<h3 id="四、framework为什么既是静态库又是动态库？"><a href="#四、framework为什么既是静态库又是动态库？" class="headerlink" title="四、framework为什么既是静态库又是动态库？"></a>四、framework为什么既是静态库又是动态库？</h3><p>系统的.framework是动态库，我们自己建立的.framework是静态库。</p>
<h3 id="五、a与-framework有什么区别？"><a href="#五、a与-framework有什么区别？" class="headerlink" title="五、a与.framework有什么区别？"></a>五、a与.framework有什么区别？</h3><p>.a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。<br>.a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用。<br>.a + .h + sourceFile = .framework。<br>建议用.framework.</p>
<h3 id="六、为什么要使用静态库？"><a href="#六、为什么要使用静态库？" class="headerlink" title="六、为什么要使用静态库？"></a>六、为什么要使用静态库？</h3><p>国内的企业，掌握有核心技术，同时是又希望更多的程序员来使用其技术，因此采用”闭源”的方式开发使用。例如：百度地图，友盟，JPush等。在企业开发中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，也会提供静态库给程序员使用。方便共享代码，便于合理使用。实现iOS程序的模块化。可以把固定的业务模块化成静态库。和别人分享你的代码库，但不想让别人看到你代码的实现。开发第三方sdk的需要。</p>
<h3 id="七、静态库的种类"><a href="#七、静态库的种类" class="headerlink" title="七、静态库的种类"></a>七、静态库的种类</h3><ul>
<li><p>静态库文件的版本(4种)<br>1.真机-Debug版本<br>2.真机-Release版本<br>3.模拟器-Debug版本<br>4.模拟器-Release版本</p>
</li>
<li><p>调试版本(Debug版本) VS 发布版本(Release版本)<br>1.调试版本会包含完整的符号信息，以方便调试<br>2.调试版本不会对代码进行优化<br>3.发布版本不会包含完整的符号信息<br>4.发布版本的执行代码是进行过优化的<br>5.发布版本的大小会比调试版本的略小<br>5.在执行速度方面，调试版本会更快些，但不意味着会有显著的提升</p>
</li>
</ul>
<h3 id="八、制作静态库时的几点注意："><a href="#八、制作静态库时的几点注意：" class="headerlink" title="八、制作静态库时的几点注意："></a>八、制作静态库时的几点注意：</h3><p>1 注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。<br>2 图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。<br>3 category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。<br>4 如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。</p>
<h3 id="九、关于静态库的报错"><a href="#九、关于静态库的报错" class="headerlink" title="九、关于静态库的报错"></a>九、关于静态库的报错</h3><p>Undefined symbols for architecture i386:  i386可以理解为制作CPU的时候的CPU的种类</p>
<p>报上面的错表示:静态库不能在使用i386架构的cpu设备上面运行</p>
<p>i386 : iPhone模拟器 3gs-&gt;iPhone5<br>x86_64 : iPhone模拟器 5s-&gt;6plus</p>
<p>lipo -info 静态库:查看该静态库支持哪些架构</p>
<p>armv7 : iPhone 3gs-&gt;4s<br>armv7s : iPhone 5-&gt;5c<br>arm64 : iPhone 5s-&gt;6plus</p>
<h3 id="合并-a"><a href="#合并-a" class="headerlink" title="合并.a"></a>合并.a</h3><p>lipo -create Debug-iphoneos/libTools.a Debug-iphonesimulator/libTools.a -output libTools.a</p>
<ul>
<li>合并.a的好处，开发过程中既可以在真机上调试，也可以在模拟器上调试</li>
<li>合并.a的坏处，如果静态库太大，合并打包后，会非常大，因此很多第三方的静态库的.a是区分版本的</li>
<li>今后在使用.a时一定注意版本</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios编程词汇大全]]></title>
      <url>http://yoursite.com/2017/02/24/words/</url>
      <content type="html"><![CDATA[<p>A2A integration [,inti’ɡreiʃən]        A2A整合<br>abstract [‘æbstrækt, æb’strækt]  抽象的<br>abstract base [beis] class (ABC)抽象基类<br>abstract class 抽象类<br>abstraction [æb’strækʃən] 抽象、抽象物、抽象性<br>access [‘ækses, ‘æksəs, æk’ses]存取、访问<br>access level[‘levəl]访问级别<br>access function [‘fʌŋkʃən]访问函数<br>account [ə’kaunt]账户<br>action [‘ækʃən]动作<br>activate [‘æktiveit] 激活<br>active [‘æktiv]活动的<br>actual parameter [‘æktʃuəl] [pə’ræmitə] 实参<br>adapter [ə’dæptə]适配器<br>add-in 插件<br>address [ə’dres]地址<br>address space     地址空间<br>address-of operator [‘ɔpəreitə]取地址操作符<br>ADL (argument-dependent lookup) [‘ɑ:ɡjumənt] [di’pendənt]<br>ADO(ActiveX Data Object)ActiveX数据对象<br>advanced [əd’vænst]高级的<br>aggregation [,æɡri’ɡeiʃən] 聚合、聚集                         1<br>algorithm [‘ælgə’rɪðəm] 算法<br>alias [ˈeɪli:əs] 别名<br>align [ə’lain]排列、对齐<br>allocate [ˈæləkeit] 分配、配置<br>allocator[‘æləukeitə]分配器、配置器<br>angle bracket [‘æŋɡl] [‘brækit]尖括号<br>annotation [,ænəu’teiʃən]注解、评注<br>API (Application Programming Interface) 应用(程序)编程接口<br>app domain (application domain) [æp] [do’men]应用域<br>application [,æpli’keiʃən]应用、应用程序<br>application framework [‘freimwə:k] 应用程序框架<br>appearance [ə’piərəns]外观<br>append [ə’pend]附加<br>architecture [‘ɑ:kitektʃə]架构、体系结构<br>archive file [‘ɑ:kaiv] [‘fail] 归档文件、存档文件<br>argument[‘ɑ:ɡjumənt]引数(传给函式的值)。参见parameter [pə’ræmitə]<br>array [ə’rei]数组<br>arrow operator [‘ærəu] [‘ɔpəreitə]箭头操作符<br>ASP(Active Server [‘sɝvɚ] Page)活动服务器页面<br>ASP.NET worker process [‘prəuses, ‘prɔ-] ASP.NET工作者进程<br>assembly [ə’sembli] 装配件、配件<br>assembly language   汇编语言                                   2<br>assembly manifest [‘mænifest]装配件清单<br>assert(ion) [ə’sə:t] assertion [ə’sɝʃən] 断言<br>assign [ə’sain] 赋值<br>assignment [ə’sainmənt]赋值、分配<br>assignment operator 赋值操作符=<br>associated [ə’səuʃi,eitid] 相关的、相关联的<br>associative container [ə’səuʃjətiv] [kən’teinə]关联式容器(对应sequential container [si’kwenʃəl])<br>asynchronous [eɪˈsɪŋkrənəs] 异步的<br>atomic [ə’tɔmik]原子的<br>atomic operation   原子操作<br>attribute[ ‘ætribju:t]  特性、属性<br>authentication [ɔːˌθentɪˈkeɪʃn]service 验证服务<br>authorization [,ɔ:θərai’zeiʃən, -ri’z-]授权<br>audio [‘ɔ:diəu]  音频<br>A.I.    人工智能artificial intelligence [,ɑ:ti’fiʃəl] [in’telidʒəns]<br>B2B integration [,inti’ɡreiʃən] B2B整合、B2B集成(business-to-business integration)<br>background   背景、后台(进程)<br>backward compatible [kəm’pætəbl] 向后兼容、向下兼容<br>backup   备份<br>backup device[di’vais]备份设备                                       3<br>backup file 备份文件<br>bandwidth [‘bændwidθ] 带宽<br>base class 基类<br>base type 基类型<br>batch [bætʃ]批处理<br>BCL (base class library)基类库<br>binary [‘bainəri]二进制<br>binary search 二分查找<br>binary tree 二叉树<br>binary function 双参函数<br>binary large object二进制大对象<br>binary operator 二元操作符<br>binding [‘baindiŋ] 绑定<br>bit 位<br>bitmap [‘bit,mæp]位图<br>bitwise 按位…<br>bitwise copy       为单元进行复制；位元逐一复制,按位拷<br>bitwise operation 按位运算<br>block 块、区块、语句块<br>bookkeeping [‘buk,ki:piŋ]簿记<br>boolean [‘bu:liən]布林值(真假值，true或false)<br>border [‘bɔ:də]边框                                               4<br>bounds checking [baʊndz] [‘tʃekiŋ]边界检查<br>boxing 装箱、装箱转换<br>brace [breis]大括号 curly [‘kə:li] brace花括号<br>bracket [‘brækit] (square [skwεə] brakcet) 中括号、方括号<br>breakpoint [‘breikpɔint]断点<br>browser applications [‘brauzə] [æpli’keiʃəns]浏览器应用(程序)<br>browser-accessible [ək’sesəbl] application 可经由浏览器访问的应用程序<br>build 编连(专指编译和连接<br>built-in [,bɪlt ‘ɪn]内建、内置<br>bus 总线<br>business 业务、商务(看场合)<br>business Logic [‘lɔdʒik]业务逻辑<br>business rules 业务规则<br>buttons 按钮<br>bug 臭虫<br>by/through 通过<br>byte 位元组(由8 bits组成)<br>cache [kæʃ] 高速缓存<br>calendar [‘kælində]日历<br>call 调用<br>callback [‘kɔ:lbæk] 回调<br>call-level interface (CLI)调用级接口(CLI)                            5<br>call operator 调用操作符<br>candidate key [‘kændideit] 候选键 (for database)<br>cascading delete [kæ’skeidiŋ] 级联删除 (for database)<br>cascading update 级联更新 (for database)<br>casting [‘kɑ:stiŋ]  转型、造型转换<br>catalog [‘kætəlɔɡ]  目录<br>chain [tʃein] 链(function calls)<br>character [‘kærəktə] 字符<br>character format [ˈfɔ:mæt]  字符格式<br>character set     字符集<br>CHECK constraints [kən’streint]    CHECK约束 (for database)<br>checkpoint [‘tʃekpɔint] 检查点 (for database)<br>check box 复选框<br>check button 复选按钮<br>child class 子类<br>CIL (common intermediate [,intə’mi:djət, -dieit] language)通用中间语言、通用中介语言<br>class    类<br>class declaration [,deklə’reiʃən] 类声明<br>class definition [,defi’niʃən]  类定义<br>class derivation [,deri’veiʃən] list 类继承列表<br>class factory    类厂                                        6<br>class hierarchy [‘haiə,rɑ:ki]类层次结构<br>class library    类库<br>class loader     类装载器<br>class template [‘templit]类模板<br>class template partial [‘pɑ:ʃəl] specializations [,spɛʃəlɪ’zeʃən] 类模板部分特化<br>class template specializations         类模板特化<br>classification [ˌklæsifiˈkeiʃən] 分类<br>clause [klɔ:z]子句<br>client [‘klaiənt] application 客户端应用程序<br>client cursor [‘kə:sə] 客户端游标 (for database)<br>code page 代码页<br>cleanup   清理、清除<br>CLI (Common Language Infrastructure [‘infrə,strʌktʃə])   通用语言基础设施<br>client [‘klaiənt]客户、客户端<br>client area 客户区<br>client-server 客户机/服务器、客户端/服务器<br>clipboard [‘klipbɔ:d]剪贴板<br>clone [kləun]克隆<br>CLS (common language specification [,spesifi’keiʃən]) 通用语言规范<br>code access security 代码访问安全<br>COFF (Common Object File Format)    通用对象文件格式             7<br>collection [kə’lekʃən]集合<br>COM (Component [kəm’pəunənt] Object Model) 组件对象模型<br>combo [‘kɔmbəu] box 组合框<br>command [kə’mɑ:nd] line 命令行<br>comment[ˈkɔment] 注释<br>commit [kə’mit]提交 (for database)<br>communication [kə,mju:ni’keiʃən]通讯<br>compatible [kəm’pætəbl]兼容<br>compiler [kəm’pail]编译器<br>compile time 编译期、编译时<br>component[kəm’pəunənt]组件<br>composite [‘kɔmpəzit] index 复合索引、组合索引 (for database)<br>composite key 复合键、组合键 (for database)<br>composition [,kɔmpə’ziʃən]复合、组合<br>concept [‘kɔnsept]概念<br>concrete[kən’kri:t, ‘kɔnkri:t]具体的<br>concrete class 具体类<br>concurrency [kən’kʌrənsi]并发、并发机制<br>constraint [kən’streint]约束 (for database)<br>configuration [kən,fiɡju’reiʃən]配置、组态<br>connection [kə’nekʃən] 连接 (for database)<br>connection pooling 连接池                                        8<br>console [kən’səul] 控制台<br>constant [‘kɔnstənt]常量<br>construct [kən’strʌkt]构件、成分、概念、构造（for language）<br>constructor (ctor) [kɔn’strʌktə]构造函数、构造器<br>container [kən’teinə] 容器<br>containment[kən’teinmənt]包容<br>context [‘kɔntekst]环境、上下文<br>control [kən’trəul]控件<br>cookie [‘kuki] (不译)<br>copy    拷贝<br>CORBA   通用对象请求中介架构<br>(Common Object Request[ri’kwest] Broker Architecture)<br>cover   覆盖、涵盖<br>create/creation [kri:’eiʃən]创建、生成<br>crosstab query [‘kwiəri]交叉表查询 (for database)<br>CRTP<br>(curiously recurring [rɪ’kɝɪŋ] template [‘templit] pattern [‘pætən])<br>CTS (common type system)通用类型系统<br>cube [kju:b]多维数据集 (for database)<br>cursor [‘kə:sə] 光标<br>cursor 游标 (for database)<br>custom [‘kʌstəm] 定制、自定义                            9<br>data   数据<br>data connection   数据连接 (for database)<br>Data Control Language (DCL) 数据控制语言(DCL) (for database)<br>Data Definition [,defi’niʃən] Language (DDL) 数据定义语言(DDL) (for database)<br>data dictionary [‘dikʃənəri]数据字典 (for database)<br>data dictionary view 数据字典视图 (for database)<br>data file 数据文件 (for database)<br>data integrity [inˈteɡriti] 数据完整性 (for database)<br>data manipulation [mə,nipju’leiʃən] language (DML)数据操作语言(DML) (for database)<br>data mart 数据集市 (for database)<br>data pump [pʌmp]数据抽取 (for database)<br>data scrubbing [skrʌbliŋ]数据清理 (for database)<br>data source [sɔ:s]数据源 (for database)<br>Data source name (DSN) 数据源名称(DSN) (for database)<br>data warehouse [‘wεəhaus, ‘wεəhauz, -haus]数据仓库 (for database)<br>dataset   数据集 (for database)<br>database 数据库 (for database)<br>database catalog 数据库目录 (for database)<br>database diagram [‘daiəɡræm] 数据关系图 (for database)<br>database file     数据库文件 (for database)                        10<br>database object   数据库对象 (for database)<br>database owner    数据库所有者 (for database)<br>database project [‘prɔdʒekt]数据库工程 (for database)<br>database role     数据库角色 (for database)<br>database schema [‘ski:mə]数据库模式、数据库架构 (for database)<br>database script [skript]数据库脚本 (for database)<br>data-bound       数据绑定 (for database)<br>data-aware control数据感知控件 (for database)<br>data member   数据成员、成员变量<br>dataset       数据集 (for database)<br>data source   数据源 (for database)<br>data structure[‘strʌktʃə]数据结构<br>data table    数据表 (for database)<br>datagram [‘deitəɡræm]数据报文<br>DBMS (database management system)数据库管理系统 (for database)<br>DCOM (distributed [di’stribjutid] COM)分布式COM<br>dead lock 死锁 (for database)<br>Deallocate [de’elkeit]归还<br>debug      调试<br>debugger    调试器<br>decay [di’kei]退化<br>decision [di’siʒən] support [sə’pɔ:t] 决策支持                11<br>declaration [,deklə’reiʃən]声明<br>Declarative[dɪˈklærətɪv]referential [,refə’renʃəl] integrity [in’teɡrəti] (DRI)声明引用完整性(DRI) (for database)<br>deduction [di’dʌkʃən]推导<br>Deafault [di’fɔ:lt] constraint默认约束 (for database)<br>default database 默认数据库 (for database)<br>default instance [‘instəns]默认实例 (for database)<br>default result set 默认结果集 (for database)<br>default     缺省、默认值<br>defer       推迟<br>definition [,defi’niʃən]定义<br>delegate [‘deliɡeit]委托<br>delegation 委托<br>dependent name<br>deploy [di:’plɔi]部署<br>dereference [di’refərəns]解引用<br>dereference operator (提领)运算子<br>derived class 派生类<br>design by contract 契约式设计<br>design pattern [‘pætən]设计模式<br>destroy [di’strɔi]销毁<br>destructor(dtor) [di’strʌktə]析构函数、析构器                12<br>device [di’vais]设备<br>DHTML<br>(dynamic [dai’næmik]HyperText [‘haipətekst] Markup Language)动态超文本标记语言<br>dialog [‘daiəlɔɡ]对话框<br>digest[daiˈdʒest]摘要<br>digital 数字的<br>DIME<br>(Direct Internet Message Encapsulation [in,-kæpsə’leiʃən])<br>直接Internet消息封装<br>directive [di’rektiv, dai-] (编译)指示符<br>directory [di’rektəri, dai-]目录<br>dirty pages脏页 (for database)<br>dirty read 脏读 (for database)<br>disassembler [,disə’semblə]反汇编器<br>DISCO (Discovery of Web Services)Web Services的查找<br>disk 盘<br>dispatch [dis’pætʃ]调度、分派、派发（我喜欢“调度”）<br>DISPID (Dispatch[dis’pætʃ] Identifier [ai’dentifaiə])分派标识符<br>distributed [di’stribjutid] computing [kəm’pju:tiŋ]分布式计算<br>distributed query分布式查询 (for database)<br>DNA (Distributed interNet Application)                            13<br>分布式网间应用程序<br>document [‘dɔkjumənt, ‘dɔkjument]文档<br>DOM (Document Object Model)文档对象模型<br>dot operator [‘ɔpəreitə] (圆)点操作符<br>driver 驱动(程序)<br>DTD (document type definition [,defi’niʃən]) 文档类型定义<br>double-byte character set (DBCS)双字节字符集(DBCS)<br>dump [dʌmp] 转储<br>dump file 转储文件<br>dynamic [dai’næmik] cursor [‘kə:sə]动态游标 (for database)<br>dynamic filter [filtə]动态筛选 (for database)<br>dynamic locking   动态锁定 (for database)<br>dynamic recovery [ri’kʌvəri] 动态恢复 (for database)<br>dynamic snapshot [‘snæpʃɔt] 动态快照 (for database)<br>dynamic SQL statements [‘steitmənt]动态SQL语句 (for database)<br>dynamic assembly 动态装配件、动态配件<br>dynamic binding 动态绑定<br>EAI (enterprise[ˈentəpraɪz] application integration [,inti’ɡreiʃən])企业应用程序集成(整合)<br>EBCO (empty base class optimization [,ɔptimai’zeiʃən, -mi’z-])空基类优化（机制）<br>e-business   电子商务                                  14<br>EDI (Electronic [,ilek’trɔnik] Data Interchange [,intə’tʃeindʒ, ‘intətʃeindʒ])电子数据交换<br>efficiency [i’fiʃənsi]效率<br>efficient [i’fiʃənt]高效<br>end-to-end authentication [ɔː,θentɪ’keɪʃən] 端对端身份验证<br>end user 最终用户<br>engine   引擎<br>entity [‘entəti] 实体<br>encapsulation [in,-kæpsə’leiʃən]封装<br>enclosing [ɪn’kləʊziŋ] class 外围类别(与巢状类别 nested class有关)<br>enum (enumeration [i,nju:mə’reiʃən]) 枚举<br>enumerators [i’nju:mə,reitəz] 枚举成员、枚举器<br>equal [‘i:kwəl]相等<br>equality[i:’kwɔləti]相等性<br>equality operator 等号操作符<br>error[‘erə] log错误日志 (for database)<br>escape code 转义码<br>escape character 转义符、转义字符<br>exclusive [ik’sklu:siv] lock   排它锁 (for database)<br>explicit [ik’splisit] transaction [træn’zækʃən] 显式事务 (for database)<br>evaluate [i’væljueit]评估<br>event    事件                                          15<br>event driven 事件驱动的<br>event handler [‘hændlə]事件处理器<br>evidence [‘evidəns]证据<br>exception [ik’sepʃən] 异常<br>exception declaration [,deklə’reiʃən]异常声明<br>exception handling [‘hændliŋ]异常处理、异常处理机制<br>exception-safe 异常安全的<br>exception specification [,spesifi’keiʃən]异常规范<br>exit     退出<br>explicit [ik’splisit] 显式<br>explicit specialization [,speʃəlai’zeiʃən] 显式特化<br>export [ik’spɔ:t]导出<br>expression [ik’spreʃən]表达式<br>facility [fə’siliti] 设施、设备<br>fat client 胖客户端<br>feature [‘fi:tʃə]特性、特征<br>fetch [fetʃ]提取<br>field 字段(java)<br>field 字段 (for database)<br>field length 字段长度 (for database)<br>file   文件<br>filter [filtə]筛选 (for database)                                16<br>finalization [ˌfaɪnl’aɪzeʃən] 终结<br>firewall [‘faiəwɔ:l] 防火墙<br>finalizer [‘faɪnəlaɪzə] 终结器<br>firmware [‘fə:mwεə]固件<br>flag     标记<br>flash memory 闪存<br>flush [flʌʃ] 刷新<br>font 字体<br>foreign key (FK) 外键(FK) (for database)<br>form   窗体<br>formal parameter [pə’ræmitə] 形参<br>forward declaration 前置声明<br>forward-only 只向前的<br>forward-only cursor 只向前游标 (for database)<br>fragmentation [,fræɡmen’teiʃən] 碎片 (for database)<br>framework [‘freimwə:k] 框架<br>full specialization 完全特化<br>function 函数<br>function call operator (即operator ()) 函数调用操作符<br>function object 函数对象<br>function overloaded [‘əuvə’ləudid] resolution[,rezə’lu:ʃən]函数重载决议<br>functionality [,fʌŋkʃə’næliti]功能                                 17<br>function template函数模板<br>functor [‘fʌŋktə]仿函数<br>GAC (global assembly cache [kæʃ])<br>全局装配件缓存、全局配件缓存<br>GC (Garbage collection)<br>垃圾回收(机制)、垃圾收集(机制)<br>game游戏<br>generate [‘dʒenəreit]生成<br>generic [dʒi’nerik]泛化的、一般化的、通用的<br>generic algorithm[‘ælɡəriðəm]通用算法<br>genericity [‘dʒenerisity] 泛型<br>getter (相对于 setter)取值函数<br>global [‘ɡləubəl]全局的<br>global object 全局对象<br>global scope [skəup] resolution operator 全局范围解析操作符<br>grant [ɡrɑ:nt, ɡrænt]授权 (for database)<br>granularity[ˌɡrænjuˈlæriti] 粒度<br>group       组、群<br>group box   分组框<br>GUI   图形界面<br>GUID (Globally Unique [ju:’ni:k] Identifier [ai’dentifaiə]) 全球唯一标识符<br>hand shaking   握手                                       18<br>handle     句柄<br>handler    处理器<br>hard-coded 硬编码的<br>hard-copy 截屏图<br>hard disk 硬盘<br>hardware   硬件<br>hash table 散列表、哈希表<br>header file头文件<br>heap [hi:p]堆<br>help file 帮助文件<br>hierarchy [‘haiə,rɑ:ki]层次结构、继承体系<br>hierarchical [,haiə’rɑ:kikəl] data 阶层式数据、层次式数据<br>hook[huk]钩子<br>Host (application)宿主(应用程序)<br>hot key   热键<br>hyperlink [‘haipəliŋk]超链接<br>HTML (HyperText [‘haipətekst] Markup Language) 超文本标记语言<br>HTTP pipeline [‘paip,lain]    HTTP管道<br>HTTP (HyperText Transfer Protocol) 超文本传输协议<br>icon   图标<br>IDE (Integrated Development Environment)集成开发环境<br>IDL (Interface Definition Language)    接口定义语言               19<br>identifier [ai’dentifaiə]标识符<br>idle [‘aidl] time 空闲时间<br>if and only if当且仅当<br>IL (Intermediate Language) 中间语言、中介语言<br>image 图象<br>IME   输入法<br>immediate [i’mi:diət] base      直接基类<br>immediate derived [di’raivd]   直接派生类<br>immediate updating 即时更新 (for database)<br>implicit [im’plisit] transaction [træn’zækʃən]隐式事务 (for database)<br>incremental[ˌɪŋkrəˈmentl] update 增量更新 (for database)<br>index          索引 (for database)<br>implement [‘implimənt, ‘impliment]实现<br>implementation [,implimen’teiʃən] 实现、实现品<br>implicit [im’plisit]隐式<br>import         导入<br>increment [‘inkrimənt] operator 增加操作符<br>infinite [‘infinət] loop       无限循环<br>infinite recursive [ri’kə:siv] 无限递归<br>information      信息<br>infrastructure [‘infrə,strʌktʃə]基础设施<br>inheritance [in’heritəns]继承、继承机制                        20<br>inline [‘in,lain]内联<br>inline expansion 内联展开<br>initialization [i,niʃəlai’zeiʃən]初始化<br>initialization list 初始化列表、初始值列表<br>initialize [ɪ’nɪʃəlaɪz]初始化<br>inner [‘inə] join      内联接 (for database)<br>in-place active 现场激活<br>instance [‘instəns]实例<br>instantiated [ɪns’tænʃɪetid]    具现化、实体化(常应用于template)<br>instantiation[inˌstænʃiˈeiʃən]具现体、具现化实体(常应用于template)<br>integrate [ˈɪntɪgreɪt]       集成、整合<br>integrity [ɪnˈtegrəti]      完整性、一致性<br>integrity constraint完整性约束 (for database)<br>interprocess communication (IPC)进程间通讯(IPC)<br>interacts [,intə’rækts]交互<br>interface 接口<br>for GUI 界面<br>interoperability[ˈintərˌɔpərəˈbiləti]<br>互操作性、互操作能力<br>interpreter [in’tə:pritə]解释器<br>introspection [,intrəu’spekʃən]自省<br>invariants [in’vεəriənts]不变性                                  21<br>invoke [in’vəuk]调用<br>isolation [ˌaɪsəˈleɪʃn] level 隔离级别 (for database)<br>iterate [‘itəreit]迭代<br>iterative [‘itərətiv]反复的、迭代的<br>iterator [ɪtə’retɚ]迭代器<br>iteration [,itə’reiʃən] 迭代(回圈每次轮回称为一个iteration)<br>item      项、条款、项目<br>JIT compilation [ˌkɔmpəˈleɪʃən] JIT编译 即时编译<br>key          键 (for database)<br>key column   键列 (for database)<br>laser        激光<br>late binding 迟绑定<br>left outer join 左向外联接 (for database)<br>level      阶、层例<br>high level 高阶、高层<br>library    库<br>lifetime   生命期、寿命<br>link       连接、链接<br>linkage [‘liŋkidʒ]连接、链接<br>linker     连接器、链接器<br>literal [‘litərəl] constant 字面常数<br>list   列表、表、链表                                       22<br>list box 列表框<br>livelock 活锁 (for database)<br>load   装载、加载<br>load balancing [‘bælənsiŋ] 负载平衡<br>loader 装载器、载入器<br>local 局部的<br>local object    局部对象<br>lock 锁<br>log   日志<br>login 登录<br>login security mode登录安全模式 (for database)<br>lookup table   查找表 (for database)<br>loop [lu:p]循环<br>loose coupling [‘kʌpliŋ] 松散耦合<br>lvalue         左值<br>machine code   机器码、机器代码<br>macro [‘mækrəu]宏<br>maintain [mein’tein]维护<br>managed code 受控代码、托管代码<br>Managed Extensions [ik’stenʃəns] 受控扩充件、托管扩展<br>managed object 受控对象、托管对象<br>mangled [‘mæŋg(ə)l] name                                       23<br>manifest [‘mænifest]清单<br>manipulator [mə’nipjuleitə]操纵器(iostream预先定义的一种东西)<br>many-to-many relationship 多对多关系 (for database)<br>many-to-one relationship 多对一关系 (for database)<br>marshal [‘mɑ:ʃəl]列集<br>member   成员<br>member access operator    成员取用运算子(有dot和arrow两种)<br>member function           成员函数<br>member initialization list成员初始值列表<br>memberwise 以member为单元…、members 逐一…<br>memberwise copy<br>memory      内存<br>memory leak 内存泄漏<br>menu     菜单<br>message 消息<br>message based 基于消息的<br>message loop   消息环<br>message queuing[kjuiŋ]消息队列<br>metadata [‘metədeɪtə] 元数据<br>metaprogramming[mɛtə’prəuɡræmiŋ]元编程<br>method [‘meθəd]方法<br>micro 微                                                 24<br>middleware 中间件<br>middle tier中间层<br>modeling [‘mɔdəliŋ]建模<br>modeling language 建模语言<br>modifier [‘mɔdifaiə]修饰字、修饰符<br>modem[ˈməudem]调制解调器<br>module [‘mɔdju:l]模块<br>most derived [di’raivd] class最底层的派生类<br>mouse   鼠标<br>mutable [‘mju:təbl]可变的<br>mutex[‘mjutex]   互斥元、互斥体<br>multidimensional [ˌmʌltidiˈmenʃənl] OLAP (MOLAP)    多维OLAP(MOLAP) (for database)<br>multithreaded[ˌmʌltidiθ’redid] server application 多线程服务器应用程序<br>multiuser [,mʌlti’ju:zə]多用户<br>multi-tasking   多任务<br>multi-thread    多线程<br>multicast [‘mʌltikɑ:st] delegate [‘deliɡət] 组播委托、多点委托<br>named parameter    命名参数<br>named pipe 命名管道<br>namespace   名字空间、命名空间<br>native      原生的、本地的                           25<br>native code 本地码、本机码<br>Native Image Generator [‘dʒenəreitə] (NGEN)本地映像生成器<br>nested [‘nestid] class 嵌套类<br>nested query 嵌套查询 (for database)<br>nested table 嵌套表 (for database)<br>network       网络<br>network card 网卡<br>nondependent name<br>object        对象<br>object based 基于对象的<br>object file   目标文件<br>object model 对象模型<br>object oriented 面向对象的<br>object pooling 对象池化<br>ODBC data source         ODBC数据源 (for database)<br>ODBC driver      ODBC驱动程序 (for database)<br>ODR (one-definition rule)<br>OLE Automation [,ɔ:tə’meiʃən] objects<br>OLE自动化对象 (for database)<br>OLE Automation [ˌɔ:təˈmeiʃən] server<br>OLE(Object Linking and Embedding [im’bediŋ])<br>自动化服务器 (for database)                                 26<br>OLE DB consumer [kən’sju:mə]<br>OLE DB使用者 (for database)<br>OLE DB for OLAP 用于OLAP的OLE DB (for database)<br>OLE DB provider OLE         DB提供者 (for database)<br>one-to-many relationship 一对多关系 (for database)<br>one-to-one relationship 一对一关系 (for database)<br>online analytical [ˌænəˈlɪtɪkl] processing (OLAP)    联机分析处理(OLAP) (for database)<br>online redo[ri:ˈdu:] log     联机重做日志 (for database)<br>online transaction processing (OLTP)   联机事务处理(OLTP) (for database)<br>Open Data Services (ODS)   开放式数据服务(ODS) (for database)<br>Open Database Connectivity [,kɔnek’tivəti] (ODBC) 开放式数据库连接(ODBC) (for database)<br>operand [‘ɔpərænd] 操作数<br>operating system (OS) 操作系统<br>operation 操作<br>operator   操作符、运算符<br>option [‘ɔpʃən]选项<br>optimizer [‘ɔptimaizə]优化器<br>outer join 外联接 (for database)<br>overflow [,əuvə’fləu]上限溢位(相对于underflow)<br>overhead   额外开销                                         27<br>overload   重载<br>overload resolution   重载决议<br>overloaded function   重载的函数<br>overloaded operator 被重载的操作符<br>override [,əuvə’raid]覆写、重载、重新定义<br>package [‘pækidʒ]包<br>packaging 打包<br>palette [‘pælit]调色板<br>parallel [‘pærəlel]并行<br>parameter [pə’ræmitə]参数、形式参数、形参<br>parameter list 参数列表<br>parameterize [pə’ræmitəraiz]参数化<br>parent class   父类<br>parentheses[pəˈrenθɪsɪsiz]    圆括弧、圆括号<br>parse [pɑ:z]解析<br>parser [‘pɑ:sə]解析器<br>part     零件、部件<br>partial specialization 局部特化<br>pass by address   传址(函式引数的传递方式)(非正式用语)<br>pass by reference 传地址、按引用传递<br>pass by value 按值传递<br>pattern [‘pætən] 模式                                          28<br>PDA (personal digital [‘didʒitəl] assistant)个人数字助理<br>PE (Portable Executable[ˈeksikju:təbl]) file   可移植可执行文件<br>performance [pə’fɔ:məns]性能<br>persistence [pə’sistəns]持久性<br>PInvoke (platform invoke service) 平台调用服务<br>pixel [‘piksəl]像素<br>placement [‘pleismənt] delete<br>placement new<br>placeholder [‘pleis,həuldə]占位符<br>platform [‘plætfɔ:m]平台<br>POD (plain old data (type)) 简单旧数据类型<br>POI (point of instantiation [in,stænʃieiʃən])<br>pointer 指针<br>poll [pəul]轮询<br>pooling 池化<br>polymorphism [,pɒlɪ’mɔːfɪz(ə)m]多态<br>pop up     弹出式<br>port [pɔ:t, pəut]端口<br>postfix [‘pəustfiks]后缀<br>precedence [‘presidəns, pri’si:-]优先序(通常用于运算子的优先执行次序)<br>prefix [,pri:’fiks, ‘pri:fiks]前缀<br>preprocessor [,priː’prəʊsesə]预处理器                           29<br>primary key (PK)主键(PK) (for database)<br>primary table   主表 (for database)<br>primary template原始模板<br>primitive [‘primitiv] type 原始类型<br>print      打印<br>printer    打印机<br>procedure [prə’si:dʒə]过程<br>procedural [prə’si:dʒərəl] 过程式的、过程化的<br>process    进程<br>profile [‘prəufail]评测<br>profiler [‘prəufailə]效能(性能)评测器<br>program    程序<br>programmer 程序员<br>programming编程、程序设计<br>progress bar 进度指示器<br>project    项目、工程<br>property   属性<br>protocol [‘prəutəkɔl]协议<br>pseudo [‘psju:dəu] code伪码<br>qualified [‘kwɔlifaid] 经过资格修饰(例如加上scope运算子)<br>qualified name<br>qualifier [‘kwɔlifaiə]修饰符                                      30<br>quality   质量<br>queue [kju:]队列<br>race condition 竞争条件（多线程环境常用语）<br>radian [‘reidiən]弧度<br>radio button   单选按钮<br>raise [reiz]引发(常用来表示发出一个exception)<br>random number 随机数<br>range   范围、区间<br>rank    等级<br>raw [rɔ:]未经处理的<br>readOnly只读<br>record 记录 (for database)<br>recordset [‘rekɔdset] 记录集 (for database)<br>recursive [ri’kə:siv]递归<br>re-direction 重定向<br>refactoring [ri’fæktəriŋ]   重构<br>refer     引用、参考<br>reference 引用、参考<br>reference counting引用计数<br>referential [,refə’renʃəl] integrity [in’teɡrəti] (RI)引用完整性(RI) (for database)<br>register [‘redʒistə]寄存器<br>reflection   反射                                       31<br>refresh data 刷新数据 (for database)<br>regular expression 正则表达式<br>relational database 关系数据库<br>remote         远程<br>remote request 远程请求<br>represent      表述，表现<br>resolve        解析、决议<br>resolution [,rezə’lu:ʃən]解析过程<br>result set     结果集 (for database)<br>retrieve [ri’tri:v] data 检索数据<br>return         返回<br>return type    返回类型<br>return value   返回值<br>right outer join 右向外联接 (for database)<br>revoke [ri’vəuk]撤销<br>robust [rəu’bʌst]健壮<br>robustness [rəʊ’bʌstnɪs]健壮性<br>roll back    回滚 (for database)<br>roll forward 前滚 (for database)<br>routine [ru:’ti:n]例程<br>row          行 (for database)<br>row lock     行锁 (for database)                                32<br>rowset       行集 (for database)<br>RPC (remote [ri’məut] procedure call)RPC(远程过程调用)<br>runtime 执行期、运行期、执行时、运行时<br>rvalue 右值<br>save    保存<br>savepoint 保存点 (for database)<br>SAX (Simple API for XML)<br>scalable [‘skeiləbl]可伸缩的、可扩展的<br>schedule [‘ʃədju:əl] 调度<br>scheduler [‘ʃedju:ələ] 调度程序<br>schema [‘ski:mə]模式、纲目结构<br>scroll bar滚动条<br>scope [skəup]作用域、生存空间<br>scope operator 生存空间操作符<br>scope resolution [,rezə’lu:ʃən] operator 生存空间解析操作符<br>screen   屏幕<br>SDK (Software Development Kit)软件开发包<br>sealed [si:ld] class 密封类<br>search [sə:tʃ]查找<br>semantics [si’mæntiks]语义<br>semaphore [ˈseməˌfɔ:,信号量<br>sequential [si’kwenʃəl]  container序列式容器                  33<br>server    服务器、服务端<br>serial [‘siəriəl]串行<br>serialization [,siəriəlai’zeiʃən ]/serialize 序列化<br>server cursor服务端游标、服务器游标 (for database)<br>session      会话 (for database)<br>setter [‘setə]设值函数<br>shared lock 共享锁 (for database)<br>sibling [‘sibliŋ]同级<br>side effect 副作用<br>signature [‘signətʃə]签名<br>single-threaded 单线程<br>slider[‘slaidə]滑块<br>slot [slɔt] 槽<br>smart pointer [‘pɔintə] 智能指针<br>SMTP (Simple Mail Transfer Protocol)   简单邮件传输协议<br>snapshot [‘snæpʃɔt]截屏图<br>snapshot       快照 (for database)<br>specialization [,speʃəlai’zeiʃən] 特化<br>specification [,spesifi’keiʃən]规范、规格<br>splitter       切分窗口<br>SOAP (simple object access protocol [‘prəutəkɔl])   简单对象访问协议<br>software      软件                                         34<br>source code   源码、源代码<br>SQL (Structured [‘strʌktʃəd] Query Language) 结构化查询语言 (for database)<br>stack [stæk]栈、堆栈<br>stack unwinding [ʌn’waindiʃ]叠辗转开解(此词用于exception主题)<br>standard library 标准库<br>standard template library 标准模板库<br>stateless [‘steɪtlɪs]无状态的<br>statement [‘steitmənt]语句、声明<br>static cursor 静态游标 (for database)<br>static SQL statements 静态SQL语句 (for database)<br>stored [stɔ:d]  procedure 存储过程 (for database)<br>status [‘steitəs]  bar 状态条<br>stream [stri:m]流<br>string   字符串<br>stub     存根<br>subobject[‘sʌb’ɔbdʒikt]子对象<br>subquery 子查询 (for database)<br>subroutine [‘sʌbruːtiːn]子例程<br>subscript operator 下标操作符<br>subset   子集<br>subtype 子类型<br>support 支持                                               35<br>suspend [sə’spend]挂起<br>symbol   记号<br>syntax [‘sintæks]语法<br>system databases   系统数据库 (for database)<br>system tables      系统表 (for database)<br>table       表 (for database)<br>table lock 表锁 (for database)<br>table-level constraint 表级约束 (for database)<br>tape backup 磁带备份 (for database)<br>target 标的,目标<br>task switch 工作切换<br>TCP (Transport Control Protocol [‘prəutəkɔl])传输控制协议<br>template [‘templit]模板<br>template-id<br>template argument deduction [di’dʌkʃən]模板参数推导<br>template explicit [ik’splisit] specialization 模板显式特化<br>template parameter   模板参数<br>template template parameter<br>temporary [‘tempərəri] object 临时对象<br>temporary table 临时表 (for database)<br>text 文本<br>text file   文本文件                                        36<br>thin client 瘦客户端<br>third-party 第三方<br>thread      线程<br>thread-safe 线程安全的<br>throw 抛出、引发(常指发出一个exception)<br>token 符号、标记、令牌（看场合）<br>trace 跟踪<br>transaction [træn’zækʃən] 事务 (for database)<br>transaction log 事务日志 (for database)<br>transaction rollback [‘rəulbæk]事务回滚 (for database)<br>transactional replication [,repli’keiʃən]事务复制 (for database)<br>translation unit 翻译单元<br>traverse [‘trævəs, -və:s, trə’və:s, træ-]遍历<br>trigger [‘triɡə]触发器 (for database)<br>two-phase [feiz] commit 两阶段提交 (for database)<br>tuple [‘tʌpl] n. 元组，重数<br>two-phase [feiz] lookup 两阶段查找<br>type 类型<br>UDDI(Universary [feiz] Description, Discovery and Integration [,inti’ɡreiʃən])统一描述、查询与集成<br>UML (unified [‘ju:nifaid] modeling language)统一建模语言<br>unary [‘ju:nəri] function 单参函数                                  37<br>unary operator 一元操作符<br>unboxing [,ʌn’bɔks ɪŋ]箱、拆箱转换<br>underflow      下限溢位(相对于overflow)<br>Union [‘ju:niən] query    联合查询 (for database)<br>UNIQUE [ju:’ni:k] constraints UNIQUE约束 (for database)<br>unique index   唯一索引 (for database)<br>unmanaged code 非受控代码、非托管代码<br>unmarshal[[ʌn ‘mɑrʃəl]]      散集<br>unqualified [,ʌn’kwɔlifaid]未经限定的、未经修饰的<br>URI (Uniform Resource identifier [ai’dentifaiə]) 统一资源标识符<br>URL (Uniform Resource Locator)    统一资源定位器<br>user            用户<br>user interface 用户界面<br>value types 值类型<br>variable [‘vεəriəbl]变量<br>vector [‘vektə]向量(一种容器，有点类似array)<br>viable [‘vaiəbl]可行的<br>video    视频<br>view     视图<br>VEE (Virtual Execution Engine)虚拟执行引擎<br>vendor [‘vendɔ:]厂商<br>view    视图 (for database)                                    38<br>virtual function 虚函数<br>virtual machine   虚拟机<br>virtual memory    虚拟内存<br>vowel [‘vauəl] 元音字母<br>Web Services   web服务<br>WHERE clause   WHERE子句 (for database)<br>wildcard [‘waildka:d]  characters 通配符字符 (for database)<br>wildcard search     通配符搜索 (for database)<br>window              窗口<br>window function     窗口函数<br>window procedure    窗口过程<br>Windows authentication [ɔː,θentɪ’keɪʃən] Windows身份验证<br>wizard [‘wizəd]向导<br>word    单词<br>word processor 字处理器<br>wrapper [‘ræpə]包装、包装器<br>write enable[iˈneibl] 写启用 (for database)<br>write-ahead log 预写日志 (for database)<br>write-only只写<br>WSDL (Web Service Description Language)Web Service描述语言<br>XML(eXtensible [ik’stensəbl] Message Interface (XMI)<br>XML消息接口-                                               39<br>XML (extensible Markup Language) 可扩展标记语言<br>XSD (XML Schema [‘ski:mə] Definition) XML模式定义语言<br>XSL (extensible Stylesheet Language) 可扩展样式表语言<br>XSLT (extensible Stylesheet Language Transformation)可扩展样式表语言转换<br>xxx based     基于xxx的<br>xxx oriented 面向xxx<br>网址：(<a href="http://www.ryedu.net/syy/hyyy/200912/15824_2.html" target="_blank" rel="external">http://www.ryedu.net/syy/hyyy/200912/15824_2.html</a>)</p>
<p>application [ˌæplɪ’keɪʃ(ə)n]应用程式 应用、应用程序<br>application framework[‘freɪmwɜːk] 应用程式框架、应用框架 应用程序框架<br>architecture[‘ɑːkɪtektʃə] 架构、系统架构 体系结构<br>argument [‘ɑːgjʊm(ə)nt]引数（传给函式的值）<br>parameter 叁数、实质叁数、实叁、自变量<br>array [ə’reɪ] 阵列 数组<br>arrow [‘ærəʊ] 箭头<br>operator [‘ɔpəreitə] arrow运算子 箭头操作符<br>assembly [ə’semblɪ]装配件<br>assembly language [‘læŋgwɪdʒ]组合语言 汇编语言<br>assert(ion) [ə’sɜːt] [ə’sɜːʃ(ə)n]断言<br>assign [ə’saɪn]指派、指定、设值、赋值 赋值<br>assignment [ə’saɪnm(ə)nt]指派、指定 赋值、分配<br>assignment operator [‘ɒpəreɪtə]指派（赋值）运算子 = 赋值操作符<br>associated [ə’soʃɪetɪd]相应的、相关的 相关的、关联、相应的<br>associative [ə’səʊʃɪətɪv] container [kən’teɪnə]关联式容器<br>sequential container 关联式容器<br>atomic [ə’tɔmik]不可分割的 原子的<br>attribute [ə’trɪbjuːt] 属性、特性<br>audio [‘ɔːdɪəʊ]音讯 音频<br>A.I. 人工智慧 人工智能（artificial [ɑ:ti’fiʃəl] intelligence [ɪn’telɪdʒ(ə)ns]）<br>background [‘bækgraʊnd]背景 背景（用於图形着色）<br>backward [‘bækwəd] compatible [kəm’pætɪb(ə)l]回溯相容 向下兼容<br>bandwidth [‘bændwidθ]频宽 带宽<br>base [beis] class [klɑːs]基础类别 基类<br>base type [taip]基础型别 (等同於 base class)<br>batch [bætʃ]批次（意思是整批作业） 批处理<br>benefit [‘benɪfɪt]利益 收益<br>best [best] viable [‘vaiəbl] function [‘fʌŋ(k)ʃ(ə)n]最佳可行函式<br>binary [‘baɪnərɪ] search [sɜːtʃ]二分搜寻法 二分查找<br>binary tree [triː]二元树 二叉树<br>binary function 二元函式 双叁函数<br>binary operator [‘ɒpəreɪtə]二元操作符<br>binding [‘baɪndɪŋ]系结 绑定<br>bit <a href="发音为beit">bɪt</a>位元 位<br>bit field [fiːld]位元栏 位域<br>bitmap [‘bɪtmæp]位元图 位图<br>bitwise 以 bit 为单元逐一┅<br>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝<br>block [英][blɔk]&nbsp;[美][blɑk]&nbsp;区块,区段 块、区块、语句块<br>boolean [‘bu:li:ən]布林值（真假值，true 或 false） 布尔值<br>border [‘bɔ:də]边框、框线 边框<br>curly [‘kə:li] brace [breis]大括弧、大括号 花括弧、花括号<br>square [skwεə] bracket [‘brækit]中括弧、中括号 方括弧、方括号<br>breakpoint [‘breikpɔint]中断点 断点<br>build [bild]建造、构筑、建置（MS 用语）<br>build－in 内建 内置<br>bus 汇流排 总线<br>business [‘bɪznɪs]商务,业务 业务<br>buttons [bʌtəns]按钮 按钮<br>byte [bait] 字节   位元组（由 8 bits 组成）<br>cache [kæʃ] 快取 高速缓存<br>call [kɔ:l] 调用 呼叫、叫用<br>callback [‘kɔ:lbæk] 回调 回呼<br>operator [‘ɔpəreitə] call（函式呼叫）运算子调用操作符 （同 function call operator）<br>candidate [‘kændidit] function 候选函式 候选函数 （在函式多载决议程序中出现的候选函式）<br>chain [tʃein]串链（例 chain of function calls）链<br>character [‘kærəktə] 字符 字元<br>check [tʃek] box复选框 核取方块 (i.e. check button)<br>checked [tʃekt] exception [ik’sepʃən]可控式异常 (Java)<br>check button [‘bʌtən] 复选按钮 方钮 (i.e. check box)<br>child [tʃaild] class 子类别（或称为derived [di’raivd] class, subtype [‘sʌbtaip] 图表类型） 子类<br>class [klɑ:s]类别 类<br>class body 类别本体 类体<br>class declaration [,deklə’reiʃən] 类声明 类别宣告、类别宣告式<br>class definition [,defi’niʃən] 类定义 类别定义、类别定义式<br>class derivation [,deri’veiʃən] list类继承列表 类别衍化列<br>class head [hed] 类头 类别表头<br>class hierarchy [‘haiərɑ:ki]类别继承体系, 类别阶层 类层次体系<br>class library [‘laibrəri] 类库 类别程式库、类别库<br>class template [‘templit]类别模板、类别范本 类模板<br>class template partial [‘pɑ:ʃəl] specializations [‘speʃəlaiz]类别模板偏特化 类模板部分特化<br>class template specializations 类别模板特化 类模板特化<br>cleanup [‘kli:nʌp]清理、善後 清理、清除<br>client [‘klaiənt] 客户端、客端、客户 客户<br>client－server [‘sə:və]主从架构 客户/服务器<br>clipboard [‘klipbɔ:d] 剪贴板 剪贴簿<br>clone [kləun]复制 克隆<br>collection [kə’lekʃən] 集合 群集<br>combo [‘kɔmbəu] box [bɔks]复合方块 复合框 组合框<br>command [kə’mɑ:nd] line [lain] 命令行 命令列 (系统文字模式下的整行执行命令)<br>communication [kə,mju:ni’keiʃən]通讯<br>compatible [kəm’pætəbl] 兼容 相容<br>compile [kəm’pail]time 编译期 编译期、编译时<br>compiler [kəm’pailə]编译器 编译器<br>component [kəm’pəunənt]组件 组件<br>composition[,kɔmpə’ziʃən]  复合、合成、组合 组合<br>computer [kəm’pju:tə]电脑、计算机 计算机、电脑<br>concept [‘kɔnsept]概念 概念<br>concrete [kən’kri:t]具象的 实在的<br>concurrent [kən’kʌrənt]并行 并发<br>configuration [kən,fiɡju’reiʃən] 配置 组态<br>connection [kə’nekʃən]连接，连线（网络,资料库） 连接<br>constraint[kən’streint]  约束（条件）<br>construct [kən’strʌkt]构件 构件<br>container [kən’teinə]容器 容器 （存放资料的某种结构如 list, vector…）<br>containment [kən’teinmənt]内含 包容<br>context[‘kɔntekst] 背景关系、周遭环境、上下脉络 环境、上下文<br>control [kən’trəul]控制元件、控件 控件<br>console [kən’səul]主控台 控制台<br>const [‘kɔnstənt]常数（constant 的缩写，C++ 关键字）<br>constant[‘kɔnstənt]  常数（相对於 variable） 常量<br>constructor[kɔn’strʌktə]（ctor） 建构式 构造函数 （与class 同名的一种 member functions）<br>copy[‘kɔpi] (v) 复制、拷贝 拷贝<br>copy (n) 复件, 副本<br>cover [‘kʌvə] 涵盖 覆盖<br>create [kri’eit]创建、建立、产生、生成 创建<br>creation [kri:’eiʃən]产生、生成 创建<br>cursor [‘kə:sə]游标 光标<br>custom [‘kʌstəm] 订制、自定 定制<br>data [‘deitə]资料 数据<br>database [‘deitəbeis]资料库 数据库<br>database schema [‘ski:mə] 数据库结构纲目<br>data member [‘membə] 资料成员、成员变数 数据成员、成员变量<br>data structure [‘strʌktʃə]资料结构 数据结构<br>datagram [‘deitəɡræm]资料元 数据报文<br>dead [ded] lock [lɔk]死结 死锁<br>debug [di:’bʌɡ]除错 调试<br>debugger [di:’bʌɡə]除错器 调试器<br>declaration [,deklə’reiʃən]宣告、宣告式 声明<br>deduction [di’dʌkʃən]推导（例：template argument deduction） 推导、推断<br>default [di’fɔ:lt]预设 缺省、默认<br>defer [di’fə:] 延缓 推迟<br>define [di’fain]定义 预定义<br>definition [,defi’niʃən]定义、定义区、定义式 定义<br>delegate [‘deliɡeit]委派、委托、委任 委托<br>delegation [,deli’ɡeiʃən] （同上）<br>demarshal 反编列 散集<br>dereference [di’refərəns]提领（取出指标所指物体的内容） 解叁考<br>operator dereference（提领）运算子 * 解叁考操作符<br>derived [di’raivd] class 衍生类别 派生类<br>design [di’zain] by contract [kən’trækt]契约式设计<br>design [di’zain] pattern [‘pætən] 设计范式、设计样式 设计模式<br>※ 最近我比较喜欢「设计范式」一词<br>destroy [di’strɔi] 摧毁、销毁<br>destructor [di’strʌktə] 解构式 析构函数<br>device [di’vais] 装置、设备 设备<br>dialog [‘daiəlɔɡ]对话窗、对话盒 对话框<br>directive [di’rektiv] 指令（例：using directive） (编译)指示符<br>directory [di’rektəri] 目录 目录<br>disk [disk] 碟 盘<br>dispatch [dis’pætʃ] 分派 分派<br>distributed [di’stribjutid] computing [kəm’pju:tiŋ] 分布式计算 (分布式电算) 分布式计算<br>分散式计算 (分散式电算)<br>document [‘dɔkjumənt]文件 文档<br>dot [dɔt] operator [‘ɔpəreitə] dot（句点）运算子 . (圆)点操作符<br>driver [draivə]驱动程式 驱动（程序）<br>dynamic [dai’næmik] binding [‘baindiŋ] 动态系结 动态绑定<br>efficiency [i’fiʃənsi] 效率 效率<br>efficient [i’fiʃənt]高效 高效<br>end [end] user [‘ju:zə]终端用户<br>entity [‘entəti] 物体 实体、物体<br>encapsulation [in,-kæpsə’leiʃən] 封装 封装<br>enclosing [in’kləuz] class 外围类别（与巢状类别 nested <a href="嵌套的">‘nestid</a> class 有关）外围类<br>enum (enumeration [i,nju:mə’reiʃən]) 枚举 列举（一种 C++ 资料型别）枚举<br>enumerators [i’nju:məreitə]列举元（enum 型别中的成员） 枚举成员、枚举器<br>equal [‘i:kwəl] 相等 相等<br>equality [i:’kwɔləti]相等性 相等性<br>operator [‘ɔpəreitə] equality（等号）运算子 == 等号操作符<br>equivalence [i’kwivələns] 等价性、等同性、对等性 等价性<br>equivalent [i’kwivələnt]等价、等同、对等 等价<br>escape [i’skeip] code 转义码 转义码<br>evaluate [i’væljueit] 评估、求值、核定 评估 </p>
<p>application 应用程式 应用、应用程序﻿<br>application framework 应用程式框架、应用框架 应用程序框架﻿<br>architecture 架构、系统架构 体系结构﻿<br>argument 参数（传给函式的值）。﻿<br>array 阵列 数组﻿<br>arrow operator arrow（箭头）运算子 箭头操作符﻿<br>assembly 装配件﻿<br>assembly language 组合语言 汇编语言﻿<br>assert(ion) 断言﻿<br>assign 指派、指定、设值、赋值 赋值﻿<br>assignment 指派、指定 赋值、分配﻿<br>assignment operator 指派（赋值）运算子 = 赋值操作符﻿<br>associated 相应的、相关的 相关的、关联、相应的﻿<br>associative container 关联式容器（对应 sequential container）关联式容器﻿<br>atomic不可分割的 原子的﻿<br>attribute 属性 属性、特性﻿<br>audio 音讯 音频﻿<br>A.I. 人工智慧 人工智能﻿<br>background 背景 背景（用於图形着色）後台（用於行程）﻿<br>backward compatible 回溯相容 向下兼容﻿<br>bandwidth 频宽 带宽﻿<br>base class 基础类别 基类﻿<br>base type 基础型别 (等同於﻿<br>base class) batch 批次（意思是整批作业） 批处理﻿<br>benefit 利益 收益﻿<br>best viable function 最佳可行函式 最佳可行函式﻿<br>binary search 二分搜寻法 二分查找﻿<br>binary tree 二元树 二叉树﻿<br>binary function 二元函式 双叁函数﻿<br>binary operator 二元运算子 二元操作符﻿<br>binding 系结 绑定﻿<br>bit 位元 位﻿<br>bit field 位元栏 位域﻿<br>bitmap 位元图 位图﻿<br>bitwise 以 bit 为单元逐一﻿<br>bitwise copy 以 bit 为单元进行复制；位元逐一复制 位拷贝﻿<br>block 区块,区段 块、区块、语句块﻿<br>boolean 布林值（真假值，true 或 false）布尔值<br>border 边框、框线 边框﻿<br>brace(curly brace) 大括弧、大括号 花括弧、花括号﻿<br>bracket(square bracket) 中括弧、中括号 方括弧、方括号﻿<br>breakpoint 中断点 断点﻿<br>build 建造、构筑、建置（MS 用语）﻿<br>build－in 内建 内置﻿<br>bus 汇流排 总线﻿<br>business 商务,业务 业务﻿<br>buttons 按钮 按钮﻿<br>byte 位元组（由 8 bits 组成） 字节﻿<br>cache 快取 高速缓存﻿<br>call 呼叫、叫用 调用﻿<br>callback 回呼 回调﻿<br>call operator call（函式呼叫）运算子调用操作符﻿<br>candidate function 候选函式 候选函数﻿<br>chain 串链（例 chain of function calls） 链﻿<br>character 字元 字符﻿<br>check box 核取方块 (i.e. check button) 复选框﻿<br>checked exception 可控式异常﻿<br>check button 方钮 (i.e. check box) 复选按钮﻿<br>child class 子类别（或称为derived class, subtype） 子类﻿<br>class 类别 类﻿<br>class body 类别本体 类体﻿<br>class declaration 类别宣告、类别宣告式 类声明﻿<br>class definition 类别定义、类别定义式 类定义﻿<br>class derivation list 类别衍化列 类继承列表﻿<br>class head 类别表头 类头﻿<br>class hierarchy 类别继承体系, 类别阶层 类层次体系﻿<br>class library 类别程式库、类别库 类库﻿<br>class template 类别模板、类别范本 类模板﻿<br>class template partial specializations 类别模板偏特化 类模板部分特化﻿<br>class template specializations 类别模板特化 类模板特化﻿<br>cleanup 清理、善後 清理、清除﻿<br>client 客端、客户端、客户 客户﻿<br>client－server 主从架构 客户/服务器﻿<br>clipboard 剪贴簿 剪贴板﻿<br>clone 复制 克隆﻿<br>collection 群集 集合﻿<br>combo box 复合方块、复合框 组合框﻿<br>command line 命令列 命令行(系统文字模式下的整行执行命令)﻿<br>communication 通讯 通讯﻿<br>compatible 相容 兼容﻿<br>compile time 编译期 编译期、编译时﻿<br>compiler 编译器 编译器﻿<br>component 组件 组件﻿<br>composition 复合、合成、组合 组合﻿<br>computer 电脑、计算机 计算机、电脑﻿<br>concept 概念 概念﻿<br>concrete 具象的 实在的﻿<br>concurrent 并行 并发﻿<br>configuration组态 配置﻿<br>connection 连接，连线（网络,资料库） 连接﻿<br>constraint 约束（条件）﻿<br>construct 构件 构件﻿<br>container 容器 容器(存放资料的某种结构如list, vector…）﻿<br>containment 内含 包容﻿<br>context背景关系、周遭环境、上下脉络 环境、上下文﻿<br>control 控制元件、控件 控件﻿<br>console 主控台 控制台﻿<br>const常数（constant 的缩写，C++ 关键字）﻿<br>constant 常数（相对於variable） 常量﻿<br>constructor（ctor） 建构式 构造函数（与class 同名的一种 member functions）﻿<br>copy (v) 复制、拷贝 拷贝﻿<br>copy (n) 复件, 副本﻿<br>cover 涵盖 覆盖﻿<br>create 创建、建立、产生、生成 创建﻿<br>creation 产生、生成 创建﻿<br>cursor 游标 光标custom、订制、自定 定制<br>data 资料 数据﻿<br>database 资料库 数据库﻿<br>database schema 数据库结构纲目﻿<br>data member 资料成员、成员变数 数据成员、成员变量﻿<br>data structure 资料结构 数据结构﻿<br>datagram 资料元 数据报文﻿<br>dead lock 死结 死锁﻿<br>debug 除错 调试﻿<br>debugger 除错器 调试器﻿<br>declaration 宣告、宣告式 声明﻿<br>deduction 推导（例：template argument deduction） 推导、推断﻿<br>default 预设 缺省、默认﻿<br>defer 延缓 推迟﻿<br>define 定义 预定义﻿<br>definition 定义、定义区、定义式 定义﻿<br>delegate 委派、委托、代理﻿<br>delegation （同上）﻿<br>demarshal 反编列 散集﻿<br>dereference 提领（取出指标所指物体的内容） 解叁考﻿<br>dereference operator dereference（提领）运算子 * 解叁考操作符﻿<br>derived class 衍生类别 派生类﻿<br>design by contract 契约式设计﻿<br>design pattern 设计范式、设计样式 设计模式﻿<br>destroy 摧毁、销毁﻿<br>destructor  解构式 析构函数﻿<br>device 装置、设备 设备﻿<br>dialog 对话窗、对话盒 对话框﻿<br>directive 指令（例：using directive） (编译)指示符﻿<br>directory 目录 目录﻿<br>disk 碟 盘﻿<br>dispatch 分派 分派﻿<br>distributed computing 分布式计算 (分布式电算) 分布式计算 分散式计算 (分散式电算)﻿<br>document 文件 文档﻿<br>dot operator dot（句点）运算子 . (圆)点操作符﻿<br>driver 驱动程式 驱动（程序）﻿<br>dynamic binding 动态系结 动态绑定﻿<br>efficiency 效率 效率﻿<br>efficient 高效 高效﻿<br>end user 终端用户﻿<br>entity 物体 实体、物体﻿<br>encapsulation 封装 封装﻿<br>enclosing class外围类别（与巢状类别 nested class有关）外围类﻿<br>enum (enumeration) 列举（一种 C++ 资料型别） 枚举﻿<br>enumerators 列举元（enum 型别中的成员） 枚举成员、枚举器﻿<br>equal 相等 相等﻿<br>equality 相等性 相等性﻿<br>equality operator equality（等号）运算子 == 等号操作符﻿<br>equivalence等价性、等同性、对等性 等价性﻿<br>equivalent 等价、等同、对等 等价﻿<br>escape code 转义码 转义码﻿<br>evaluate 评估、求值、核定 评估﻿<br>event 事件 事件﻿<br>event driven 事件驱动的 事件驱动的﻿<br>exception 异常情况 异常﻿<br>exception declaration 异常宣告（ref. C++ Primer 3/e, 11.3）异常声明﻿<br>exception handling 异常处理、异常处理机制 异常处理、异常处理机制﻿<br>exception specification 异常规格（ref. C++ Primer 3/e, 11.4）异常规范﻿<br>exit 退离（指离开函式时的那一个执行点） 退出﻿<br>explicit 明白的、明显的、显式 显式﻿<br>export 汇出 引出、导出﻿<br>facility 设施、设备 设施、设备﻿<br>feature 特性﻿<br>field 栏位,资料栏（Java） 字段, 值域（Java）﻿<br>file 档案 文件﻿<br>firmware 韧体 固件﻿<br>flag 旗标 标记﻿<br>flash memory 快闪记忆体 闪存﻿<br>flexibility 弹性 灵活性﻿<br>flush 清理、扫清 刷新﻿<br>font 字型 字体﻿<br>form 表单（programming 用语） 窗体﻿<br>formal parameter形式叁数 形式叁数</p>
<p>forward declaration 前置宣告 前置声明﻿<br>forwarding 转呼叫,转发 转发﻿<br>forwarding function 转呼叫函式,转发函式 转发函数﻿<br>fractal 碎形 分形﻿<br>framework 框架 框架﻿<br>full specialization 全特化（ref. partial specialization）﻿<br>function 函式、函数 函数﻿<br>function call operator 同﻿<br>call operator function object 函式物件（ref. C++ Primer 3/e, 12.3） 函数对象﻿<br>function overloaded resolution 函式多载决议程序 函数重载解决（方案）﻿<br>functionality 功能、机能 功能﻿<br>function template 函式模板、函式范本 函数模板﻿<br>functor 仿函式 仿函式、函子<br>game 游戏 游戏﻿<br>generate 生成﻿<br>generic 泛型、一般化的 一般化的、通用的、泛化﻿<br>generic algorithm 泛型演算法 通用算法﻿<br>getter (相对於 setter) 取值函式﻿<br>global 全域的（对应於 local） 全局的﻿<br>global object 全域物件 全局对象﻿<br>global scope resolution operator 全域生存空间（范围决议）运算子 :: 全局范围解析操作符﻿<br>group 群组<br>group box 群组方块 分组框<br>guard clause 卫述句 (Refactoring, p250) 卫语句<br>GUI 图形介面 图形界面﻿<br>hand shaking握手协商﻿<br>handle 识别码、识别号、号码牌、权柄 句柄﻿<br>handler 处理常式 处理函数﻿<br>hard－coded 编死的 硬编码的﻿<br>hard－copy 硬拷图 屏幕截图﻿<br>hard disk硬碟 硬盘﻿<br>hardware 硬体 硬件﻿<br>hash table 杂凑表 哈希表、散列表﻿<br>header file 表头档、标头档 头文件﻿<br>heap堆积 堆﻿<br>hierarchy 阶层体系 层次结构（体系）﻿<br>hook 挂钩 钩子﻿<br>hyperlink 超链结 超链接﻿<br>icon 图示、图标 图标﻿<br>IDE 整合开发环境 集成开发环境﻿<br>identifier 识别字、识别符号 标识符﻿<br>if and only if 若且唯若 当且仅当﻿<br>Illinois 伊利诺 伊利诺斯﻿<br>image 影像 图象﻿<br>immediate base 直接的（紧临的）上层 base class。 直接上层基类﻿<br>immediate derived 直接的（紧临的）下层derived class。 直接下层派生类﻿<br>immutability 不变性﻿<br>immutable不可变（的）﻿<br>implement实作、实现 实现﻿<br>implementation实作品、实作体、实作码、实件 实现﻿<br>implicit 隐喻的、暗自的、隐式 隐式﻿<br>import汇入 导入﻿<br>increment operator累加运算子 ++ 增加操作符﻿<br>infinite loop 无穷回圈 无限循环﻿<br>infinite recursive 无穷递回 无限递归﻿<br>information 资讯 信息﻿<br>infrastructure 公共基础建设﻿<br>inheritance继承、继承机制 继承、继承机制﻿<br>inline 行内 内联﻿<br>inline expansion 行内展开 内联展开﻿<br>initialization 初始化（动作） 初始化﻿<br>initialization list 初值列 初始值列表﻿<br>initialize 初始化 初始化﻿<br>inner class 内隐类别 内嵌类﻿<br>instance 实体 实例（根据某种表述而实际产生的「东西」）﻿<br>instantiated 具现化、实体化（常应用於 template） 实例化﻿<br>instantiation 具现体、具现化实体（常应用於 template） 实例﻿<br>integer (integral) 整数（的） 整型（的）﻿<br>integrate 整合 集成﻿<br>interacts 交谈、互动 交互﻿<br>interface 介面 接口﻿<br>interpreter 直译器 解释器﻿<br>invariants 恒常性,约束条件 约束条件﻿<br>invoke 唤起 调用﻿<br>iterate迭代（回圈一个轮回一个轮回地进行） 迭代﻿<br>iterative 反覆的，迭代的﻿<br>iterator 迭代器（一种泛型指标） 迭代器﻿<br>iteration 迭代（回圈每次轮回称为一个 iteration） 迭代﻿<br>item 项目、条款 项、条款、项目﻿<br>laser 雷射 激光﻿<br>level 阶 层 (级) 例high level高阶 高层﻿<br>library 程式库、函式库 库、函数库﻿<br>lifetime生命期、寿命 生命期、寿命﻿<br>link联结、连结 连接,链接﻿<br>linker联结器、连结器 连接器﻿<br>literal constant 字面常数（例 3.14 或 “hi” 这等常数值） 字面常数﻿<br>list串列（linked－list） 列表、表、链表﻿<br>list box 列表方块、列表框 列表框﻿</p>
<p>load 载入 装载﻿<br>loader 载入器 装载器、载入器﻿<br>local 区域的（对应於 global） 局部的﻿<br>local object 区域物件 局部对象﻿<br>lock机锁﻿<br>loop 回圈 循环﻿<br>lvalue左值 左值﻿<br>﻿<br>macro 巨集 宏﻿<br>magic number 魔术数字 魔法数﻿<br>maintain 维护 维护﻿<br>manipulator操纵器（iostream预先定义的一种东西） 操纵器﻿<br>marshal 编列 列集叁考<br>demarshal mechanism 机制 机制﻿<br>member 成员 成员﻿<br>member access operator 成员取用运算子（有 dot 和 arrow 两种） 成员存取操作符﻿<br>member function 成员函式 成员函数﻿<br>member initialization list 成员初值列 成员初始值列表﻿<br>member wise 以 member 为单元┅、members 逐一┅ 以成员为单位﻿<br>member wise copy 以 members 为单元逐一复制﻿<br>memory 记忆体 内存﻿<br>menu 表单、选单 菜单﻿<br>message 讯息 消息<br>message based 以讯息为基础的 基於消息的﻿<br>message loop讯息回圈 消息环﻿<br>method 方法、行为、函式 方法﻿<br>meta－ 超－ 元－﻿<br>meta－programming 超编程 元编程﻿<br>micro 微 微﻿<br>middleware 中介层 中间件﻿<br>modeling 模塑﻿<br>modeling language 塑模语言，建模语言﻿<br>modem 数据机 调制解调器﻿<br>module 模组 模块﻿<br>modifier 饰词 修饰符﻿<br>most derived class 最末层衍生类别 最底层的派生类﻿<br>mouse 滑鼠 鼠标﻿<br>mutable可变的 可变的﻿<br>multi－tasking 多工 多任务﻿<br>namespace 命名空间 名字空间、命名空间﻿<br>native 原生的 本地的、固有的﻿<br>nested class 巢状类别 嵌套类﻿<br>network 网路 网络﻿<br>network card网路卡 网卡<br>object 物件 对象﻿<br>object based 以物件为基础的 基於对象的﻿<br>object file 目的档 目标文件﻿<br>object model 物件模型 对象模型﻿<br>object oriented 物件导向的 面向对象的﻿<br>online 线上 在线﻿<br>opaque不透明的﻿<br>operand 运算元 操作数﻿<br>operating system (OS) 作业系统 操作系统﻿<br>operation 操作、操作行为 操作﻿<br>operator 运算子 操作符、运算符﻿<br>option 选项，可选方案 选项﻿<br>ordinary 常规的 常规的﻿<br>overflow 上限溢位（相对於 underflow） 溢出（underflow:下溢）﻿<br>overhead 额外负担、额外开销 额外开销﻿<br>overload 多载化、多载化、重载 重载﻿<br>overloaded function 多载化函式 重载的函数﻿<br>overloaded operator 多载化运算子 被重载的操作符﻿<br>overloaded set 多载集合 重载集合﻿<br>override 改写、覆写 重载、改写、重新定义（在 derived class 中重新定义虚拟函式)<br>package套件 包<br>pair 对组﻿<br>palette 调色盘、组件盘、工具箱﻿<br>pane 窗格 窗格﻿<br>parallel平行 并行﻿<br>parameter 叁数（函式叁数列上的变数） 叁数、形式叁数、形叁﻿<br>parameter list 叁数列 叁数列表﻿<br>parent class 父类别（或称 base class） 父类﻿<br>parentheses 小括弧、小括号 圆括弧、圆括号﻿<br>parse 解析 解析﻿<br>part零件 部件﻿<br>partial specialization 偏特化（ref. C++ Primer 3/e, 16.10）局部特化﻿<br>pass by address 传址（函式引数的传递方式）（非正式用语）传地址﻿<br>pass by reference传址（函式引数的一种传递方式） 传地址, 按引用传递﻿<br>pass by value 传值（函式引数的一种传递方式） 按值传递﻿<br>pattern 范式、样式 模式﻿<br>performance 效率、性能兼而有之 性能﻿<br>persistence 永续性 持久性﻿<br>pixel 图素、像素 像素﻿<br>platform 平台 平台﻿<br>pointer指标 指针址位器（和址叁器 reference 形成对映，满好）﻿<br>poll 轮询 轮询﻿<br>polymorphism多型 多态﻿<br>pop up 冒起式、弹出式 弹出式﻿<br>port 埠 端口﻿<br>postfix 後置式、後序式 後置式﻿<br>precedence 优先序（通常用於运算子的优先执行次序）﻿<br>prefix 前置式、前序式 前置式﻿<br>preprocessor 前处理器 预处理器﻿<br>prime质数 素数﻿<br>primitive type 基本型别 (不同於 base class,基础类别)﻿<br>print 列印 打印﻿<br>printer 印表机 打印机﻿<br>priority优先权 (通常用於执行绪获得 CPU 时间的优先次序）﻿<br>procedure 程序 过程﻿<br>procedural 程序的、程序式的 过程式的、过程化的﻿</p>
<p>process 行程 进程﻿<br>profile 评测 评测﻿<br>profiler 效能（效率）评测器 效能（性能）评测器﻿<br>programmer 程式员 程序员﻿<br>programming 编程、程式设计、程式化 编程﻿<br>progress bar 进度指示器 进度指示器﻿<br>project 专案 项目、工程﻿<br>property 属性﻿<br>protocol协定 协议﻿<br>pseudo code 假码、虚拟码、伪码 伪码﻿<br>﻿<br>qualified 经过资格修饰（例如加上scope 运算子） 限定﻿<br>qualifier 资格修饰词、饰词 限定修饰词﻿<br>quality品质 质量﻿<br>queue 伫列 队列﻿<br>radian 径度 弧度﻿<br>radio button 圆钮 单选按钮﻿<br>raise 引发（常用来表示发出一个 exception） 引起、引发﻿<br>random number 随机数、乱数 随机数﻿<br>range范围、区间（用於 STL 时） 范围、区间﻿<br>rank 等级、分等（ref. C++Primer 3/e 9,15章） 等级﻿<br>raw 生鲜的、未经处理的 未经处理的﻿<br>record记录 记录﻿<br>recordset 记录集 记录集﻿<br>recursive 递回 递归﻿<br>re－direction重导向 重定向﻿<br>refactoring 重构、重整 重构﻿<br>refer 取用 叁考﻿<br>refer to指向、指涉、指代﻿<br>reference 引用、叁考 址叁器,﻿<br>see pointer register暂存器 寄存器﻿<br>reflection 反射 反射、映像﻿<br>relational database 关联式资料库 关系数据库﻿<br>represent 表述，表现 表述，表现﻿<br>resolve 决议（为算式中的符号名称寻找 解析对应之宣告式的过程）﻿<br>resolution 决议程序、决议过程 解析过程﻿<br>resolution 解析度 分辨率﻿<br>restriction 局限﻿<br>return 传回、回返 返回﻿<br>return type 回返型别 返回类型﻿<br>return value 回返值 返回值﻿<br>robust 强固、稳健 健壮﻿<br>robustness强固性、稳健性 健壮性﻿<br>routine常式 例程﻿<br>runtime 执行期 运行期、运行时﻿<br>common language runtime(CLR) 译为「通用语言执行层」﻿<br>rvalue 右值 右值﻿<br>save 保存﻿<br>save point 保存点﻿<br>SAX (Simple API for XML)scalable可伸缩的、可扩展的﻿<br>schedule 调度</p>
<p>scheduler 调度程序﻿<br>schema模式、纲目结构﻿<br>scroll bar 滚动条﻿<br>scope 作用域、生存空间﻿<br>scope operator 生存空间操作符﻿<br>scope resolution operator生存空间解析操作符﻿<br>screen 屏幕﻿<br>SDK (Software Development Kit) 软件开发包﻿<br>sealed class 密封类﻿<br>search 查找﻿<br>semantics 语义﻿<br>semaphore信号量﻿<br>sequential container序列式容器﻿<br>server 服务器、服务端﻿<br>serial 串行﻿<br>serialization/serialize 序列化﻿<br>server cursor服务端游标、服务器游标﻿<br>session 会话﻿<br>setter 设值函数﻿<br>shared lock 共享锁﻿<br>sibling 同级﻿<br>side effect 副作用﻿<br>signature 签名﻿<br>single-threaded 单线程﻿<br>slider滑块﻿<br>slot 槽﻿<br>smart pointer 智能指针﻿<br>SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议﻿<br>snapshot 截屏图﻿<br>snapshot 快照﻿<br>specialization 特化﻿<br>specification 规范、规格﻿<br>splitter 切分窗口﻿<br>SOAP (simple object access protocol)简单对象访问协议﻿<br>software 软件﻿<br>source code 源码、源代码﻿<br>SQL (Structured Query Language) 结构化查询语言﻿<br>stack 栈、堆栈﻿<br>stack unwinding 叠辗转开解(此词用于exception主题)﻿<br>standard library 标准库﻿<br>standard template library 标准模板库﻿<br>stateless 无状态的﻿<br>statement 语句、声明﻿<br>static cursor 静态游标﻿<br>static SQL statements 静态SQL语句﻿<br>stored procedure 存储过程﻿<br>status bar 状态条﻿<br>stream 流﻿<br>string 字符串﻿<br>stub 存根﻿<br>subobject子对象﻿<br>subquery 子查询﻿<br>subroutine 子例程﻿<br>subscript operator 下标操作符﻿<br>subset 子集﻿<br>subtype 子类型﻿<br>support 支持﻿<br>suspend挂起﻿<br>symbol记号﻿<br>syntax 语法﻿<br>system databases 系统数据库﻿<br>system tables 系统表﻿<br>tag标签 标记 索引标签,页签﻿<br>target 标的（例target pointer：标的指标） 目标﻿<br>task switch 工作切换 任务切换﻿<br>template 模板、范本 模板﻿<br>template argument deduction 模板引数推导 模板叁数推导﻿<br>template explicit specialization 模板显式特化（版本） 模板显式特化﻿<br>template parameter 模板叁数 模板叁数﻿<br>temporary object 暂时物件 临时对象﻿<br>text文字 文本﻿<br>text file程式本文档（放置程式原始码的档案） 文本文件﻿<br>thread 执行绪 线程﻿<br>thread safe 多绪安全 多线程安全﻿<br>throw丢掷（常指发出一个exception） 丢掷、引发﻿<br>token 语汇单元 符号、标记﻿<br>transaction 交易 事务﻿<br>transaction log 事务日志﻿<br>transaction rollback 事务回滚﻿<br>transactional replication 事务复制﻿<br>translation unit 翻译单元﻿<br>transparent(ly) 透通的(地)﻿<br>traverse 巡访（来回走动） 遍历﻿<br>trigger 触发 触发﻿<br>type型别 类型﻿<br>table 表﻿<br>table lock 表锁﻿<br>table-level constraint表级约束﻿<br>tape backup 磁带备份﻿<br>task switch 工作切换﻿<br>TCP (Transport Control Protocol) 传输控制协议﻿<br>temporary table临时表﻿<br>thin client瘦客户端﻿<br>third-party第三方﻿<br>trace 跟踪﻿<br>traverse 遍历﻿<br>two-phase commit两阶段提交﻿<br>tupletwo-phase lookup 两阶段查找﻿<br>UML unified modeling language统一建模语言﻿<br>unary function 一元函式 单叁函数﻿<br>unary operator一元运算子 一元操作符﻿<br>underflow下限溢位（相对於overflow） 下溢﻿<br>unchecked exception 不可控异常﻿<br>unqualified 未经资格修饰（而直接取用）﻿<br>user 使用者、用户 用户﻿<br>user interface使用者界面、用户界面、人机界面﻿<br>UDDI(Universary Description, Discovery and Integration)统一描述、查询与集成﻿<br>unboxing 拆箱、拆箱转换﻿<br>Union query 联合查询﻿<br>UNIQUE constraints UNIQUE约束﻿<br>unique index 唯一索引﻿<br>unmanaged code 非受控代码、非托管代码﻿<br>unmarshal散集﻿<br>unqualified 未经限定的、未经修饰的﻿<br>URI (Uniform Resource identifier) 统一资源标识符﻿<br>URL (Uniform Resource Locator)统一资源定位器﻿<br>variable 变数（相对於常数const） 变量﻿<br>vector 向量（一种容器，有点类似array） 向量、矢量﻿<br>viable可实行的、可行的 可行的﻿<br>viable function可行函式 可行函数﻿<br>video 视讯 视频<br>view (1) 视图﻿<br>(document/view)文档/视图﻿<br>virtual function 虚拟函式 虚函数﻿<br>virtual machine虚拟机器 虚拟机﻿<br>virtual memory虚拟记忆体 虚内存, 虚存﻿<br>volatile 易挥发的、易变的﻿<br>vowel 母音 元音字母﻿<br>window 视窗 窗口﻿<br>window function 视窗函式 窗口函数﻿<br>window procedure 视窗函式 窗口过程﻿<br>word 字 单词﻿<br>word processor文书处理器 字处理器﻿<br>wrapper 外覆、外包 包装﻿<br>Web Services web 服务﻿<br>WHERE clause WHERE子句﻿<br>wildcard characters 通配符字符﻿<br>wildcard search 通配符搜索﻿<br>Windows authentication Windows 身份验证﻿<br>wizard 向导﻿<br>write enable写启用﻿<br>write-ahead log 预写日志﻿<br>write-only 只写﻿<br>WSDL (Web Service Description Language)Web Service 描述语言﻿<br>XML (eXtensible Markup Language)可扩展标记语言﻿<br>XSD (XML Schema Definition)  XML 模式定义语言﻿<br>XSL (eXtensible Stylesheet Language)可扩展样式表语言﻿<br>XSLT (eXtensible Stylesheet Language Transformation)可扩展样式表语言转换﻿<br>xxx based基于xxx的﻿</p>
<p>xxx oriented面向xxxXML (eXtensible Markup Language) 可扩展标记语言</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[版本管理Git]]></title>
      <url>http://yoursite.com/2017/02/21/Git/</url>
      <content type="html"><![CDATA[<h2 id="GIT简介"><a href="#GIT简介" class="headerlink" title="GIT简介"></a>GIT简介</h2><h4 id="什么是git"><a href="#什么是git" class="headerlink" title="什么是git?"></a>什么是git?</h4><ul>
<li>git是一款开源的分布式版本控制工具</li>
<li>在世界上所有的分布式版本控制工具中，git是最快、最简单、最流行的版本管理工具<h4 id="git的起源"><a href="#git的起源" class="headerlink" title="git的起源"></a>git的起源</h4></li>
<li>作者是Linux之父：Linus Benedict Torvalds</li>
<li>当初开发git仅仅是为了辅助Linux内核的开发（管理源代码）<h4 id="git的现状"><a href="#git的现状" class="headerlink" title="git的现状"></a>git的现状</h4></li>
<li>在国外已经非常普及，国内并未普及（在慢慢普及）</li>
<li>越来越多的开源项目已经转移到git<h3 id="其他版本控制工具"><a href="#其他版本控制工具" class="headerlink" title="其他版本控制工具"></a>其他版本控制工具</h3><h4 id="CVS"><a href="#CVS" class="headerlink" title="CVS"></a>CVS</h4></li>
<li>最早的开源、免费的集中式版本控制工具</li>
<li>自身设计有问题，会造成提交文件不完整，版本库莫名其妙损坏的情况</li>
</ul>
<h4 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h4><ul>
<li>修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制工具</li>
</ul>
<h4 id="ClearCase"><a href="#ClearCase" class="headerlink" title="ClearCase"></a>ClearCase</h4><ul>
<li>收费的集中式版本控制工具，安装比Windows还大，运行比蜗牛还慢</li>
<li>能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗或者人傻钱多</li>
</ul>
<h4 id="VSS"><a href="#VSS" class="headerlink" title="VSS"></a>VSS</h4><ul>
<li>微软的集中式版本控制工具，集成在Visual Studio中</li>
<li>由于它反人类的设计，连微软自己都不好意思用了</li>
</ul>
<h3 id="集中式版本控制"><a href="#集中式版本控制" class="headerlink" title="集中式版本控制"></a>集中式版本控制</h3><p><img src="/img/1.png" alt="集中式版本控制"></p>
<h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p><img src="/img/2.png" alt="分布式版本控制"></p>
<h3 id="git和SVN的简单对比"><a href="#git和SVN的简单对比" class="headerlink" title="git和SVN的简单对比"></a>git和SVN的简单对比</h3><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><ul>
<li>在很多情况下，git的速度远远比SVN快</li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li>SVN是集中式管理，git是分布式管理</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>SVN使用分支比较笨拙，git可以轻松拥有无限个分支</li>
<li>SVN必须联网才能正常工作，git支持本地版本控制工作</li>
<li>旧版本的SVN会在每一个目录置放一个.svn，git只会在根目录拥有一个.git</li>
</ul>
<h3 id="SVN的工作流程"><a href="#SVN的工作流程" class="headerlink" title="SVN的工作流程"></a>SVN的工作流程</h3><p><img src="/img/3.png" alt="SVN的工作流程"></p>
<h3 id="git的工作流程"><a href="#git的工作流程" class="headerlink" title="git的工作流程"></a>git的工作流程</h3><ul>
<li>分布式和集中式的最大区别在于：在分布式下开发者可以本地提交每个开发者机器上都有一个服务器的数据库<br><img src="/img/4.png" alt="git的工作流程"></li>
</ul>
<h3 id="使用Git"><a href="#使用Git" class="headerlink" title="使用Git"></a>使用Git</h3><p>跟SVN一样，你可以通过命令行敲指令或者图形界面客户端使用git，在Mac上，比较好用的git图形界面客户端有<br>SourceTree<br>下载地址：（<a href="http://www.sourcetreeapp.com/download/）" target="_blank" rel="external">http://www.sourcetreeapp.com/download/）</a><br>GitHub<br>下载地址：(<a href="https://mac.github.com" target="_blank" rel="external">https://mac.github.com</a>)<br>不过它是专门为GitHub网站而设计的</p>
<h3 id="Git的常用的指令"><a href="#Git的常用的指令" class="headerlink" title="Git的常用的指令"></a>Git的常用的指令</h3><p>git help ：git指令帮助手册</p>
<ul>
<li>查看其他指令的做法：git help 其他指令</li>
</ul>
<p>git config ：git的配置信息相关（修改的是.git/config文件）</p>
<ul>
<li>配置用户名：git config “user.name” 用户名（用于跟踪修改记录）</li>
<li>配置邮箱：git config “user.email” 邮箱（用于多人开发间的沟通）</li>
<li>查看配置信息：git config –l</li>
<li>编辑配置信息：git config –e（用vim编辑，:wq是退出vim编辑器）</li>
<li>设置指令的别名：git config alias.别名 原指令名称</li>
<li>设置带参数指令的别名：git config alias.别名 “原指令名称 参数”</li>
<li>将此设置应用到整个系统中：git config ––gloabal</li>
</ul>
<p>git status ：查文件的状态</p>
<ul>
<li>查看某个文件的状态：git status 文件名</li>
<li>查看当前路径所有文件的状态：git status</li>
</ul>
<p>git log ：查看文件的修改日志</p>
<ul>
<li>查看某个文件的修改日志：git log 文件名</li>
<li>查看当前路径所有文件的修改日志：git log</li>
<li>用一行的方式查看简单的日志信息：git log ––pretty=oneline</li>
<li>查看最近的N次修改：git log –N（N是一个整数）</li>
</ul>
<p>git diff ：查看文件最新改动的地方</p>
<ul>
<li>查看某个文件的最新改动的地方：git diff 文件名</li>
<li>查看当前路径所有文件最新改动的地方：git diff</li>
</ul>
<p>git init ：初始化一个空的本地仓库，生成一个.git目录，用于维护版本信息</p>
<ul>
<li>在当前路径初始化仓库：git init</li>
<li>在其他路径初始化仓库：git init 仓库路径</li>
</ul>
<p>git add ：将工作区的文件保存到暂缓区</p>
<ul>
<li>保存某个文件到暂缓区：git add 文件名</li>
<li>保存当前路径的所有文件到暂缓区：git add .（注意，最后是一个点 . ）</li>
</ul>
<p>git commit ：将暂缓区的文件提交到当前分支</p>
<ul>
<li>提交某个文件到分支：git commit -m ”注释” 文件名</li>
<li>保存当前路径的所有文件到分支：git commit -m ”注释” </li>
</ul>
<p>git reset ：版本回退（建议加上––hard参数，git支持无限次后悔）</p>
<ul>
<li>回退到上一个版本：git reset ––hard HEAD^</li>
<li>回退到上上一个版本：git reset ––hard HEAD^^</li>
<li>回退到上N个版本：git reset ––hard HEAD~N（N是一个整数）</li>
<li>回退到任意一个版本：git reset ––hard 版本号（版本号用7位即可）</li>
</ul>
<p>git reflog ：查看分支引用记录（能够查看所有的版本号）<br>git rm：删除文件（删完之后要进行commit操作，才能同步到版本库）<br>git clone：下载远程仓库到本地</p>
<ul>
<li>下载远程仓库到当前路径：git clone 仓库的URL</li>
<li>下载远程仓库到特定路径：git clone 仓库的URL 存放仓库的路径</li>
</ul>
<p>git pull：下载远程仓库的最新信息到本地仓库<br>git push：将本地的仓库信息推送到远程仓库</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>如果是多人团队开发，最好还是搭建一个远程仓库,搭建远程仓库的途径</p>
<p>自己搭建一个git服务器：费时费力<br>在GitHub上托管项目：公开项目免费、私有项目收费，很多第三方开源项目<br>在oschina上托管项目：完全免费，在国内访问速度快（推荐使用）</p>
<h4 id="搭建GitHub远程仓库-–-配置SSH-Key"><a href="#搭建GitHub远程仓库-–-配置SSH-Key" class="headerlink" title="搭建GitHub远程仓库 – 配置SSH Key"></a>搭建GitHub远程仓库 – 配置SSH Key</h4><p>注册一个GitHub帐号：（<a href="https://github.com" target="_blank" rel="external">https://github.com</a>)<br>打开“Account Settings”<br>点击“SSH keys”<br>配置Mac的SSH Key的公钥（用于限制提交）<br>在Mac上生成SSH Key（在终端输入下面指令）<br>cd ~/.ssh<br>ssh-keygen -t rsa -C “你的邮箱地址”<br>然后一直敲回车<br>然后就会在~/.ssh目录下生成SSK Key的秘钥对<br>id_rsa ：私钥，不可泄露<br>id_rsa.pub ：公钥，可以公开（将这个文件的内容粘贴到GitHub上）<br>利用cat指令可以查看文件的内容<br>cat id_rsa.pub</p>
<h4 id="搭建GitHub远程仓库–-添加仓库"><a href="#搭建GitHub远程仓库–-添加仓库" class="headerlink" title="搭建GitHub远程仓库– 添加仓库"></a>搭建GitHub远程仓库– 添加仓库</h4><p><img src="/img/6.png" alt="添加一个仓库"></p>
<h4 id="拷贝仓库地址，用于下载到本地"><a href="#拷贝仓库地址，用于下载到本地" class="headerlink" title="拷贝仓库地址，用于下载到本地"></a>拷贝仓库地址，用于下载到本地</h4><p><img src="/img/7.png" alt="拷贝仓库地址用于下载到本地"></p>
<h4 id="如果想删除仓库，也很简单"><a href="#如果想删除仓库，也很简单" class="headerlink" title="如果想删除仓库，也很简单"></a>如果想删除仓库，也很简单</h4><p><img src="/img/8.png" alt="删除"></p>
<h2 id="搭建oschina远程仓库-–创建仓库"><a href="#搭建oschina远程仓库-–创建仓库" class="headerlink" title="搭建oschina远程仓库 –创建仓库"></a>搭建oschina远程仓库 –创建仓库</h2><p>注册一个oschina帐号:(<a href="https://git.oschina.net" target="_blank" rel="external">https://git.oschina.net</a>)<br><img src="/img/9.png" alt="创建一个新项目"><br><img src="/img/10.png" alt=""></p>
<h2 id="搭建oschina远程仓库-–仓库地址"><a href="#搭建oschina远程仓库-–仓库地址" class="headerlink" title="搭建oschina远程仓库 –仓库地址"></a>搭建oschina远程仓库 –仓库地址</h2><p><img src="/img/11.png" alt=""></p>
<p><img src="/img/12.png" alt="添加项目组成员"></p>
<h2 id="搭建oschina远程仓库-–-删除仓库"><a href="#搭建oschina远程仓库-–-删除仓库" class="headerlink" title="搭建oschina远程仓库 – 删除仓库"></a>搭建oschina远程仓库 – 删除仓库</h2><p><img src="/img/13.png" alt="添加项目组成员"></p>
<h1 id="二、本地的Git操作"><a href="#二、本地的Git操作" class="headerlink" title="二、本地的Git操作"></a>二、本地的Git操作</h1><hr>
<h2 id="1-GIT命令行帮助"><a href="#1-GIT命令行帮助" class="headerlink" title="1.GIT命令行帮助"></a>1.GIT命令行帮助</h2><p>$ svn help<br>查看svn所有命令的帮助<br>$ svn help 子命令</p>
<ul>
<li>要退出帮助信息，按”q”</li>
<li>翻看下页，按”空格”</li>
<li>翻看上页，按”CTRL+B”</li>
<li>要搜索相关文字，按”/“然后输入”相关文字”</li>
</ul>
<h2 id="2-创建代码库-amp-配置个人信息"><a href="#2-创建代码库-amp-配置个人信息" class="headerlink" title="2.创建代码库 &amp; 配置个人信息"></a>2.创建代码库 &amp; 配置个人信息</h2><h3 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h3><p>$ git init</p>
<h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><p>$ git config user.name lnj<br>$ git config user.email lnj@gmail.com</p>
<ul>
<li>以上两个命令会将用户信息保存在当前代码仓库中,只有配置了用户和邮箱之后，git才能识别出操作的人员信息，通过钩子(hooks)程序可以设置一些动作, 例如单元测试发现问题后，自动给相关人员发送电子邮件</li>
</ul>
<h3 id="如果要一次性配置完成可以使用一下命令"><a href="#如果要一次性配置完成可以使用一下命令" class="headerlink" title="如果要一次性配置完成可以使用一下命令"></a>如果要一次性配置完成可以使用一下命令</h3><p>$ git config –global user.name lnj<br>$ git config –global user.email lnj321@gmail.com</p>
<ul>
<li>以上两个命令会将用户信息保存在用户目录下的 .gitconfig 文件中</li>
</ul>
<h3 id="查看当前所有配置"><a href="#查看当前所有配置" class="headerlink" title="查看当前所有配置"></a>查看当前所有配置</h3><p>$ git config -l</p>
<h2 id="3-实际开发"><a href="#3-实际开发" class="headerlink" title="3.实际开发"></a>3.实际开发</h2><h3 id="创建代码，开始开发"><a href="#创建代码，开始开发" class="headerlink" title="创建代码，开始开发"></a>创建代码，开始开发</h3><p>$ touch main.c<br>$ open main.c</p>
<h3 id="将代码添加到代码库"><a href="#将代码添加到代码库" class="headerlink" title="将代码添加到代码库"></a>将代码添加到代码库</h3><h4 id="查看当前代码库状态"><a href="#查看当前代码库状态" class="headerlink" title="查看当前代码库状态"></a>查看当前代码库状态</h4><p>$ git status</p>
<h4 id="将文件添加到代码库"><a href="#将文件添加到代码库" class="headerlink" title="将文件添加到代码库"></a>将文件添加到代码库</h4><p>$ git add main.c</p>
<h4 id="将修改提交到代码库"><a href="#将修改提交到代码库" class="headerlink" title="将修改提交到代码库"></a>将修改提交到代码库</h4><p>$ git commit -m “添加了main.c”</p>
<p>提示：</p>
<ul>
<li>在此一定要使用 -m 参数指定修改的备注信息</li>
<li>否则会进入 vim 编辑器，如果对vim不熟悉，会是很糟糕的事情</li>
</ul>
<h3 id="将当前文件夹下的所有新建或修改的文件一次性添加到代码库"><a href="#将当前文件夹下的所有新建或修改的文件一次性添加到代码库" class="headerlink" title="将当前文件夹下的所有新建或修改的文件一次性添加到代码库"></a>将当前文件夹下的所有新建或修改的文件一次性添加到代码库</h3><p>$ git add .</p>
<h4 id="添加多个文件"><a href="#添加多个文件" class="headerlink" title="添加多个文件"></a>添加多个文件</h4><p>$ touch Person.h Person.m<br>$ git add .<br>$ git commit -m “添加了Person类”<br>$ open Person.h<br>$ git add .<br>$ git commit -m “增加Person类属性”</p>
<ul>
<li>注意 使用git时，每一次修改都需要添加再提交，这一点是与svn不一样的<h4 id="git-的重要概念及工作原理"><a href="#git-的重要概念及工作原理" class="headerlink" title="git 的重要概念及工作原理"></a>git 的重要概念及工作原理</h4>工作区<br>暂存区(staged)<br>分支(HEAD)</li>
</ul>
<h2 id="3-别名-amp-日志"><a href="#3-别名-amp-日志" class="headerlink" title="3.别名 &amp; 日志"></a>3.别名 &amp; 日志</h2><p>$ git config alias.st status<br>$ git config alias.ci “commit -m”</p>
<ul>
<li>个人建议：除非特殊原因，最好不要设置别名，否则换一台机器就不会用了<h4 id="查看所有版本库日志"><a href="#查看所有版本库日志" class="headerlink" title="查看所有版本库日志"></a>查看所有版本库日志</h4>$ git log<h4 id="查看指定文件的版本库日志"><a href="#查看指定文件的版本库日志" class="headerlink" title="查看指定文件的版本库日志"></a>查看指定文件的版本库日志</h4>$ git log 文件名<h4 id="配置带颜色的log别名"><a href="#配置带颜色的log别名" class="headerlink" title="配置带颜色的log别名"></a>配置带颜色的log别名</h4>$ git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”<br>提示：在git中，版本号是一个由SHA1生成的哈希值</li>
</ul>
<h2 id="4-版本号，让我们在任意版本之间穿梭"><a href="#4-版本号，让我们在任意版本之间穿梭" class="headerlink" title="4.版本号，让我们在任意版本之间穿梭"></a>4.版本号，让我们在任意版本之间穿梭</h2><h3 id="回到当前版本，放弃所有没有提交的修改"><a href="#回到当前版本，放弃所有没有提交的修改" class="headerlink" title="回到当前版本，放弃所有没有提交的修改"></a>回到当前版本，放弃所有没有提交的修改</h3><p>$ git reset –hard HEAD</p>
<h3 id="回到上一个版本"><a href="#回到上一个版本" class="headerlink" title="回到上一个版本"></a>回到上一个版本</h3><p>$ git reset –hard HEAD^</p>
<h3 id="回到之前第3个修订版本"><a href="#回到之前第3个修订版本" class="headerlink" title="回到之前第3个修订版本"></a>回到之前第3个修订版本</h3><p>$ git reset –hard HEAD~(3)</p>
<h3 id="回到指定版本号的版本"><a href="#回到指定版本号的版本" class="headerlink" title="回到指定版本号的版本"></a>回到指定版本号的版本</h3><p>$ git reset e695b67</p>
<h3 id="查看分支引用记录"><a href="#查看分支引用记录" class="headerlink" title="查看分支引用记录"></a>查看分支引用记录</h3><p>$ git reflog</p>
<h2 id="5-单个文件的修改管理"><a href="#5-单个文件的修改管理" class="headerlink" title="5.单个文件的修改管理"></a>5.单个文件的修改管理</h2><h3 id="查看文件变化"><a href="#查看文件变化" class="headerlink" title="查看文件变化"></a>查看文件变化</h3><p>$ git diff</p>
<h3 id="撤销对文件做的修改"><a href="#撤销对文件做的修改" class="headerlink" title="撤销对文件做的修改"></a>撤销对文件做的修改</h3><p>$ git checkout Person.h</p>
<h3 id="从代码库（暂存区中删除文件）"><a href="#从代码库（暂存区中删除文件）" class="headerlink" title="从代码库（暂存区中删除文件）"></a>从代码库（暂存区中删除文件）</h3><h1 id="三、Git团队开发操作"><a href="#三、Git团队开发操作" class="headerlink" title="三、Git团队开发操作"></a>三、Git团队开发操作</h1><hr>
<h2 id="1-建立代码仓库-专门用于团队开发的代码仓库"><a href="#1-建立代码仓库-专门用于团队开发的代码仓库" class="headerlink" title="1.建立代码仓库(专门用于团队开发的代码仓库)"></a>1.建立代码仓库(专门用于团队开发的代码仓库)</h2><h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><p>$ cd /Users/lnj/Desktop/git演练/公司/weibo</p>
<h3 id="建立空白代码库-专门用于团队开发"><a href="#建立空白代码库-专门用于团队开发" class="headerlink" title="建立空白代码库(专门用于团队开发)"></a>建立空白代码库(专门用于团队开发)</h3><p>$ git init –bare</p>
<h2 id="2-项目经理准备项目-前奏"><a href="#2-项目经理准备项目-前奏" class="headerlink" title="2.项目经理准备项目(前奏)"></a>2.项目经理准备项目(前奏)</h2><h3 id="切换目录-1"><a href="#切换目录-1" class="headerlink" title="切换目录"></a>切换目录</h3><p>$ cd /Users/lnj/Desktop/git演练/经理</p>
<h3 id="“克隆”代码库到本地"><a href="#“克隆”代码库到本地" class="headerlink" title="“克隆”代码库到本地"></a>“克隆”代码库到本地</h3><p>$ git clone /Users/lnj/Desktop/git演练/公司/weibo/</p>
<h3 id="个人信息配置-因为要演示一台机器上的多人协作，日常开发可以忽略"><a href="#个人信息配置-因为要演示一台机器上的多人协作，日常开发可以忽略" class="headerlink" title="个人信息配置(因为要演示一台机器上的多人协作，日常开发可以忽略)"></a>个人信息配置(因为要演示一台机器上的多人协作，日常开发可以忽略)</h3><p>$ git config user.name manager<br>$ git config user.email manager@163.com</p>
<p>.gitignore<br>.gitignore可以指定哪些文件不纳入版本库的管理</p>
<p>参考网址:(<a href="https://github.com/github/gitignore" target="_blank" rel="external">https://github.com/github/gitignore</a>)</p>
<h1 id="命令行中进入与-git同级的目录"><a href="#命令行中进入与-git同级的目录" class="headerlink" title="命令行中进入与.git同级的目录"></a>命令行中进入与.git同级的目录</h1><p>$ cd /Users/lnj/Desktop/git演练/经理/weibo</p>
<ul>
<li>将以下命令一次性粘贴到命令行中</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">echo -e "# Xcode</div><div class="line">#</div><div class="line">build/</div><div class="line">*.pbxuser</div><div class="line">*.mode1v3</div><div class="line">*.mode2v3</div><div class="line">*.perspectivev3</div><div class="line">xcuserdata</div><div class="line">*.xccheckout</div><div class="line">*.moved-aside</div><div class="line">DerivedData</div><div class="line">*.hmap</div><div class="line">*.ipa</div><div class="line">*.xcuserstate</div><div class="line"># CocoaPods</div><div class="line">#</div><div class="line"># We recommend against adding the Pods directory to your .gitignore. However</div><div class="line"># you should judge for yourself, the pros and cons are mentioned at:</div><div class="line"># http://guides.cocoapods.org/using/using-cocoapods.html#should-i-ignore-the-pods-directory-in-source-control</div><div class="line">#</div><div class="line"># Pods/" &gt; .gitignore</div></pre></td></tr></table></figure>
<h3 id="将-gitignore添加到代码库"><a href="#将-gitignore添加到代码库" class="headerlink" title="将.gitignore添加到代码库"></a>将.gitignore添加到代码库</h3><p>$ git add .gitignore</p>
<h2 id="3-创建项目"><a href="#3-创建项目" class="headerlink" title="3.创建项目"></a>3.创建项目</h2><ul>
<li>提交同时”push”到远程代码仓库</li>
</ul>
<h2 id="4-新人加入"><a href="#4-新人加入" class="headerlink" title="4.新人加入"></a>4.新人加入</h2><p>…</p>
<h2 id="5-分布式的代码库-仅供参考"><a href="#5-分布式的代码库-仅供参考" class="headerlink" title="5.分布式的代码库 - 仅供参考"></a>5.分布式的代码库 - 仅供参考</h2><ul>
<li>由于git是分布式的，任何一台计算机上都保留有完整的代码库的内容，因此可以把团队开发的代码库放在任何位置</li>
</ul>
<h2 id="6-分支管理-Tag"><a href="#6-分支管理-Tag" class="headerlink" title="6.分支管理 - Tag"></a>6.分支管理 - Tag</h2><h3 id="查看当前标签"><a href="#查看当前标签" class="headerlink" title="查看当前标签"></a>查看当前标签</h3><p>$ git tag</p>
<h3 id="在本地代码库给项目打上一个标签"><a href="#在本地代码库给项目打上一个标签" class="headerlink" title="在本地代码库给项目打上一个标签"></a>在本地代码库给项目打上一个标签</h3><p>$ git tag -a v1.0 -m ‘Version 1.0’</p>
<h3 id="将标签添推送到远程代码库中"><a href="#将标签添推送到远程代码库中" class="headerlink" title="将标签添推送到远程代码库中"></a>将标签添推送到远程代码库中</h3><p>$ git push origin v1.0</p>
<ul>
<li>使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本</li>
</ul>
<h3 id="签出v1-0标签"><a href="#签出v1-0标签" class="headerlink" title="签出v1.0标签"></a>签出v1.0标签</h3><p>$ git checkout v1.0</p>
<h3 id="从签出状态创建v1-0bugfix分支"><a href="#从签出状态创建v1-0bugfix分支" class="headerlink" title="从签出状态创建v1.0bugfix分支"></a>从签出状态创建v1.0bugfix分支</h3><p>$ git checkout -b bugfix1.0</p>
<h3 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h3><p>$ git branch -r</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>$ git branch -r -d origin/bugfix1.0</p>
<h1 id="四、Git分支管理-了解"><a href="#四、Git分支管理-了解" class="headerlink" title="四、Git分支管理(了解)"></a>四、Git分支管理(了解)</h1><hr>
<h2 id="1-分布式的代码库-仅供参考"><a href="#1-分布式的代码库-仅供参考" class="headerlink" title="1.分布式的代码库 - 仅供参考"></a>1.分布式的代码库 - 仅供参考</h2><ul>
<li>由于git是分布式的，任何一台计算机上都保留有完整的代码库的内容，因此可以把团队开发的代码库放在任何位置</li>
<li>多个远程代码库之间的同步演练”提示，此演练仅供了解，具体的使用，需要一定的团队规模之后，才能够体会”</li>
</ul>
<h2 id="2-分支管理-Tag"><a href="#2-分支管理-Tag" class="headerlink" title="2.分支管理 - Tag"></a>2.分支管理 - Tag</h2><h3 id="查看当前标签-1"><a href="#查看当前标签-1" class="headerlink" title="查看当前标签"></a>查看当前标签</h3><p>$ git tag</p>
<h3 id="在本地代码库给项目打上一个标签-1"><a href="#在本地代码库给项目打上一个标签-1" class="headerlink" title="在本地代码库给项目打上一个标签"></a>在本地代码库给项目打上一个标签</h3><p>$ git tag -a v1.0 -m ‘Version 1.0’</p>
<h3 id="将标签添推送到远程代码库中-1"><a href="#将标签添推送到远程代码库中-1" class="headerlink" title="将标签添推送到远程代码库中"></a>将标签添推送到远程代码库中</h3><p>$ git push origin v1.0</p>
<h3 id="使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本"><a href="#使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本" class="headerlink" title="使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本"></a>使用tag，就能够将项目快速切换到某一个中间状态，例如产品开发线上的某一个稳定版本</h3><h3 id="签出v1-0标签-1"><a href="#签出v1-0标签-1" class="headerlink" title="签出v1.0标签"></a>签出v1.0标签</h3><p>$ git checkout v1.0</p>
<h3 id="从签出状态创建v1-0bugfix分支-1"><a href="#从签出状态创建v1-0bugfix分支-1" class="headerlink" title="从签出状态创建v1.0bugfix分支"></a>从签出状态创建v1.0bugfix分支</h3><p>$ git checkout -b bugfix1.0</p>
<h3 id="查看远程分支-1"><a href="#查看远程分支-1" class="headerlink" title="查看远程分支"></a>查看远程分支</h3><p>$ git branch -r</p>
<h3 id="删除远程分支-1"><a href="#删除远程分支-1" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>$ git branch -r -d origin/bugfix1.0</p>
<h1 id="四、Github使用-amp-如何学习第三方库"><a href="#四、Github使用-amp-如何学习第三方库" class="headerlink" title="四、Github使用&amp;如何学习第三方库"></a>四、Github使用&amp;如何学习第三方库</h1><hr>
<h2 id="如何使用-学习第三方框架-优秀的第三方框架都在-github-com。"><a href="#如何使用-学习第三方框架-优秀的第三方框架都在-github-com。" class="headerlink" title="如何使用/学习第三方框架?优秀的第三方框架都在 github.com。"></a>如何使用/学习第三方框架?优秀的第三方框架都在 github.com。</h2><h3 id="1-搜索"><a href="#1-搜索" class="headerlink" title="1.搜索"></a>1.搜索</h3><h3 id="2-git-clone-获得完整版本"><a href="#2-git-clone-获得完整版本" class="headerlink" title="2.git clone 获得完整版本"></a>2.git clone 获得完整版本</h3><p>$ git clone <a href="https://github.com/AFNetworking/AFNetworking.git" target="_blank" rel="external">https://github.com/AFNetworking/AFNetworking.git</a></p>
<h3 id="3-获取最新版本-git-pull"><a href="#3-获取最新版本-git-pull" class="headerlink" title="3.获取最新版本 git pull"></a>3.获取最新版本 git pull</h3><ul>
<li>进入clone的本地文件夹<br>$ git pull<h3 id="4-看github上的文档-优秀的第三方框架都有好的文档"><a href="#4-看github上的文档-优秀的第三方框架都有好的文档" class="headerlink" title="4.看github上的文档,优秀的第三方框架都有好的文档"></a>4.看github上的文档,优秀的第三方框架都有好的文档</h3><h3 id="5-编写测试程序-看运行结果"><a href="#5-编写测试程序-看运行结果" class="headerlink" title="5.编写测试程序,看运行结果"></a>5.编写测试程序,看运行结果</h3><h3 id="6-针对感兴趣的部分-看源代码"><a href="#6-针对感兴趣的部分-看源代码" class="headerlink" title="6.针对感兴趣的部分,看源代码"></a>6.针对感兴趣的部分,看源代码</h3><h3 id="7-有问题去-http-stackoverflow-com"><a href="#7-有问题去-http-stackoverflow-com" class="headerlink" title="7.有问题去(http://stackoverflow.com)"></a>7.有问题去(<a href="http://stackoverflow.com" target="_blank" rel="external">http://stackoverflow.com</a>)</h3></li>
</ul>
<h1 id="五、练习笔记"><a href="#五、练习笔记" class="headerlink" title="五、练习笔记"></a>五、练习笔记</h1><hr>
<p>1.新建一个“本地仓库”<br>$ git init</p>
<p>2.配置仓库<br>》告诉git你是谁<br>git config user.name lnj<br>》告诉git怎么联系你<br>git config user.email lnj@itcast.cn</p>
<p>》上面一种配置方式是一次性的配置， 会配置到被管理文件的。git文件夹下<br>》下面一种配置方式是一劳永逸的方式:<br>git config –global user.name lmj<br>git config –global user.email lmj@itcast.cn</p>
<p>》如何学习git指令</p>
<blockquote>
<p>学习git指令和SVN指令的学习其实是一样的， 只不过展现的方式不太一样， git是通过使用指南的方式告诉我们某一个指令如何使用<br>这个指南其实是一个不可编辑的vim<br>Q退出指南<br>按空格下一页<br>control + B 上一页<br>/需要搜索的内容 可以进行搜索</p>
</blockquote>
<p>git常规指令<br>》git status 查看文件状态<br>》git add 添加文件到“暂存区”<br>》git commit 文件名称   添加文件到”本地仓库“<br>注意：如果没有在commit后面加上 -m说明修改了什么， 会自动进入vim界面， 要求我们输入修改信息<br>按键盘上的 i 代表开始输入内容<br>输入完毕之后按 esc 然后按 ：wq<br>所以： 如果以后在终端中提交最好在后面加上-m<br>》注意： git中的add和SVN中的add不太一样， SVN中只需要add一次， 而git中每次新建或者修改之后都需要重新add</p>
<p>》1.为添加之前的颜色<br>红色 代表在”工作区“<br>》2.添加到暂存区之后的颜色<br>绿色 代码在”暂存区“</p>
<p>》注意： git默认没有简写指令<br>》注意： 一般情况下不建议自定义简写指令<br>》git中的简写称之为起别名</p>
<blockquote>
<p>查看log<br>》git log 文件名<br>》注意： GIt中的版本号是一个”40位“的哈希值， 而SVN中的版本号是一个递增的整数<br>》已经提交<br>git reset —hard HEAD^ 返回上一个版本<br>其中—hard代表强制重置<br>git reset —hard 版本号（只需要写前7位）<br>》未提交<br>git checkout 文件名 回退到上一次提交的版本<br>git reset —hard HEAD  回退到上一次提交的版, 注意HEAD后面没有尖号^</p>
</blockquote>
<p>c9ad690 HEAD@{0}: commit: main.c</p>
<p>7026f99 HEAD@{1}: commit: 输出结果</p>
<p>e950c89 HEAD@{2}: commit: 新增输入</p>
<p>c7bf91c HEAD@{3}: commit: 添加变量</p>
<p>cbd9e52 HEAD@{4}: commit: 删除print函数</p>
<p>45ea44d HEAD@{5}: commit: 添加了printf函数</p>
<p>0da06d8 HEAD@{6}: commit (initial): i</p>
<blockquote>
<p>git reflog  查看所有修改信息（所有版本）</p>
</blockquote>
<p>》查看文件被修改的什么地方<br>】    》git diff 文件名<br>》如果显示绿色代表新增<br>》如果显示红色代表删除</p>
<p>远程仓库<br>SVN需要一个单独的服务器<br>Git不需要： 文件中、U盘中、云上、github、OSChina…</p>
<p>1.新建git远程仓库<br>》git init —bare<br>注意： 这个仓库仅仅是用于管理代码， 不参与开发</p>
<p>2.项目经理初始化项目<br>》2.1先克隆一份空得仓库到本地<br>git clone /Users/apple/Desktop/working/公司远程仓库</p>
<p>》2.2忽略不需要加入版本控制器的文件以及文件夹<br>.gitignore<br>注意： 配置忽略文件只需要到github上搜索.gitignore拷贝别人写好的代码即可<br>配置.gitignore一定要在和.git隐藏文件夹同一级的目录下<br>》2.3生成好.gitignore文件之后， 还需要将.gitignore文件添加到版本控制<br>git add  .gitignore<br>git commit .gitignore -m””</p>
<p>》2.4新建项目<br>》 source conrol—&gt;commit  将代码提交到本地仓库<br>》source conrol—&gt;push 将代码提交到远程仓库</p>
<p>git中默认就会创建一个分支， 这个分支叫做origin/master， 相当于svn中的trunk</p>
<p>专业人员只需要在git仓库的hooks文件夹中写一些指令， 就可以完成自动测试（压力测试、自动测试、集成测试、冒烟测试、。。。）</p>
<p>》 和SVN一样， 如果服务器仓库的代码被修改了， 我们再提交代码也会报错。<br>fetch first == out of data</p>
<p>总结：<br>git和svn最大的区别<br>》1.git每次修改新增都需要add<br>》2.git每台电脑都有一个仓库<br>》3.git是先提交到本地仓库， 再提交到远程仓库</p>
<p>新人服务器搭建<br>1.新建一个新人服务器<br>2.初始化仓库<br>git init –bare<br>3.添加一个新的远程仓库<br>source control —&gt; master —&gt;config —&gt;remotes —&gt;add —&gt; add remote<br>4.将经理最新的代码提交到新人服务器<br>5.经理分配新人服务器的地址给新人</p>
<p>GIT的分支管理<br>》在本地代码库给项目打上一个标签<br>git tag -a v1.0 -m ‘Version 1.0’<br>》查看当前标签<br>git tag<br>注意： 此时此刻打上的这个标签仅仅是一个本地标签。（和服务器没有关系）<br>》将标签添推送到远程代码库中<br>git push origin v1.0</p>
<p>1.开发<br>2.发布<br>3.保存稳定版本<br>4.继续开发<br>5.出现bug<br>6.分配员工到分支上修复bug</p>
<blockquote>
<p>员工从服务器下载最新代码<br>》员工利用git checkout v1.0指令快速切换到1.0版本<br>》根据提示：开启一个新的分支开始修复代码<br>git checkout -b 1.0bug_fix</p>
</blockquote>
<p>7.合并修复后的代码到主线<br>8.备份稳定版本</p>
<p>通过Xcode将代码提交到github上， 把仓库放在github上</p>
<p>》1.注册一个github账号<br>》2.配置SSH Keys， 只要配置了SSH Keys就可以和github无缝衔接</p>
<p>》点击昵称来到个人主页<br>》点击主页中的设置（setting）<br>》点击SSH Keys<br>》点击 generating SSH keys</p>
<p>》1.检查本地的ssh keys<br>在“用户目录”下 ls -al ~/.ssh</p>
<p>2.如果文件夹不存在需要手动创建一个<br>mkdir .ssh</p>
<p>3.根据github的提示2生成ssh keys<br>在.ssh目录下执行 ssh-keygen -t rsa -C “your_email@example.com”<br>输入完成之后连续按下回车， 知道出现牛逼的图形位置</p>
<p>4.生成完公钥和私钥之后输入<br>ls -la查看是否生成成功   id_rsa（私钥） id_rsa.pub(公钥)</p>
<p>5.根据提示3获得公钥<br>pbcopy &lt; ~/.ssh/id_rsa.pub</p>
<p>6.点击 setting —》 ssh key —&gt;add ssh key<br>将刚才获取到得公钥添加进去</p>
<p>7.更具github第4步提示， 验证公钥<br>验证成功网页上的灰色圆点会变成绿色</p>
<p>8.拷贝到公钥之后打开github主页<br>》点击仓库（Repositories）<br>》再点击new来到github创建仓库界面</p>
<p>9.通过github提供的地址下载一个空得仓库到本地<br>》创建一个新的项目到本地仓库文件夹中<br>》利用Xcode提交代码到github<br>》注意： 要求输入用户名密码时候， 输入的是github上显示的昵称而不是登录账号</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios关键字const、static、extern]]></title>
      <url>http://yoursite.com/2017/02/20/const-static-extern%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="const、static、extern简介"><a href="#const、static、extern简介" class="headerlink" title="const、static、extern简介"></a>const、static、extern简介</h3><h3 id="一、const与宏的区别（面试题）"><a href="#一、const与宏的区别（面试题）" class="headerlink" title="一、const与宏的区别（面试题）:"></a>一、const与宏的区别（面试题）:</h3><ul>
<li><code>const简介</code>:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。</li>
<li><code>编译时刻</code>:宏是预编译（编译之前处理），const是编译阶段。</li>
<li><code>编译检查</code>:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>
<li><code>宏的好处</code>:宏能定义一些函数，方法。 const不能。</li>
<li><code>宏的坏处</code>:使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>
</ul>
<p>注意:很多Blog都说使用宏，会消耗很多内存，我这验证并不会生成很多内存，宏定义的是常量，常量都放在常量区，只会生成一份内存。<br><img src="/Users/yuanzheng/Desktop/项目准备/课堂笔记/Const/Snip20151014_1.png" alt=""></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常见的常量：抽成宏</span></div><div class="line"><span class="meta">#define XMGAccount @<span class="meta-string">"account"</span></span></div><div class="line"></div><div class="line"><span class="meta">#define XMGUserDefault [NSUserDefaults standardUserDefaults]</span></div><div class="line"></div><div class="line"><span class="comment">// 字符串常量</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> account = <span class="string">@"account"</span>;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line"><span class="comment">// 偏好设置存储</span></div><div class="line"><span class="comment">// 使用宏</span></div><div class="line">[XMGUserDefault setValue:<span class="string">@"123"</span> forKey:XMGAccount];</div><div class="line"></div><div class="line"><span class="comment">// 使用const常量</span></div><div class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setValue:<span class="string">@"123"</span> forKey:account];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、const作用：限制类型"><a href="#二、const作用：限制类型" class="headerlink" title="二、const作用：限制类型"></a>二、const作用：限制类型</h3><ul>
<li>1.const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）</li>
<li><p>2.被const修饰的变量是只读的。</p>
</li>
<li><p><code>const基本使用</code></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line"></div><div class="line"><span class="comment">// 定义变量</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// 允许修改值</span></div><div class="line">a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// const两种用法</span></div><div class="line"><span class="comment">// const:修饰基本变量p</span></div><div class="line"><span class="comment">// 这两种写法是一样的，const只修饰右边的基本变量b</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> b = <span class="number">20</span>; <span class="comment">// b:只读变量</span></div><div class="line"></div><div class="line"><span class="comment">// 不允许修改值</span></div><div class="line">b = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// const:修饰指针变量*p，带*的变量，就是指针变量.</span></div><div class="line"><span class="comment">// 定义一个指向int类型的指针变量，指向a的地址</span></div><div class="line"><span class="keyword">int</span> *p = &amp;a;</div><div class="line"></div><div class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</div><div class="line"></div><div class="line">p = &amp;c;</div><div class="line"></div><div class="line"><span class="comment">// 允许修改p指向的地址，</span></div><div class="line"><span class="comment">// 允许修改p访问内存空间的值</span></div><div class="line">*p = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// const修饰指针变量访问的内存空间，修饰的是右边*p1，</span></div><div class="line"><span class="comment">// 两种方式一样</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1; <span class="comment">// *p1：常量 p1:变量</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p1; <span class="comment">// *p1：常量 p1:变量</span></div><div class="line"></div><div class="line"><span class="comment">// const修饰指针变量p1</span></div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1:变量 p1:常量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 第一个const修饰*p1 第二个const修饰 p1</span></div><div class="line"><span class="comment">// 两种方式一样</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p1; <span class="comment">// *p1：常量 p1：常量</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p1;  <span class="comment">// *p1：常量 p1：常量</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三、const开发中使用场景"><a href="#三、const开发中使用场景" class="headerlink" title="三、const开发中使用场景:"></a>三、const开发中使用场景:</h3><ul>
<li>1.当一个方法参数只读</li>
<li>2.定义只读全局变量</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"><span class="comment">// 定义只读全局常量</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> str  = <span class="string">@"123"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 当一个方法的参数，只读.</span></div><div class="line">- (<span class="keyword">void</span>)test:(<span class="built_in">NSString</span> * <span class="keyword">const</span>)name</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 指针只读,不能通过指针修改值</span></div><div class="line">- (<span class="keyword">void</span>)test1:(<span class="keyword">int</span> <span class="keyword">const</span> *)a&#123;</div><div class="line"></div><div class="line"><span class="comment">//    *a = 10;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 基本数据类型只读</span></div><div class="line">- (<span class="keyword">void</span>)test2:(<span class="keyword">int</span> <span class="keyword">const</span>)a&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="四、static和extern简单使用-要使用一个东西，先了解其作用"><a href="#四、static和extern简单使用-要使用一个东西，先了解其作用" class="headerlink" title="四、static和extern简单使用(要使用一个东西，先了解其作用)"></a>四、static和extern简单使用(要使用一个东西，先了解其作用)</h3><ul>
<li><code>static作用</code>:</li>
<li>修饰局部变量：</li>
</ul>
<p>1.延长局部变量的生命周期,程序结束才会销毁。</p>
<p>2.局部变量只会生成一份内存,只会初始化一次。</p>
<ul>
<li>修饰全局变量</li>
</ul>
<p>1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改</p>
<ul>
<li><code>extern作用</code>:</li>
<li>只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</li>
<li><code>extern工作原理</code>:</li>
<li>先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局变量：只有一份内存，所有文件共享，与extern联合使用。</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// static修饰全局变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">20</span>;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)test</div><div class="line">&#123;</div><div class="line"><span class="comment">// static修饰局部变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">0</span>;</div><div class="line">age++;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line"></div><div class="line"></div><div class="line">    [<span class="keyword">self</span> test];</div><div class="line">    [<span class="keyword">self</span> test];</div><div class="line"></div><div class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,age);</div><div class="line">&#125;</div><div class="line">I</div></pre></td></tr></table></figure>
<h3 id="五、static与const联合使用"><a href="#五、static与const联合使用" class="headerlink" title="五、static与const联合使用"></a>五、static与const联合使用</h3><ul>
<li>static与const作用:声明一个只读的静态变量</li>
<li>开发使用场景:在<code>一个文件中</code>经常使用的字符串常量，可以使用static与const组合</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开发中常用static修饰全局变量,只改变作用域</span></div><div class="line"></div><div class="line"><span class="comment">// 为什么要改变全局变量作用域，防止重复声明全局变量。</span></div><div class="line"></div><div class="line"><span class="comment">// 开发中声明的全局变量，有些不希望外界改动，只允许读取。</span></div><div class="line"></div><div class="line"><span class="comment">// 比如一个基本数据类型不希望别人改动</span></div><div class="line"></div><div class="line"><span class="comment">// 声明一个静态的全局只读常量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">// staic和const联合的作用:声明一个静态的全局只读常量</span></div><div class="line"></div><div class="line"><span class="comment">// iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量.</span></div><div class="line"></div><div class="line"><span class="comment">// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。</span></div><div class="line"><span class="keyword">static</span>  <span class="built_in">NSString</span> * <span class="keyword">const</span> key = <span class="string">@"name"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。</span></div><div class="line"></div><div class="line"><span class="keyword">static</span>  <span class="built_in">NSString</span> <span class="keyword">const</span> *key1 = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure>
<h3 id="六、extern与const联合使用"><a href="#六、extern与const联合使用" class="headerlink" title="六、extern与const联合使用"></a>六、extern与const联合使用</h3><ul>
<li>开发中使用场景:在<code>多个文件中</code>经常使用的同一个字符串常量，可以使用extern与const组合。</li>
<li>原因:</li>
<li>static与const组合：在每个文件都需要定义一份静态全局变量。</li>
<li>extern与const组合:只需要定义一份全局变量，多个文件共享。</li>
<li>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</li>
</ul>
<ul>
<li>GlobeConst.h</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> nameKey = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure>
<ul>
<li>GlobeConst.m</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> nameKey = <span class="string">@"name"</span>;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios运行时Runtime]]></title>
      <url>http://yoursite.com/2017/02/20/Runtime/</url>
      <content type="html"><![CDATA[<h3 id="一、runtime简介"><a href="#一、runtime简介" class="headerlink" title="一、runtime简介"></a>一、runtime简介</h3><ul>
<li>RunTime简称运行时。OC就是<code>运行时机制</code>，也就是在运行时候的一些机制，其中最主要的是消息机制。</li>
<li>对于C语言，<code>函数的调用在编译的时候会决定调用哪个函数</code>。</li>
<li>对于OC的函数，属于<code>动态调用过程</code>，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。</li>
<li>事实证明：</li>
<li>在编译阶段，OC可以<code>调用任何函数</code>，即使这个函数并未实现，只要声明过就不会报错。</li>
<li>在编译阶段，C语言调用<code>未实现的函数</code>就会报错。</li>
</ul>
<h3 id="二、runtime作用"><a href="#二、runtime作用" class="headerlink" title="二、runtime作用"></a>二、runtime作用</h3><h4 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1.发送消息"></a>1.发送消息</h4><ul>
<li>方法调用的本质，就是让对象发送消息。</li>
<li>objc_msgSend,只有对象才能发送消息，因此以objc开头.</li>
<li>使用<code>消息机制</code>前提，必须导入#import <objc message.h=""></objc></li>
<li>消息机制简单使用</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建person对象</span></div><div class="line">Person *p = [[Person alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 调用对象方法</span></div><div class="line">[p eat];</div><div class="line"></div><div class="line"><span class="comment">// 本质：让对象发送消息</span></div><div class="line">objc_msgSend(p, <span class="keyword">@selector</span>(eat));</div><div class="line"></div><div class="line"><span class="comment">// 调用类方法的方式：两种</span></div><div class="line"><span class="comment">// 第一种通过类名调用</span></div><div class="line">[Person eat];</div><div class="line"><span class="comment">// 第二种通过类对象调用</span></div><div class="line">[[Person <span class="keyword">class</span>] eat];</div><div class="line"></div><div class="line"><span class="comment">// 用类名调用类方法，底层会自动把类名转换成类对象调用</span></div><div class="line"><span class="comment">// 本质：让类对象发送消息</span></div><div class="line">objc_msgSend([Person <span class="keyword">class</span>], <span class="keyword">@selector</span>(eat));</div></pre></td></tr></table></figure>
<ul>
<li>消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现</li>
<li><img src="Snip20151013_4.png" alt=""></li>
</ul>
<h4 id="2-交换方法"><a href="#2-交换方法" class="headerlink" title="2.交换方法"></a>2.交换方法</h4><ul>
<li>开发使用场景:系统自带的方法功能不够，给系统自带的方法扩展一些功能，并且保持原有的功能。</li>
<li>方式一:继承系统的类，重写方法.</li>
<li>方式二:使用runtime,交换方法.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 需求：给imageNamed方法提供功能，每次加载图片就判断下图片是否加载成功。</span></div><div class="line">    <span class="comment">// 步骤一：先搞个分类，定义一个能加载图片并且能打印的方法+ (instancetype)imageWithName:(NSString *)name;</span></div><div class="line">    <span class="comment">// 步骤二：交换imageNamed和imageWithName的实现，就能调用imageWithName，间接调用imageWithName的实现。</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"123"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">Image</span>)</span></div><div class="line"><span class="comment">// 加载分类到内存的时候调用</span></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 交换方法</span></div><div class="line">    <span class="comment">// 获取imageWithName方法地址</span></div><div class="line">    Method imageWithName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageWithName:));</div><div class="line"></div><div class="line">    <span class="comment">// 获取imageWithName方法地址</span></div><div class="line">    Method imageName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageNamed:));</div><div class="line"></div><div class="line">    <span class="comment">// 交换方法地址，相当于交换实现方式</span></div><div class="line">    method_exchangeImplementations(imageWithName, imageName);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</span></div><div class="line"></div><div class="line"><span class="comment">// 既能加载图片又能打印</span></div><div class="line">+ (<span class="keyword">instancetype</span>)imageWithName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 这里调用imageWithName，相当于调用imageName</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageWithName:name];</div><div class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"加载空的图片"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>交换原理：</li>
<li><p>交换之前：<br><img src="Snip20151013_2.png" alt=""></p>
</li>
<li><p>交换之后：<br><img src="Snip20151013_3.png" alt=""></p>
</li>
</ul>
<h4 id="3-动态添加方法"><a href="#3-动态添加方法" class="headerlink" title="3.动态添加方法"></a>3.动态添加方法</h4><ul>
<li>开发使用场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。</li>
<li>经典面试题：有没有使用performSelector，其实主要想问你有没有动态添加过方法。</li>
<li>简单使用</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    Person *p = [[Person alloc] init];</div><div class="line">    <span class="comment">// 默认person，没有实现eat方法，可以通过performSelector调用，但是会报错。</span></div><div class="line">    <span class="comment">// 动态添加方法就不会报错</span></div><div class="line">    [p performSelector:<span class="keyword">@selector</span>(eat)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"><span class="comment">// void(*)()</span></div><div class="line"><span class="comment">// 默认方法都有两个隐式参数，</span></div><div class="line"><span class="keyword">void</span> eat(<span class="keyword">id</span> <span class="keyword">self</span>,SEL sel)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,<span class="keyword">self</span>,<span class="built_in">NSStringFromSelector</span>(sel));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 当一个对象调用未实现的方法，会调用这个方法处理,并且会把对应的方法列表传过来.</span></div><div class="line"><span class="comment">// 刚好可以用来判断，未实现的方法是不是我们想要动态添加的方法</span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(eat)) &#123;</div><div class="line">        <span class="comment">// 动态添加eat方法</span></div><div class="line">        <span class="comment">// 第一个参数：给哪个类添加方法</span></div><div class="line">        <span class="comment">// 第二个参数：添加方法的方法编号</span></div><div class="line">        <span class="comment">// 第三个参数：添加方法的函数实现（函数地址）</span></div><div class="line">        <span class="comment">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></div><div class="line">        class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(eat), eat, <span class="string">"v@:"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="4-给分类添加属性"><a href="#4-给分类添加属性" class="headerlink" title="4.给分类添加属性"></a>4.给分类添加属性</h4><ul>
<li>原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">[<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 给系统NSObject类动态添加属性name</span></div><div class="line">    <span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    objc.name = <span class="string">@"小码哥"</span>;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,objc.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 定义关联的key</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"name"</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Property</span>)</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 根据关联的key，获取关联的值。</span></div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, key);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 第一个参数：给哪个对象添加关联</span></div><div class="line">    <span class="comment">// 第二个参数：关联的key，通过这个key获取</span></div><div class="line">    <span class="comment">// 第三个参数：关联的value</span></div><div class="line">    <span class="comment">// 第四个参数:关联的策略</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="5-字典转模型"><a href="#5-字典转模型" class="headerlink" title="5.字典转模型"></a>5.字典转模型</h4><ul>
<li>设计模型：字典转模型的第一步</li>
<li>模型属性，通常需要跟字典中的key一一对应</li>
<li>问题：一个一个的生成模型属性，很慢？</li>
<li>需求：能不能自动根据一个字典，生成对应的属性。</li>
<li>解决：提供一个分类，专门根据字典生成对应的属性字符串。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Log</span>)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 自动打印属性字符串</span></div><div class="line">+ (<span class="keyword">void</span>)resolveDict:(<span class="built_in">NSDictionary</span> *)dict&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 拼接属性字符串代码</span></div><div class="line">    <span class="built_in">NSMutableString</span> *strM = [<span class="built_in">NSMutableString</span> string];</div><div class="line"></div><div class="line">    <span class="comment">// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</span></div><div class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 类型经常变，抽出来</span></div><div class="line">    <span class="built_in">NSString</span> *type;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFString"</span>)]) &#123;</div><div class="line">        type = <span class="string">@"NSString"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFArray"</span>)])&#123;</div><div class="line">        type = <span class="string">@"NSArray"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFNumber"</span>)])&#123;</div><div class="line">        type = <span class="string">@"int"</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFDictionary"</span>)])&#123;</div><div class="line">        type = <span class="string">@"NSDictionary"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 属性字符串</span></div><div class="line">    <span class="built_in">NSString</span> *str;</div><div class="line">    <span class="keyword">if</span> ([type containsString:<span class="string">@"NS"</span>]) &#123;</div><div class="line">    str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, strong) %@ *%@;"</span>,type,key];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">    str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, assign) %@ %@;"</span>,type,key];</div><div class="line">&#125;</div><div class="line">    <span class="comment">// 每生成属性字符串，就自动换行。</span></div><div class="line">    [strM appendFormat:<span class="string">@"\n%@\n"</span>,str];</div><div class="line"></div><div class="line">    &#125;];</div><div class="line">    <span class="comment">// 把拼接好的字符串打印出来，就好了。</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strM);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>字典转模型的方式一：KVC</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Status</span></span></div><div class="line"></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)statusWithDict:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    Status *status = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    [status setValuesForKeysWithDictionary:dict];</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>KVC字典转模型弊端：必须保证，模型中的属性和字典中的key一一对应。</li>
<li>如果不一致，就会调用<code>[&lt;Status 0x7fa74b545d60&gt; setValue:forUndefinedKey:]</code><br>报<code>key</code>找不到的错。    </li>
<li>分析:模型中的属性和字典的key不一一对应，系统就会调用<code>setValue:forUndefinedKey:</code>报错。</li>
<li>解决:重写对象的<code>setValue:forUndefinedKey:</code>,把系统的方法覆盖，<br>就能继续使用KVC，字典转模型了。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forUndefinedKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>字典转模型的方式二：Runtime</li>
<li>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。</li>
<li>步骤：提供一个NSObject分类，专门字典转模型，以后所有模型都可以通过这个分类转。 </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></div><div class="line">    <span class="comment">// 解析Plist文件</span></div><div class="line">    <span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"status.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSDictionary</span> *statusDict = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:filePath];</div><div class="line">    <span class="comment">// 获取字典数组</span></div><div class="line">    <span class="built_in">NSArray</span> *dictArr = statusDict[<span class="string">@"statuses"</span>];</div><div class="line">    <span class="comment">// 自动生成模型的属性字符串</span></div><div class="line">    <span class="comment">// [NSObject resolveDict:dictArr[0][@"user"]];</span></div><div class="line">    _statuses = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">    <span class="comment">// 遍历字典数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> dictArr) &#123;</div><div class="line">        Status *status = [Status modelWithDict:dict];</div><div class="line">        [_statuses addObject:status];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 测试数据</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,_statuses,[_statuses[<span class="number">0</span>] user]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Model</span>)</span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 思路：遍历模型中所有属性-》使用运行时</span></div><div class="line"></div><div class="line">    <span class="comment">// 0.创建对应的对象</span></div><div class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 1.利用runtime给对象中的成员属性赋值</span></div><div class="line"></div><div class="line">    <span class="comment">// class_copyIvarList:获取类中的所有成员属性</span></div><div class="line">    <span class="comment">// Ivar：成员属性的意思</span></div><div class="line">    <span class="comment">// 第一个参数：表示获取哪个类中的成员属性</span></div><div class="line">    <span class="comment">// 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</span></div><div class="line">    <span class="comment">// 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</span></div><div class="line">    <span class="comment">/* 类似下面这种写法</span></div><div class="line"></div><div class="line">    Ivar ivar;</div><div class="line">    Ivar ivar1;</div><div class="line">    Ivar ivar2;</div><div class="line">    // 定义一个ivar的数组a</div><div class="line">    Ivar a[] = &#123;ivar,ivar1,ivar2&#125;;</div><div class="line"></div><div class="line">    // 用一个Ivar *指针指向数组第一个元素</div><div class="line">    Ivar *ivarList = a;</div><div class="line"></div><div class="line">    // 根据指针访问数组第一个元素</div><div class="line">    ivarList[0];</div><div class="line"></div><div class="line">    */</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="comment">// 获取类中的所有成员属性</span></div><div class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 根据角标，从数组取出对应的成员属性</span></div><div class="line">                Ivar ivar = ivarList[i];</div><div class="line"></div><div class="line">                <span class="comment">// 获取成员属性名</span></div><div class="line">                <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</div><div class="line"></div><div class="line">                <span class="comment">// 处理成员属性名-&gt;字典中的key</span></div><div class="line">                <span class="comment">// 从第一个角标开始截取</span></div><div class="line">                <span class="built_in">NSString</span> *key = [name substringFromIndex:<span class="number">1</span>];</div><div class="line"></div><div class="line">                <span class="comment">// 根据成员属性名去字典中查找对应的value</span></div><div class="line">                <span class="keyword">id</span> value = dict[key];</div><div class="line"></div><div class="line">                <span class="comment">// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span></div><div class="line">                <span class="comment">// 判断下value是否是字典</span></div><div class="line">                <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                    <span class="comment">// 字典转模型</span></div><div class="line">                    <span class="comment">// 获取模型的类对象，调用modelWithDict</span></div><div class="line">                    <span class="comment">// 模型的类名已知，就是成员属性的类型</span></div><div class="line"></div><div class="line">                    <span class="comment">// 获取成员属性类型</span></div><div class="line">                    <span class="built_in">NSString</span> *type = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</div><div class="line">                    <span class="comment">// 生成的是这种@"@\"User\"" 类型 -》 @"User"  在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符</span></div><div class="line">                    <span class="comment">// 裁剪类型字符串</span></div><div class="line">                    <span class="built_in">NSRange</span> range = [type rangeOfString:<span class="string">@"\""</span>];</div><div class="line"></div><div class="line">                    type = [type substringFromIndex:range.location + range.length];</div><div class="line"></div><div class="line">                    range = [type rangeOfString:<span class="string">@"\""</span>];</div><div class="line"></div><div class="line">                    <span class="comment">// 裁剪到哪个角标，不包括当前角标</span></div><div class="line">                    type = [type substringToIndex:range.location];</div><div class="line"></div><div class="line">                    <span class="comment">// 根据字符串类名生成类对象</span></div><div class="line">                    Class modelClass = <span class="built_in">NSClassFromString</span>(type);</div><div class="line"></div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (modelClass) &#123; <span class="comment">// 有对应的模型才需要转</span></div><div class="line">                        <span class="comment">// 把字典转模型</span></div><div class="line">                        value  =  [modelClass modelWithDict:value];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span></div><div class="line">        <span class="comment">// 判断值是否是数组</span></div><div class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            <span class="comment">// 判断对应类有没有实现字典数组转模型数组的协议</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(arrayContainModelClass)]) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 转换成id类型，就能调用任何对象的方法</span></div><div class="line">                <span class="keyword">id</span> idSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">                <span class="comment">// 获取数组中字典对应的模型</span></div><div class="line">                <span class="built_in">NSString</span> *type =  [idSelf arrayContainModelClass][key];</div><div class="line"></div><div class="line">                <span class="comment">// 生成模型</span></div><div class="line">                Class classModel = <span class="built_in">NSClassFromString</span>(type);</div><div class="line">                <span class="built_in">NSMutableArray</span> *arrM = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">                <span class="comment">// 遍历字典数组，生成模型数组</span></div><div class="line">                <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> value) &#123;</div><div class="line">                    <span class="comment">// 字典转模型</span></div><div class="line">                    <span class="keyword">id</span> model =  [classModel modelWithDict:dict];</div><div class="line">                    [arrM addObject:model];</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// 把模型数组赋值给value</span></div><div class="line">                value = arrM;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (value) &#123; <span class="comment">// 有值，才需要给模型的属性赋值</span></div><div class="line">            <span class="comment">// 利用KVC给模型中的属性赋值</span></div><div class="line">            [objc setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> objc;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios之ReactiveCocoa的使用]]></title>
      <url>http://yoursite.com/2017/02/19/ReactiveCocoa/</url>
      <content type="html"><![CDATA[<h3 id="1-ReactiveCocoa简介"><a href="#1-ReactiveCocoa简介" class="headerlink" title="1.ReactiveCocoa简介"></a>1.ReactiveCocoa简介</h3><p>ReactiveCocoa（简称为<code>RAC</code>）,是由<code>Github</code>开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。</p>
<h3 id="2-ReactiveCocoa作用"><a href="#2-ReactiveCocoa作用" class="headerlink" title="2.ReactiveCocoa作用"></a>2.ReactiveCocoa作用</h3><ul>
<li>在我们iOS开发过程中，当某些事件响应的时候，需要处理某些业务逻辑,这些事件都用不同的方式来处理。</li>
<li>比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO等系统提供的方式。</li>
<li>其实这些事件，都可以通过RAC处理</li>
<li>ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。非常符合我们开发中<code>高聚合，低耦合</code>的思想。</li>
</ul>
<h3 id="3-编程思想"><a href="#3-编程思想" class="headerlink" title="3.编程思想"></a>3.编程思想</h3><p>在开发中我们也不能太依赖于某个框架，否则这个框架不更新了，导致项目后期没办法维护，比如之前Facebook提供的<code>Three20框架</code>，在当时也是神器，但是后来不更新了，也就没什么人用了。因此我感觉学习一个框架，还是有必要了解它的<code>编程思想</code>。</p>
<p><code>编程思想的由来</code>：在开发中我们会遇见各种各样的需求，经常会思考如何快速的完成这些需求，这样就会慢慢形成快速完成这些需求的思想。</p>
<p>先简单介绍下目前咱们已知的<code>编程思想</code>。</p>
<p>3.1 <code>面向过程</code>：处理事情以过程为核心，一步一步的实现。</p>
<p>3.2 <code>面向对象</code>：万物皆对象</p>
<p>3.3 <code>链式编程思想</code>：是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。a(1).b(2).c(3)</p>
<ul>
<li><p><code>链式编程特点</code>：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）</p>
</li>
<li><p><code>代表</code>：masonry框架。</p>
</li>
<li><p><code>练习一</code>:模仿masonry，写一个加法计算器，练习链式编程思想。</p>
</li>
</ul>
<p>3.4 <code>响应式编程思想</code>：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。</p>
<ul>
<li><p><code>代表</code>：KVO运用。</p>
</li>
<li><p><code>练习二</code>:KVO底层实现。</p>
</li>
</ul>
<p>3.5 <code>函数式编程思想</code>：是把操作尽量写成一系列嵌套的函数或者方法调用。</p>
<ul>
<li><code>函数式编程本质</code>:就是往方法中传入Block,方法中嵌套Block调用，把代码聚合起来管理</li>
<li><p><code>函数式编程特点</code>：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）</p>
</li>
<li><p><code>代表</code>：ReactiveCocoa。</p>
</li>
<li><p><code>练习三</code>:用函数式编程实现，写一个加法计算器,并且加法计算器自带判断是否等于某个值.</p>
</li>
</ul>
<h3 id="4-ReactiveCocoa编程思想"><a href="#4-ReactiveCocoa编程思想" class="headerlink" title="4.ReactiveCocoa编程思想"></a>4.ReactiveCocoa编程思想</h3><p>ReactiveCocoa结合了几种编程风格：</p>
<p><code>函数式编程（Functional Programming）</code></p>
<p><code>响应式编程（Reactive Programming）</code></p>
<p>所以，你可能听说过ReactiveCocoa被描述为函数响应式编程（FRP）框架。</p>
<p>以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。</p>
<h3 id="5-如何导入ReactiveCocoa框架"><a href="#5-如何导入ReactiveCocoa框架" class="headerlink" title="5.如何导入ReactiveCocoa框架"></a>5.如何导入ReactiveCocoa框架</h3><p>通常都会使用CocoaPods（用于管理第三方框架的插件）帮助我们导入。</p>
<p>CocoaPods教程（<a href="http://code4app.com/article/cocoapods-install-usage）" target="_blank" rel="external">http://code4app.com/article/cocoapods-install-usage）</a></p>
<p><code>练习四</code>:创建一个新的工程，演示下，框架的导入。</p>
<p><code>注意</code>：</p>
<ul>
<li>podfile如果只描述pod ‘ReactiveCocoa’, ‘~&gt; 4.0.2-alpha-1’，会导入不成功<br><img src="Snip20150926_1.png" alt=""></li>
<li>报错信息<br><img src="Snip20150926_2.png" alt=""></li>
<li>需要在podfile加上use_frameworks，重新pod install 才能导入成功。<br><img src="Snip20150926_3.png" alt=""></li>
</ul>
<h3 id="6-ReactiveCocoa常见类。"><a href="#6-ReactiveCocoa常见类。" class="headerlink" title="6.ReactiveCocoa常见类。"></a>6.ReactiveCocoa常见类。</h3><p>学习框架首要之处:个人认为先要搞清楚框架中常用的类，在RAC中最核心的类RACSiganl,搞定这个类就能用ReactiveCocoa开发了。</p>
<p><code>练习五</code>:介绍常见类</p>
<p><code>RACSiganl</code>:信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>
<ul>
<li><p>信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</p>
</li>
<li><p>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</p>
</li>
<li><p>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。</p>
</li>
<li><p><code>RACSiganl简单使用:</code></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACSignal使用步骤：</span></div><div class="line"><span class="comment">// 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span></div><div class="line"><span class="comment">// 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 3.发送信号 - (void)sendNext:(id)value</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RACSignal底层实现：</span></div><div class="line"><span class="comment">// 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。</span></div><div class="line"><span class="comment">// 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock</span></div><div class="line"><span class="comment">// 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。</span></div><div class="line"><span class="comment">// 2.1 subscribeNext内部会调用siganl的didSubscribe</span></div><div class="line"><span class="comment">// 3.siganl的didSubscribe中调用[subscriber sendNext:@1];</span></div><div class="line"><span class="comment">// 3.1 sendNext底层其实就是执行subscriber的nextBlock</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"><span class="comment">// block调用时刻：每当有订阅者订阅信号，就会调用block。</span></div><div class="line"></div><div class="line"><span class="comment">// 2.发送信号</span></div><div class="line">[subscriber sendNext:@<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</span></div><div class="line">[subscriber sendCompleted];</div><div class="line"></div><div class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line"></div><div class="line"><span class="comment">// block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</span></div><div class="line"></div><div class="line"><span class="comment">// 执行完Block后，当前信号就不在被订阅了。</span></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"信号被销毁"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号,才会激活信号.</span></div><div class="line">[siganl subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// block调用时刻：每当有信号发出数据，就会调用block.</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"接收到数据:%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>RACSubscriber</code>:表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</p>
<p><code>RACDisposable</code>:用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</p>
<ul>
<li><code>使用场景</code>:不想监听某个信号时，可以通过它主动取消订阅信号。</li>
</ul>
<p><code>RACSubject</code>:RACSubject:信号提供者，自己可以充当信号，又能发送信号。</p>
<ul>
<li><code>使用场景</code>:通常用来代替代理，有了它，就不必要定义代理了。</li>
</ul>
<p><code>RACReplaySubject</code>:重复提供信号类，RACSubject的子类。</p>
<ul>
<li><code>RACReplaySubject</code>与<code>RACSubject</code>区别:</li>
<li>RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。</li>
<li><code>使用场景一</code>:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</li>
<li><p><code>使用场景二</code>:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。</p>
</li>
<li><p><code>RACSubject和RACReplaySubject简单使用:</code></p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACSubject使用步骤</span></div><div class="line"><span class="comment">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span></div><div class="line"><span class="comment">// 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 3.发送信号 sendNext:(id)value</span></div><div class="line"></div><div class="line"><span class="comment">// RACSubject:底层实现和RACSignal不一样。</span></div><div class="line"><span class="comment">// 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</span></div><div class="line"><span class="comment">// 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSubject *subject = [RACSubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// block调用时刻：当信号发出新值，就会调用.</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者%@"</span>,x);</div><div class="line">&#125;];</div><div class="line">[subject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// block调用时刻：当信号发出新值，就会调用.</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.发送信号</span></div><div class="line">[subject sendNext:<span class="string">@"1"</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RACReplaySubject使用步骤:</span></div><div class="line"><span class="comment">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span></div><div class="line"><span class="comment">// 2.可以先订阅信号，也可以先发送信号。</span></div><div class="line"><span class="comment">// 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span></div><div class="line"><span class="comment">// 2.2 发送信号 sendNext:(id)value</span></div><div class="line"></div><div class="line"><span class="comment">// RACReplaySubject:底层实现和RACSubject不一样。</span></div><div class="line"><span class="comment">// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span></div><div class="line"><span class="comment">// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock</span></div><div class="line"></div><div class="line"><span class="comment">// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。</span></div><div class="line"><span class="comment">// 也就是先保存值，在订阅值。</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACReplaySubject *replaySubject = [RACReplaySubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 2.发送信号</span></div><div class="line">[replaySubject sendNext:@<span class="number">1</span>];</div><div class="line">[replaySubject sendNext:@<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号</span></div><div class="line">[replaySubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者接收到的数据%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 订阅信号</span></div><div class="line">[replaySubject subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者接收到的数据%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<ul>
<li><code>RACSubject替换代理</code></li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 需求:</span></div><div class="line"><span class="comment">// 1.给当前控制器添加一个按钮，modal到另一个控制器界面</span></div><div class="line"><span class="comment">// 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器</span></div><div class="line"></div><div class="line">步骤一：在第二个控制器.h，添加一个RACSubject代替代理。</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TwoViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RACSubject *delegateSignal;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">步骤二：监听第二个控制器按钮点击</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TwoViewController</span></span></div><div class="line">- (<span class="keyword">IBAction</span>)notice:(<span class="keyword">id</span>)sender &#123;</div><div class="line"><span class="comment">// 通知第一个控制器，告诉它，按钮被点了</span></div><div class="line"></div><div class="line"><span class="comment">// 通知代理</span></div><div class="line"><span class="comment">// 判断代理信号是否有值</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.delegateSignal) &#123;</div><div class="line"><span class="comment">// 有值，才需要通知</span></div><div class="line">[<span class="keyword">self</span>.delegateSignal sendNext:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OneViewController</span></span></div><div class="line">- (<span class="keyword">IBAction</span>)btnClick:(<span class="keyword">id</span>)sender &#123;</div><div class="line"></div><div class="line"><span class="comment">// 创建第二个控制器</span></div><div class="line">TwoViewController *twoVc = [[TwoViewController alloc] init];</div><div class="line"></div><div class="line"><span class="comment">// 设置代理信号</span></div><div class="line">twoVc.delegateSignal = [RACSubject subject];</div><div class="line"></div><div class="line"><span class="comment">// 订阅代理信号</span></div><div class="line">[twoVc.delegateSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"点击了通知按钮"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 跳转到第二个控制器</span></div><div class="line">[<span class="keyword">self</span> presentViewController:twoVc animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><code>RACTuple</code>:元组类,类似NSArray,用来包装值.</p>
<p><code>RACSequence</code>:RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。</p>
<p><code>使用场景</code>：1.字典转模型</p>
<p><code>RACSequence和RACTuple简单使用</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.遍历数组</span></div><div class="line"><span class="built_in">NSArray</span> *numbers = @[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">4</span>];</div><div class="line"></div><div class="line"><span class="comment">// 这里其实是三步</span></div><div class="line"><span class="comment">// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence</span></div><div class="line"><span class="comment">// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal</span></div><div class="line"><span class="comment">// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。</span></div><div class="line">[numbers.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 2.遍历字典,遍历出来的键值对会包装成RACTuple(元组对象)</span></div><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"name"</span>:<span class="string">@"xmg"</span>,<span class="string">@"age"</span>:@<span class="number">18</span>&#125;;</div><div class="line">[dict.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;</div><div class="line"></div><div class="line"><span class="comment">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span></div><div class="line">RACTupleUnpack(<span class="built_in">NSString</span> *key,<span class="built_in">NSString</span> *value) = x;</div><div class="line"></div><div class="line"><span class="comment">// 相当于以下写法</span></div><div class="line"><span class="comment">//        NSString *key = x[0];</span></div><div class="line"><span class="comment">//        NSString *value = x[1];</span></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,key,value);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3.字典转模型</span></div><div class="line"><span class="comment">// 3.1 OC写法</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *items = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> dictArr) &#123;</div><div class="line">FlagItem *item = [FlagItem flagWithDict:dict];</div><div class="line">[items addObject:item];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 3.2 RAC写法</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *flags = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">_flags = flags;</div><div class="line"></div><div class="line"><span class="comment">// rac_sequence注意点：调用subscribeNext，并不会马上执行nextBlock，而是会等一会。</span></div><div class="line">[dictArr.rac_sequence.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="comment">// 运用RAC遍历字典，x：字典</span></div><div class="line"></div><div class="line">FlagItem *item = [FlagItem flagWithDict:x];</div><div class="line"></div><div class="line">[flags addObject:item];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,  <span class="built_in">NSStringFromCGRect</span>([<span class="built_in">UIScreen</span> mainScreen].bounds));</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3.3 RAC高级写法:</span></div><div class="line"><span class="built_in">NSString</span> *filePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"flags.plist"</span> ofType:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSArray</span> *dictArr = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:filePath];</div><div class="line"><span class="comment">// map:映射的意思，目的：把原始值value映射成一个新值</span></div><div class="line"><span class="comment">// array: 把集合转换成数组</span></div><div class="line"><span class="comment">// 底层实现：当信号被订阅，会遍历集合中的原始值，映射成新值，并且保存到新的数组里。</span></div><div class="line"><span class="built_in">NSArray</span> *flags = [[dictArr.rac_sequence map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line"></div><div class="line"><span class="keyword">return</span> [FlagItem flagWithDict:value];</div><div class="line"></div><div class="line">&#125;] array];</div></pre></td></tr></table></figure>
<p><code>RACMulticastConnection</code>:用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</p>
<p><code>使用注意</code>:RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.</p>
<p><code>RACMulticastConnection简单使用</code>:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RACMulticastConnection使用步骤:</span></div><div class="line"><span class="comment">// 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span></div><div class="line"><span class="comment">// 2.创建连接 RACMulticastConnection *connect = [signal publish];</span></div><div class="line"><span class="comment">// 3.订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]</span></div><div class="line"><span class="comment">// 4.连接 [connect connect]</span></div><div class="line"></div><div class="line"><span class="comment">// RACMulticastConnection底层原理:</span></div><div class="line"><span class="comment">// 1.创建connect，connect.sourceSignal -&gt; RACSignal(原始信号)  connect.signal -&gt; RACSubject</span></div><div class="line"><span class="comment">// 2.订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。</span></div><div class="line"><span class="comment">// 3.[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject</span></div><div class="line"><span class="comment">// 3.1.订阅原始信号，就会调用原始信号中的didSubscribe</span></div><div class="line"><span class="comment">// 3.2 didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext</span></div><div class="line"><span class="comment">// 4.RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。</span></div><div class="line"><span class="comment">// 4.1 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。</span></div><div class="line"><span class="comment">// 解决：使用RACMulticastConnection就能解决.</span></div><div class="line"></div><div class="line"><span class="comment">// 1.创建请求信号</span></div><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"发送请求"</span>);</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"接收数据"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"><span class="comment">// 2.订阅信号</span></div><div class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"接收数据"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.运行结果，会执行两遍发送请求，也就是每次订阅都会发送一次请求</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RACMulticastConnection:解决重复请求问题</span></div><div class="line"><span class="comment">// 1.创建信号</span></div><div class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"发送请求"</span>);</div><div class="line">[subscriber sendNext:@<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2.创建连接</span></div><div class="line">RACMulticastConnection *connect = [signal publish];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号，</span></div><div class="line"><span class="comment">// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接,当调用连接，就会一次性调用所有订阅者的sendNext:</span></div><div class="line">[connect.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"订阅者一信号"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line">[connect.signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"订阅者二信号"</span>);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 4.连接,激活信号</span></div><div class="line">[connect connect];</div></pre></td></tr></table></figure>
<p><code>RACCommand</code>:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</p>
<p><code>使用场景</code>:监听按钮点击，网络请求</p>
<p><code>RACCommand简单使用</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 一、RACCommand使用步骤:</span></div><div class="line"><span class="comment">// 1.创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock</span></div><div class="line"><span class="comment">// 2.在signalBlock中，创建RACSignal，并且作为signalBlock的返回值</span></div><div class="line"><span class="comment">// 3.执行命令 - (RACSignal *)execute:(id)input</span></div><div class="line"></div><div class="line"><span class="comment">// 二、RACCommand使用注意:</span></div><div class="line"><span class="comment">// 1.signalBlock必须要返回一个信号，不能传nil.</span></div><div class="line"><span class="comment">// 2.如果不想要传递信号，直接创建空的信号[RACSignal empty];</span></div><div class="line"><span class="comment">// 3.RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</span></div><div class="line"></div><div class="line"><span class="comment">// 三、RACCommand设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</span></div><div class="line"><span class="comment">// 1.在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。</span></div><div class="line"><span class="comment">// 2.当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</span></div><div class="line"></div><div class="line"><span class="comment">// 四、如何拿到RACCommand中返回信号发出的数据。</span></div><div class="line"><span class="comment">// 1.RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</span></div><div class="line"><span class="comment">// 2.订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</span></div><div class="line"></div><div class="line"><span class="comment">// 五、监听当前命令是否正在执行executing</span></div><div class="line"></div><div class="line"><span class="comment">// 六、使用场景,监听按钮点击，网络请求</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 1.创建命令</span></div><div class="line">RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"执行命令"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建空信号,必须返回信号</span></div><div class="line"><span class="comment">//        return [RACSignal empty];</span></div><div class="line"></div><div class="line"><span class="comment">// 2.创建信号,用来传递数据</span></div><div class="line"><span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line">[subscriber sendNext:<span class="string">@"请求数据"</span>];</div><div class="line"></div><div class="line"><span class="comment">// 注意：数据传递完，最好调用sendCompleted，这时命令才执行完毕。</span></div><div class="line">[subscriber sendCompleted];</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 强引用命令，不要被销毁，否则接收不到数据</span></div><div class="line">_conmmand = command;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 3.执行命令</span></div><div class="line">[<span class="keyword">self</span>.conmmand execute:@<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">// 4.订阅RACCommand中的信号</span></div><div class="line">[command.executionSignals subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line">[x subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// RAC高级用法</span></div><div class="line"><span class="comment">// switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号</span></div><div class="line">[command.executionSignals.switchToLatest subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 5.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</span></div><div class="line">[[command.executing skip:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ([x boolValue] == <span class="literal">YES</span>) &#123;</div><div class="line"><span class="comment">// 正在执行</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"正在执行"</span>);</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="comment">// 执行完成</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"执行完成"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><code>RACScheduler</code>:RAC中的队列，用GCD封装的。</p>
<p><code>RACUnit</code> :表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.</p>
<p><code>RACEvent</code>: 把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。</p>
<h3 id="7-ReactiveCocoa开发中常见用法。"><a href="#7-ReactiveCocoa开发中常见用法。" class="headerlink" title="7.ReactiveCocoa开发中常见用法。"></a>7.ReactiveCocoa开发中常见用法。</h3><p>7.1 代替代理:</p>
<ul>
<li><code>rac_signalForSelector</code>：用于替代代理。</li>
</ul>
<p>7.2 代替KVO :</p>
<ul>
<li><code>rac_valuesAndChangesForKeyPath</code>：用于监听某个对象的属性改变。</li>
</ul>
<p>7.3 监听事件:</p>
<ul>
<li><code>rac_signalForControlEvents</code>：用于监听某个事件。</li>
</ul>
<p>7.4 代替通知:</p>
<ul>
<li><code>rac_addObserverForName</code>:用于监听某个通知。</li>
</ul>
<p>7.5 监听文本框文字改变:</p>
<ul>
<li><code>rac_textSignal</code>:只要文本框发出改变就会发出这个信号。</li>
</ul>
<p>7.6 处理当界面有多次请求时，需要都获取到数据时，才能展示界面</p>
<ul>
<li><code>rac_liftSelector:withSignalsFromArray:Signals</code>:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。</li>
<li>使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</li>
</ul>
<p>7.7 代码演示</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 1.代替代理</span></div><div class="line"><span class="comment">// 需求：自定义redView,监听红色view中按钮点击</span></div><div class="line"><span class="comment">// 之前都是需要通过代理监听，给红色View添加一个代理属性，点击按钮的时候，通知代理做事情</span></div><div class="line"><span class="comment">// rac_signalForSelector:把调用某个对象的方法的信息转换成信号，就要调用这个方法，就会发送信号。</span></div><div class="line"><span class="comment">// 这里表示只要redV调用btnClick:,就会发出信号，订阅就好了。</span></div><div class="line">[[redV rac_signalForSelector:<span class="keyword">@selector</span>(btnClick:)] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"点击红色按钮"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 2.KVO</span></div><div class="line"><span class="comment">// 把监听redV的center属性改变转换成信号，只要值改变就会发送信号</span></div><div class="line"><span class="comment">// observer:可以传入nil</span></div><div class="line">[[redV rac_valuesAndChangesForKeyPath:<span class="string">@"center"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line"></div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.监听事件</span></div><div class="line"><span class="comment">// 把按钮点击事件转换为信号，点击按钮，就会发送信号</span></div><div class="line">[[<span class="keyword">self</span>.btn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"按钮被点击了"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 4.代替通知</span></div><div class="line"><span class="comment">// 把监听到的通知转换信号</span></div><div class="line">[[[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="built_in">UIKeyboardWillShowNotification</span> object:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"键盘弹出"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 5.监听文本框的文字改变</span></div><div class="line">[_textField.rac_textSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"文字改变了%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 6.处理多个请求，都返回结果的时候，统一做处理.</span></div><div class="line">RACSignal *request1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"></div><div class="line"><span class="comment">// 发送请求1</span></div><div class="line">[subscriber sendNext:<span class="string">@"发送请求1"</span>];</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">RACSignal *request2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"><span class="comment">// 发送请求2</span></div><div class="line">[subscriber sendNext:<span class="string">@"发送请求2"</span>];</div><div class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 使用注意：几个信号，参数一的方法就几个参数，每个参数对应信号发出的数据。</span></div><div class="line">[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(updateUIWithR1:r2:) withSignalsFromArray:@[request1,request2]];</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 更新UI</span></div><div class="line">- (<span class="keyword">void</span>)updateUIWithR1:(<span class="keyword">id</span>)data r2:(<span class="keyword">id</span>)data1</div><div class="line">&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"更新UI%@  %@"</span>,data,data1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="8-ReactiveCocoa常见宏。"><a href="#8-ReactiveCocoa常见宏。" class="headerlink" title="8.ReactiveCocoa常见宏。"></a>8.ReactiveCocoa常见宏。</h3><p>8.1 <code>RAC(TARGET, [KEYPATH, [NIL_VALUE]])</code>:用于给某个对象的某个属性绑定。</p>
<p><code>基本用法</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只要文本框文字改变，就会修改label的文字</span></div><div class="line">RAC(<span class="keyword">self</span>.labelView,text) = _textField.rac_textSignal;</div></pre></td></tr></table></figure>
<p>8.2 <code>RACObserve(self, name)</code>:监听某个对象的某个属性,返回的是信号。</p>
<p><code>基本用法</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[RACObserve(<span class="keyword">self</span>.view, center) subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>8.3  <code>@weakify(Obj)和@strongify(Obj)</code>,一般两个都是配套使用,解决循环引用问题.</p>
<p>8.4 <code>RACTuplePack</code>：把数据包装成RACTuple（元组类）</p>
<p><code>基本用法</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把参数中的数据包装成元组</span></div><div class="line">RACTuple *tuple = RACTuplePack(@<span class="number">10</span>,@<span class="number">20</span>);</div></pre></td></tr></table></figure></p>
<p>8.5 <code>RACTupleUnpack</code>：把RACTuple（元组类）解包成对应的数据。</p>
<p><code>基本用法</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 把参数中的数据包装成元组</span></div><div class="line">RACTuple *tuple = RACTuplePack(<span class="string">@"xmg"</span>,@<span class="number">20</span>);</div><div class="line"></div><div class="line"><span class="comment">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span></div><div class="line"><span class="comment">// name = @"xmg" age = @20</span></div><div class="line">RACTupleUnpack(<span class="built_in">NSString</span> *name,<span class="built_in">NSNumber</span> *age) = tuple;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios内存MemoryManagement]]></title>
      <url>http://yoursite.com/2016/12/31/MemoryManagement/</url>
      <content type="html"><![CDATA[<p>###苹果是如何“收垃圾”的?</p>
<p>不管搭载的iOS还是Android，设备的运行内存都是有限的。在你开了一大堆应用程序，快要把内存占满的时候，为了维持正常运行，iOS和Android都会Kill掉一些后台进程，这个行为也称为“垃圾回收机制”。但需要注意的是，iOS和Android“收垃圾”的方式不甚相同。iOS会依次把最老的应用直接关闭掉，所以时候在切换到很老的后台App时会发现，它们都会从标题界面重新启动。相比之下，Android的胆子则要小得多，它不会直接关掉App，而是筛选出其中的一些无用对象，率先把它们Kill掉，从而释放部分内存。但只要你不手动关，这些后台程序都不会自动消失。因此，苹果设备就算只有1GB运行内存，你正在用的App也绝对不会卡，而Android后台程序不会自动被关闭，需要提供更多的内存(2GB、3GB甚至更多)才能保证系统流畅运行。内存需求小不是苹果牛掰的意思，虽然1GB用着也很舒坦，但说“苹果优化好”似乎不太准确，因为iOS和Android的垃圾处理方法并不是一个高端、一个土鳖，而是各有利弊。</p>
<p>iOS会无差别地关掉老应用，这意味着如果你正在玩一个大型游戏，那么可能微信、微博、QQ这些软件就全都被关掉了。你若想切换回这些软件，就要经历一个相当闹心的启动过程。朋友圈发完了、微博也玩够了，这回天下该太平了吧?等等，但愿你的游戏还能回到刚才暂停的位置……另外一个比较闹心的场景就是你在Safari浏览器里开了N个标签，1GB运存承受不住那么多的内容，于是非常自觉地把最老的几个网页给挂起了。如果那几个页面刚好是你填了一半的付款界面或者是写了一半的文章，那么……那Android又是怎么坑爹的呢? 想必用家们都深有感触：切换界面会卡、接电话会卡、解锁会卡，连看个照片都得等半天。但是，Android的大内存也有得天独厚的好处，那就是不管你想开什么后台应用，它们都会把你上次干半截的事情完整地带到前台，不会连个招呼都不打就关了它们。尤其目前市面上具备3GB运行内存的Android手机，它们既能够保证大量应用同时运行，也能保持整个系统处在一个比较流畅的状态，整体的体验也还是可以的(开好几十个应用不关的除外)。所以，iOS的“霸道型小内存”和Android的“人文关怀型大内存”其实都是各有利弊的，并不是简单的一个比另一个好的关系。</p>
<p>###运存那么小，你以为苹果真的很满足?</p>
<p>苹果在iPhone 6和6 Plus上保持1GB运行内存，不单单是因为用起来不卡，其实也基于以下一些问题进行了考量：内存耗电：更多的内存会消耗更多的电能，iPhone6内存仅1GB，而且采用了LPDDR3低电压版模块，节能效果相当可观;成本问题：升级到2GB或者更高，单台手机的制造成本并不会提高多少，但是对于一个出货量动辄好几千万的产品来说，那算下来可得损失不少钱呢!用户需求问题：虽然存在着一些略显坑爹的关后台问题，但是果粉们早就习惯了，就算加大内存容量，整体体验的提升也不见得多明显。对于追求各方面性能均衡的苹果来说，单个指标不突出不算是缺憾。其实说到底，在理想状态下，苹果也非常想让内存更大一些，毕竟用户运行多任务的时候，谁都希望能多开几个应用。苹果也意识到随着用户需求的提高，内存问题势必变得愈加尖锐，他们已然开始行动了：iPad Air 2升级到了2GB内存，这样一来，相信下一代的iPhone离大运存也不会太远了。</p>
<p>###那么1G的内存是如何分配给各个App的嘞?</p>
<p>苹果给每个应用程序设置20M的内存警告量，30M的闪退量，游戏会略微放款10~20M，需要向系统申请。这一条说明除了系统本身占用内存以外，任何程序几乎都不可能占用超过50M内存。实际上，不是单个程序存在50M的内存使用上限，而是单线程使用上限是50M，同一个程序可以加载多个线程，同一个程序可以使用多个线程。</p>
<ul>
<li><p>关于后台:<br>苹果设计本身就没有后台，当你把程序最小化的时候程序就暂停了一切活动。如果应用想继续运行一部分功能的话，必须向系统申请运行时长，或者调用系统功能，比如音乐播放。由此跟安卓需要大内存来支持后台运行的区别就显而易见了，因为安卓是在Linux上跑的Java虚拟机，他的内存管理机制是申请之后就一直在那放着，等一个Runtime周期结束之后会自动收回不必要的内存。</p>
</li>
<li><p>关于内存：<br>个人认为，IOS只要不彻底重新编写的话，苹果几乎不可能开放海量内存，因为它既不支持真后台，又给APP设置了50M的内存使用上限。打个比方：你开法拉利（超大内存），我开QQ（1G内存），咱俩一起在路上跑（使用内存），但是限速50（内存使用限制），只要超过限速就扣车（超过限制即强行释放内存），你开再好的车也不可能比我快多少，因为苹果不让，除非苹果放开限速让你随便跑（开放内存配额上限）。但是不把路挖掉重新铺的话（系统限制，除非大刀阔斧的做改造，否则开放意义也不大，主要是苹果公司认为没意义……），就不能开放限速，所以现阶段只能限速50.这就是IPHONE只用1G内存的原因。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios常见的储存方案]]></title>
      <url>http://yoursite.com/2016/12/30/Ios%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h2 id="Ios四种常见的储存方案"><a href="#Ios四种常见的储存方案" class="headerlink" title="Ios四种常见的储存方案"></a>Ios四种常见的储存方案</h2><h3 id="概念问题"><a href="#概念问题" class="headerlink" title="概念问题"></a>概念问题</h3><p>首先要明确区分两个概念，数据结构和储存方式。所谓数据结构就是数据存在的形式。除了基本的NSDictionary、NSArray和NSSet这些对象，还有更复杂的如：关系模型、对象图和属性列表多种结构。而存储方式则简单的分为两种：内存与闪存。内存存储是临时的，运行时有效的，但效率高，而闪存则是一种持久化存储，但产生I/O消耗，效率相对低。把内存数据转移到闪存中进行持久化的操作称成为归档。二者结合起来才是完整的数据存储方案，我们最常谈起的那些：SQLite、CoreData、NSUserDefaults等都是数据存储方案。当然在这些框架提供的方案之外，我们自己也可以按照个性化需求订制方案。这些存储方案侧重不同，支持的形式和方式也各不相同，在不同的使用场景下表现也是各有优劣。但万变不离其宗。</p>
<h3 id="以下将对四种存储方式进行详细的介绍"><a href="#以下将对四种存储方式进行详细的介绍" class="headerlink" title="以下将对四种存储方式进行详细的介绍"></a>以下将对四种存储方式进行详细的介绍</h3><ul>
<li>NSUserDefaults，用于存储配置信息</li>
<li>SQLite，用于存储查询需求较多的数据</li>
<li>CoreData，用于规划应用中的对象</li>
<li>使用基本对象类型定制的个性化缓存方案</li>
</ul>
<h4 id="用NSUserDefaults存储配置信息"><a href="#用NSUserDefaults存储配置信息" class="headerlink" title="用NSUserDefaults存储配置信息"></a>用NSUserDefaults存储配置信息</h4><p>NSUserDefaults被设计用来存储设备和应用的配置信息，它通过一个工厂方法返回默认的、也是最常用到的实例对象。这个对象中储存了系统中用户的配置信息，开发者可以通过这个实例对象对这些已有的信息进行修改，也可以按照自己的需求创建新的配置项。<br>NSUserDefaults把配置信息以字典的形式组织起来，支持字典的项包括：字符串或者是数组，除此之外还支持数字等基本格式。一句话概括就是：基础类型的小数据的字典。操作方法几乎与NSDictionary的操作方法无异，另外还可以通过指定返回类型的方法获取到指定类型的返回值。<br>NSUserDefaults的所有数据都放在内存里，因此操作速度很快，并还提供一个归档方法：+ (void)synchronize。开发者自定义的配置项（如图2中的最后一项 key:alkdjfkladsjfmm）会以plist格式的文件归档在相应应用目录的/Library/Preferences/[App_Bundle_Identifier].plist文件。再次初始化获得实例对象后，框架会把用户自定义的这个配置和系统配置合并得到完整数据。</p>
<h4 id="用SQLite存储查询需求较多的数据"><a href="#用SQLite存储查询需求较多的数据" class="headerlink" title="用SQLite存储查询需求较多的数据"></a>用SQLite存储查询需求较多的数据</h4><p>iOS的SDK里预置了SQLite的库，开发者可以自建SQLite数据库。SQLite每次写入数据都会产生IO消耗，把数据归档到相应的文件。SQLite擅长处理的数据类型其实与NSUserDefaults差不多，也是基础类型的小数据，只是从组织形式上不同。开发者可以以关系型数据库的方式组织数据，使用SQL DML来管理数据。 一般来说应用中的格式化的文本类数据可以存放在数据库中，尤其是类似聊天记录、Timeline等这些具有条件查询和排序需求的数据。每一个数据库的句柄都会在内存中都会被分配一段缓存，用于提高查询效率。另一个方面，由于查询缓存，当产生大量句柄或数据量较大时，会出现缓存过大，造成内存浪费。SQLite的使用起来要比NSUserDefaults复杂的多，因此建议开发者使用SQLite要搭配一个操作控件使用，可以简化操作。笔者开发的SQLight是一款对SQLite操作的封装，把相对复杂的SQLite命令封装成对象和方法，可以供大家参考。大家可以在Github上获取这个工程的代码进一步了解。</p>
<h4 id="用CoreData规划应用中对象"><a href="#用CoreData规划应用中对象" class="headerlink" title="用CoreData规划应用中对象"></a>用CoreData规划应用中对象</h4><p>官方给出的定义是，一个支持持久化的，对象图和生命周期的自动化管理方案。严格意义上说CoreData是一个管理方案，他的持久化可以通过SQLite、XML或二进制文件储存。如官方定义所说，CoreData的作用远远不止储存数据这么简单，它可以把整个应用中的对象建模并进行自动化的管理。<br>MyDocument是一个对象实例，有两个Collection：Employee和Department，存放各自的对象列表。MyDocument、Employee和Department三个对象以及他们之间的关系都通过CoreData建模，并可以通过save方法进行持久化。<br>从归档文件还原模型时CoreData并不是一次性把整个模型中的所有数据都载入内存，而是根据运行时状态，把被调用到的对象实例载入内存。框架会自动控制这个过程，从而达到控制内存消耗，避免浪费。<br>无论从设计原理还是使用方法上看，CoreData都比较复杂。因此，如果仅仅是考虑缓存数据这个需求，CoreData绝对不是一个优选方案。CoreData的使用场景在于：整个应用使用CoreData规划，把应用内的数据通过CoreData建模，完全基于CoreData架构应用。<br>之前提到的NSUserDefaults和SQLite适合存储基础类型的小数据，而CoreData则不适合存储单一的数据</p>
<h2 id="Ios四种储存方案的使用"><a href="#Ios四种储存方案的使用" class="headerlink" title="Ios四种储存方案的使用"></a>Ios四种储存方案的使用</h2><h3 id="保存文件的额目录"><a href="#保存文件的额目录" class="headerlink" title="保存文件的额目录"></a>保存文件的额目录</h3><ul>
<li>持久化<br>所谓的持久化，就是将数据保存到硬盘中，使得在应用程序或机器重启后可以继续访问之前保存的数据。</li>
<li><p>沙盒<br>在介绍各种存储方法之前，有必要说明以下沙盒机制。iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p>
</li>
<li><p>结构<br>沙盒的目录结构如下</p>
</li>
</ul>
<p>“应用程序包”<br>Documents<br>Library<br>Caches<br>Preferences<br>tmp</p>
<ul>
<li>目录特性<br>虽然沙盒中有这么多文件夹，但是没有文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。</li>
</ul>
<p>** 应用程序包<br>// 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] bundlePath];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure></p>
<p>** Documents<br>//最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure></p>
<p>** Library/Caches<br>// iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure>
<p>** Library/Preferences<br>// iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</p>
<p>** tmp<br>iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSTemporaryDirectory</span>();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, path);</div></pre></td></tr></table></figure>
<h3 id="plist文件"><a href="#plist文件" class="headerlink" title="plist文件"></a>plist文件</h3><p>plist文件是将某些特定的类，通过XML文件的方式保存在目录中。<br>可以被序列化的类型只有如下几种：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span>;</div><div class="line"><span class="built_in">NSMutableArray</span>;</div><div class="line"><span class="built_in">NSDictionary</span>;</div><div class="line"><span class="built_in">NSMutableDictionary</span>;</div><div class="line"><span class="built_in">NSData</span>;</div><div class="line"><span class="built_in">NSMutableData</span>;</div><div class="line"><span class="built_in">NSString</span>;</div><div class="line"><span class="built_in">NSMutableString</span>;</div><div class="line"><span class="built_in">NSNumber</span>;</div><div class="line"><span class="built_in">NSDate</span>;</div></pre></td></tr></table></figure>
<h4 id="1-获得文件路径"><a href="#1-获得文件路径" class="headerlink" title="1.获得文件路径"></a>1.获得文件路径</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *path = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject;</div><div class="line"><span class="built_in">NSString</span> *fileName = [path stringByAppendingPathComponent:<span class="string">@"123.plist"</span>];</div></pre></td></tr></table></figure>
<h4 id="2-存储"><a href="#2-存储" class="headerlink" title="2.存储"></a>2.存储</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"123"</span>, <span class="string">@"456"</span>, <span class="string">@"789"</span>];</div><div class="line">[array writeToFile:fileName atomically:<span class="literal">YES</span>];</div></pre></td></tr></table></figure>
<h4 id="3-读取"><a href="#3-读取" class="headerlink" title="3.读取"></a>3.读取</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *result = [<span class="built_in">NSArray</span> arrayWithContentsOfFile:fileName];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, result);</div></pre></td></tr></table></figure>
<h4 id="4-注意"><a href="#4-注意" class="headerlink" title="4.注意"></a>4.注意</h4><p>只有以上列出的类型才能使用plist文件存储。存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。读取时使用arrayWithContentsOfFile:方法。</p>
<h3 id="Preference"><a href="#Preference" class="headerlink" title="Preference"></a>Preference</h3><h4 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="1.使用方法"></a>1.使用方法</h4><p>//1.获得NSUserDefaults文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div></pre></td></tr></table></figure></p>
<p>//2.向文件中写入内容<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[userDefaults setObject:<span class="string">@"AAA"</span> forKey:<span class="string">@"a"</span>];</div><div class="line">[userDefaults setBool:<span class="literal">YES</span> forKey:<span class="string">@"sex"</span>];</div><div class="line">[userDefaults setInteger:<span class="number">21</span> forKey:<span class="string">@"age"</span>];</div></pre></td></tr></table></figure></p>
<p>//2.1立即同步<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[userDefaults synchronize];</div></pre></td></tr></table></figure></p>
<p>//3.读取文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *name = [userDefaults objectForKey:<span class="string">@"a"</span>];</div><div class="line"><span class="built_in">BOOL</span> sex = [userDefaults boolForKey:<span class="string">@"sex"</span>];</div><div class="line"><span class="built_in">NSInteger</span> age = [userDefaults integerForKey:<span class="string">@"age"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@, %d, %ld"</span>, name, sex, age);</div></pre></td></tr></table></figure></p>
<h4 id="2-注意"><a href="#2-注意" class="headerlink" title="2.注意"></a>2.注意</h4><p>偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。</p>
<h3 id="NSKeyedArchiver"><a href="#NSKeyedArchiver" class="headerlink" title="NSKeyedArchiver"></a>NSKeyedArchiver</h3><p>归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。</p>
<h4 id="1-遵循NSCoding协议"><a href="#1-遵循NSCoding协议" class="headerlink" title="1.遵循NSCoding协议"></a>1.遵循NSCoding协议</h4><p>NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。</p>
<ul>
<li><p>遵循协议和设置属性</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//1.遵循NSCoding协议 </span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//2.设置属性</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIImage</span> *avatar;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
</li>
<li><p>实现协议方法</p>
</li>
</ul>
<p>//解档<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="keyword">self</span>.avatar = [aDecoder decodeObjectForKey:<span class="string">@"avatar"</span>];</div><div class="line">        <span class="keyword">self</span>.name = [aDecoder decodeObjectForKey:<span class="string">@"name"</span>];</div><div class="line">        <span class="keyword">self</span>.age = [aDecoder decodeIntegerForKey:<span class="string">@"age"</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//归档<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123;</div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.avatar forKey:<span class="string">@"avatar"</span>];</div><div class="line">    [aCoder encodeObject:<span class="keyword">self</span>.name forKey:<span class="string">@"name"</span>];</div><div class="line">    [aCoder encodeInteger:<span class="keyword">self</span>.age forKey:<span class="string">@"age"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>特别注意<br>如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder] 方法;</li>
</ul>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><ul>
<li>需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *file = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.data"</span>];</div><div class="line">Person *person = [[Person alloc] init];</div><div class="line">person.avatar = <span class="keyword">self</span>.avatarView.image;</div><div class="line">person.name = <span class="keyword">self</span>.nameField.text;</div><div class="line">person.age = [<span class="keyword">self</span>.ageField.text integerValue];</div><div class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:person toFile:file];</div></pre></td></tr></table></figure>
<ul>
<li>需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法unarchiveObjectWithFile: 即可<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *file = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.data"</span>];</div><div class="line"></div><div class="line">Person *person = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:file];</div><div class="line"><span class="keyword">if</span> (person) &#123;</div><div class="line">    <span class="keyword">self</span>.avatarView.image = person.avatar;</div><div class="line">    <span class="keyword">self</span>.nameField.text = person.name;</div><div class="line">    <span class="keyword">self</span>.ageField.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, person.age];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h4><p>1.必须遵循并实现NSCoding协议<br>2.保存文件的扩展名可以任意指定<br>3.继承时必须先调用父类的归档解档方法</p>
<h2 id="SQLite3"><a href="#SQLite3" class="headerlink" title="SQLite3"></a>SQLite3</h2><p>之前的所有存储方法，都是覆盖存储。如果想要增加一条数据就必须把整个文件读出来，然后修改数据后再把整个内容覆盖写入文件。所以它们都不适合存储大量的内容。</p>
<h4 id="1-字段类型"><a href="#1-字段类型" class="headerlink" title="1.字段类型"></a>1.字段类型</h4><p>表面上SQLite将数据分为以下几种类型：</p>
<ul>
<li>integer : 整数</li>
<li>real : 实数（浮点数）</li>
<li>text : 文本字符串</li>
<li>blob : 二进制数据，比如文件，图片之类的<br>实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。SQLite之所以什么类型就是为了良好的编程规范和方便开发人员交流，所以平时在使用时最好设置正确的字段类型！主键必须设置成integer</li>
</ul>
<h4 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h4><p>准备工作就是导入依赖库啦，在iOS中要使用SQLite3，需要添加库文件：libsqlite3.dylib并导入主头文件，这是一个C语言的库，所以直接使用SQLite3还是比较麻烦的。</p>
<h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h4><ul>
<li>创建数据库并打开<br>操作数据库之前必须先指定数据库文件和要操作的表，所以使用SQLite3，首先要打开数据库文件，然后指定或创建一张表。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*  打开数据库并创建一个表</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)openDatabase &#123;</div><div class="line"></div><div class="line"><span class="comment">//1.设置文件名</span></div><div class="line"><span class="built_in">NSString</span> *filename = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.db"</span>];</div><div class="line"></div><div class="line"><span class="comment">//2.打开数据库文件，如果没有会自动创建一个文件</span></div><div class="line"><span class="built_in">NSInteger</span> result = sqlite3_open(filename.UTF8String, &amp;_sqlite3);</div><div class="line"><span class="keyword">if</span> (result == SQLITE_OK) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"打开数据库成功！"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//3.创建一个数据库表</span></div><div class="line">    <span class="keyword">char</span> *errmsg = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    sqlite3_exec(_sqlite3, <span class="string">"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg);</div><div class="line">    <span class="keyword">if</span> (errmsg) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"错误：%s"</span>, errmsg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"创表成功！"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"打开数据库失败！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行指令<br>使用 sqlite3_exec() 方法可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*  往表中插入1000条数据</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)insertData &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *nameStr;</div><div class="line">    <span class="built_in">NSInteger</span> age;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">        nameStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Bourne-%d"</span>, arc4random_uniform(<span class="number">10000</span>)];</div><div class="line">        age = arc4random_uniform(<span class="number">80</span>) + <span class="number">20</span>;</div><div class="line"></div><div class="line">        <span class="built_in">NSString</span> *sql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"INSERT INTO t_person (name, age) VALUES('%@', '%ld')"</span>, nameStr, age];</div><div class="line"></div><div class="line">        <span class="keyword">char</span> *errmsg = <span class="literal">NULL</span>;</div><div class="line">        sqlite3_exec(_sqlite3, sql.UTF8String, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errmsg);</div><div class="line">        <span class="keyword">if</span> (errmsg) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"错误：%s"</span>, errmsg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"插入完毕！"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>查询指令<br>前面说过一般不使用 sqlite3_exec() 方法查询数据。因为查询数据必须要获得查询结果，所以查询相对比较麻烦。示例代码如下：<br>sqlite3_prepare_v2() : 检查sql的合法性<br>sqlite3_step() : 逐行获取查询结果，不断重复，直到最后一条记录<br>sqlite3_coloum_xxx() : 获取对应类型的内容，iCol对应的就是SQL语句中字段的顺序，从0开始。根据实际查询字段的属性，使用sqlite3_column_xxx取得对应的内容即可。<br>sqlite3_finalize() : 释放stmt</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*  从表中读取数据到数组中</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)readData &#123;</div><div class="line">    <span class="built_in">NSMutableArray</span> *mArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1000</span>];</div><div class="line">    <span class="keyword">char</span> *sql = <span class="string">"select name, age from t_person;"</span>;</div><div class="line">    sqlite3_stmt *stmt;</div><div class="line"></div><div class="line">    <span class="built_in">NSInteger</span> result = sqlite3_prepare_v2(_sqlite3, sql, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (result == SQLITE_OK) &#123;</div><div class="line">        <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">char</span> *name = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">0</span>);</div><div class="line">            <span class="built_in">NSInteger</span> age = sqlite3_column_int(stmt, <span class="number">1</span>);</div><div class="line"></div><div class="line">            <span class="comment">//创建对象</span></div><div class="line">            Person *person = [Person personWithName:[<span class="built_in">NSString</span> stringWithUTF8String:name] Age:age];</div><div class="line">            [mArray addObject:person];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">self</span>.dataList = mArray;</div><div class="line">    &#125;</div><div class="line">    sqlite3_finalize(stmt);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>总得来说，SQLite3的使用还是比较麻烦的，因为都是些c语言的函数，理解起来有些困难。不过在一般开发过程中，使用的都是第三方开源库 FMDB，封装了这些基本的c语言方法，使得我们在使用时更加容易理解，提高开发效率。</p>
<h2 id="FMDB"><a href="#FMDB" class="headerlink" title="FMDB"></a>FMDB</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>FMDB是iOS平台的SQLite数据库框架，它是以OC的方式封装了SQLite的C语言API，它相对于cocoa自带的C语言框架有如下的优点:</p>
<ul>
<li>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</li>
<li>对比苹果自带的Core Data框架，更加轻量级和灵活</li>
<li>提供了多线程安全的数据库操作方法，有效地防止数据混乱</li>
</ul>
<h3 id="2-核心类"><a href="#2-核心类" class="headerlink" title="2.核心类"></a>2.核心类</h3><p>FMDB有三个主要的类:</p>
<ul>
<li><p>FMDatabase<br>一个FMDatabase对象就代表一个单独的SQLite数据库，用来执行SQL语句</p>
</li>
<li><p>FMResultSet<br>使用FMDatabase执行查询后的结果集</p>
</li>
<li><p>FMDatabaseQueue<br>用于在多线程中执行多个查询或更新，它是线程安全的</p>
</li>
</ul>
<h3 id="3-打开数据库"><a href="#3-打开数据库" class="headerlink" title="3.打开数据库"></a>3.打开数据库</h3><p>和c语言框架一样，FMDB通过指定SQLite数据库文件路径来创建FMDatabase对象，但FMDB更加容易理解，使用起来更容易，使用之前一样需要导入sqlite3.dylib。打开数据库方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSString</span> *path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).firstObject stringByAppendingPathComponent:<span class="string">@"person.db"</span>];</div><div class="line"></div><div class="line">FMDatabase *database = [FMDatabase databaseWithPath:path];    </div><div class="line"><span class="keyword">if</span> (![database open]) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"数据库打开失败！"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="值得注意的是，Path的值可以传入以下三种情况："><a href="#值得注意的是，Path的值可以传入以下三种情况：" class="headerlink" title="值得注意的是，Path的值可以传入以下三种情况："></a>值得注意的是，Path的值可以传入以下三种情况：</h4><ul>
<li>具体文件路径，如果不存在会自动创建</li>
<li>空字符串@””，会在临时目录创建一个空的数据库，当FMDatabase连接关闭时，数据库文件也被删除</li>
<li>nil，会创建一个内存中临时数据库，当FMDatabase连接关闭时，数据库会被销毁</li>
</ul>
<h3 id="4-更新"><a href="#4-更新" class="headerlink" title="4.更新"></a>4.更新</h3><p>在FMDB中，除查询以外的所有操作，都称为“更新”, 如：create、drop、insert、update、delete等操作，使用executeUpdate:方法执行更新：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//常用方法有以下3种：   </span></div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdate:(<span class="built_in">NSString</span>*)sql, ...</div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdateWithFormat:(<span class="built_in">NSString</span>*)format, ...</div><div class="line">- (<span class="built_in">BOOL</span>)executeUpdate:(<span class="built_in">NSString</span>*)sql withArgumentsInArray:(<span class="built_in">NSArray</span> *)arguments</div><div class="line"></div><div class="line"><span class="comment">//示例</span></div><div class="line">[database executeUpdate:<span class="string">@"CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)"</span>];   </div><div class="line"><span class="comment">//或者  </span></div><div class="line">[database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES(?, ?)"</span>, <span class="string">@"Bourne"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">42</span>]];</div></pre></td></tr></table></figure>
<h3 id="5-查询"><a href="#5-查询" class="headerlink" title="5.查询"></a>5.查询</h3><p>查询方法也有3种，使用起来相当简单：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (FMResultSet *)executeQuery:(<span class="built_in">NSString</span>*)sql, ...</div><div class="line">- (FMResultSet *)executeQueryWithFormat:(<span class="built_in">NSString</span>*)format, ...</div><div class="line">- (FMResultSet *)executeQuery:(<span class="built_in">NSString</span> *)sql withArgumentsInArray:(<span class="built_in">NSArray</span> *)arguments</div></pre></td></tr></table></figure>
<p>查询示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//1.执行查询</span></div><div class="line">FMResultSet *result = [database executeQuery:<span class="string">@"SELECT * FROM t_person"</span>];</div><div class="line"><span class="comment">//2.遍历结果集</span></div><div class="line"><span class="keyword">while</span> ([result next]) &#123;</div><div class="line"><span class="built_in">NSString</span> *name = [result stringForColumn:<span class="string">@"name"</span>];</div><div class="line">    <span class="keyword">int</span> age = [result intForColumn:<span class="string">@"age"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-线程安全"><a href="#6-线程安全" class="headerlink" title="6.线程安全"></a>6.线程安全</h3><p>在多个线程中同时使用一个FMDatabase实例是不明智的。不要让多个线程分享同一个FMDatabase实例，它无法在多个线程中同时使用。 如果在多个线程中同时使用一个FMDatabase实例，会造成数据混乱等问题。所以，请使用 FMDatabaseQueue，它是线程安全的。以下是使用方法：</p>
<ul>
<li>创建队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</div></pre></td></tr></table></figure>
<ul>
<li>使用队列<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[queue inDatabase:^(FMDatabase *database) &#123;    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_1"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]];    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_2"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>]];    </div><div class="line">    [database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_3"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>]];      </div><div class="line">    FMResultSet *result = [database executeQuery:<span class="string">@"select * from t_person"</span>];    </div><div class="line">    <span class="keyword">while</span>([result next]) &#123;   </div><div class="line"></div><div class="line">    &#125;    </div><div class="line">&#125;];</div><div class="line">而且可以轻松地把简单任务包装到事务里：</div><div class="line"></div><div class="line">[queue inTransaction:^(FMDatabase *database, <span class="built_in">BOOL</span> *rollback) &#123;    </div><div class="line">[database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_1"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]];    </div><div class="line">[database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_2"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>]];    </div><div class="line">[database executeUpdate:<span class="string">@"INSERT INTO t_person(name, age) VALUES (?, ?)"</span>, <span class="string">@"Bourne_3"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>]];      </div><div class="line">FMResultSet *result = [database executeQuery:<span class="string">@"select * from t_person"</span>];    </div><div class="line"><span class="keyword">while</span>([result next]) &#123;   </div><div class="line">&#125;   </div><div class="line"></div><div class="line"><span class="comment">// 回滚</span></div><div class="line">*rollback = <span class="literal">YES</span>;  </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>FMDatabaseQueue 后台会建立系列化的G-C-D队列，并执行你传给G-C-D队列的块。这意味着 你从多线程同时调用调用方法，GDC也会按它接收的块的顺序来执行。</p>
<h2 id="一-CoreData的基本使用"><a href="#一-CoreData的基本使用" class="headerlink" title="一,CoreData的基本使用"></a>一,CoreData的基本使用</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>创建数据库<br>新建文件，选择CoreData -&gt; DataModel<br>添加实体（表），Add Entity<br>给表中添加属性，点击Attributes下方的‘+’号</li>
<li>创建模型文件<br>新建文件，选择CoreData -&gt; NSManaged Object subclass<br>根据提示，选择实体<br>*通过代码，关联数据库和实体</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">/*</span></div><div class="line">    * 关联的时候，如果本地没有数据库文件，Ｃoreadata自己会创建</div><div class="line">    */</div><div class="line"></div><div class="line">    <span class="comment">// 1. 上下文</span></div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 上下文关连数据库</span></div><div class="line"></div><div class="line">    <span class="comment">// 2.1 model模型文件</span></div><div class="line">    <span class="built_in">NSManagedObjectModel</span> *model = [<span class="built_in">NSManagedObjectModel</span> mergedModelFromBundles:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 持久化存储调度器</span></div><div class="line">    <span class="comment">// 持久化，把数据保存到一个文件，而不是内存</span></div><div class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *store = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 设置CoreData数据库的名字和路径</span></div><div class="line">    <span class="built_in">NSString</span> *doc = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="built_in">NSString</span> *sqlitePath = [doc stringByAppendingPathComponent:<span class="string">@"company.sqlite"</span>];</div><div class="line"></div><div class="line">    [store addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:sqlitePath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    context.persistentStoreCoordinator = store;</div><div class="line">    _context = context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CoreData的基本操作（CURD）"><a href="#CoreData的基本操作（CURD）" class="headerlink" title="CoreData的基本操作（CURD）"></a>CoreData的基本操作（CURD）</h3><ul>
<li>添加元素 - Create</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)addEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个员工对象 </span></div><div class="line">    <span class="comment">//Employee *emp = [[Employee alloc] init]; 不能用此方法创建</span></div><div class="line">    Employee *emp = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_context];</div><div class="line">    emp.name = <span class="string">@"wangwu"</span>;</div><div class="line">    emp.height = @<span class="number">1.80</span>;</div><div class="line">    emp.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">// 直接保存数据库</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>读取数据 - Read</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)readEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 1.FetchRequest 获取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.设置过滤条件</span></div><div class="line">    <span class="comment">// 查找zhangsan</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>,</div><div class="line">    <span class="string">@"zhangsan"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 3.设置排序</span></div><div class="line">    <span class="comment">// 身高的升序排序</span></div><div class="line">    <span class="built_in">NSSortDescriptor</span> *heigtSort = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"height"</span> ascending:<span class="literal">NO</span>];</div><div class="line">    request.sortDescriptors = @[heigtSort];</div><div class="line"></div><div class="line">    <span class="comment">// 4.执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//NSLog(@"%@",emps);</span></div><div class="line"></div><div class="line">    <span class="comment">//遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 身高 %@ 生日 %@"</span>,emp.name,emp.height,emp.birthday);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>修改数据 - Update</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)updateEmployee&#123;</div><div class="line">    <span class="comment">// 改变zhangsan的身高为2m</span></div><div class="line"></div><div class="line">    <span class="comment">// 1.查找到zhangsan</span></div><div class="line">    <span class="comment">// 1.1FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 1.2设置过滤条件</span></div><div class="line">    <span class="comment">// 查找zhangsan</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>, <span class="string">@"zhangsan"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 1.3执行请求</span></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.更新身高</span></div><div class="line">    <span class="keyword">for</span> (Employee *e <span class="keyword">in</span> emps) &#123;</div><div class="line">        e.height = @<span class="number">2.0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 3.保存</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>删除数据 - Delete<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)deleteEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 删除 lisi</span></div><div class="line"></div><div class="line">    <span class="comment">// 1.查找lisi</span></div><div class="line">    <span class="comment">// 1.1FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 1.2设置过滤条件</span></div><div class="line">    <span class="comment">// 查找zhangsan</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>,</div><div class="line">    <span class="string">@"lisi"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 1.3执行请求</span></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.删除</span></div><div class="line">    <span class="keyword">for</span> (Employee *e <span class="keyword">in</span> emps) &#123;</div><div class="line">    [_context deleteObject:e];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 3.保存</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、CoreData的表关联"><a href="#二、CoreData的表关联" class="headerlink" title="二、CoreData的表关联"></a>二、CoreData的表关联</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>创建数据库<br>新建文件，选择CoreData -&gt; DataModel<br>添加实体（表），Add Entity ， 注意：这里根据关联添加多个实体<br>给表中添加属性，点击Attributes下方的‘+’号</li>
<li>创建模型文件<br>新建文件，选择CoreData -&gt; NSManaged Object subclass<br>根据提示，选择实体，注意：这里先选择被关联的实体，最后添加最上层的实体</li>
<li>通过代码，关联数据库和实体</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">/*</span></div><div class="line">    * 关联的时候，如果本地没有数据库文件，Ｃoreadata自己会创建</div><div class="line">    */</div><div class="line"></div><div class="line">    <span class="comment">// 1. 上下文</span></div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 上下文关连数据库</span></div><div class="line"></div><div class="line">    <span class="comment">// 2.1 model模型文件</span></div><div class="line">    <span class="built_in">NSManagedObjectModel</span> *model = [<span class="built_in">NSManagedObjectModel</span> mergedModelFromBundles:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 持久化存储调度器</span></div><div class="line">    <span class="comment">// 持久化，把数据保存到一个文件，而不是内存</span></div><div class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *store = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 设置CoreData数据库的名字和路径</span></div><div class="line">    <span class="built_in">NSString</span> *doc = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="built_in">NSString</span> *sqlitePath = [doc stringByAppendingPathComponent:<span class="string">@"company.sqlite"</span>];</div><div class="line"></div><div class="line">    [store addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:sqlitePath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    context.persistentStoreCoordinator = store;</div><div class="line">    _context = context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>添加元素 - Create</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)addEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 1. 创建两个部门 ios android</span></div><div class="line">    <span class="comment">//1.1 iOS部门</span></div><div class="line">    Department *iosDepart = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Department"</span> inManagedObjectContext:_context];</div><div class="line">    iosDepart.name = <span class="string">@"ios"</span>;</div><div class="line">    iosDepart.departNo = <span class="string">@"0001"</span>;</div><div class="line">    iosDepart.createDate = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">//1.2 Android部门</span></div><div class="line">    Department *andrDepart = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Department"</span> inManagedObjectContext:_context];</div><div class="line">    andrDepart.name = <span class="string">@"android"</span>;</div><div class="line">    andrDepart.departNo = <span class="string">@"0002"</span>;</div><div class="line">    andrDepart.createDate = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">//2. 创建两个员工对象 zhangsan属于ios部门 lisi属于android部门</span></div><div class="line">    <span class="comment">//2.1 zhangsan</span></div><div class="line">    Employee *zhangsan = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_context];</div><div class="line">    zhangsan.name = <span class="string">@"zhangsan"</span>;</div><div class="line">    zhangsan.height = @(<span class="number">1.90</span>);</div><div class="line">    zhangsan.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line">    zhangsan.depart = iosDepart;</div><div class="line"></div><div class="line">    <span class="comment">//2.2 lisi</span></div><div class="line">    Employee *lisi = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_context];</div><div class="line">    lisi.name = <span class="string">@"lisi"</span>;</div><div class="line">    lisi.height = @<span class="number">2.0</span>;</div><div class="line">    lisi.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line">    lisi.depart = andrDepart;</div><div class="line"></div><div class="line">    <span class="comment">//3. 保存数据库</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    [_context save:&amp;error];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>读取信息 - Read<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)readEmployee&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 读取ios部门的员工</span></div><div class="line"></div><div class="line">    <span class="comment">// 1.FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.设置过滤条件</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"depart.name = %@"</span>,<span class="string">@"android"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 4.执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 部门 %@"</span>,emp.name,emp.depart.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、CoreData的模糊查询"><a href="#三、CoreData的模糊查询" class="headerlink" title="三、CoreData的模糊查询"></a>三、CoreData的模糊查询</h2><ul>
<li><p>模糊查询</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)readEmployee&#123;</div><div class="line">    <span class="comment">// 1.FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2.设置排序</span></div><div class="line">    <span class="comment">// 按照身高的升序排序</span></div><div class="line">    <span class="built_in">NSSortDescriptor</span> *heigtSort = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"height"</span> ascending:<span class="literal">NO</span>];</div><div class="line">    request.sortDescriptors = @[heigtSort];</div><div class="line"></div><div class="line">    <span class="comment">// 3.模糊查询</span></div><div class="line">    <span class="comment">// 3.1 名字以"wang"开头</span></div><div class="line">    <span class="comment">//    NSPredicate *pre = [NSPredicate predicateWithFormat:@"name BEGINSWITH %@",@"wangwu1"];</span></div><div class="line">    <span class="comment">//    request.predicate = pre;</span></div><div class="line"></div><div class="line">    <span class="comment">// 名字以"1"结尾</span></div><div class="line">    <span class="comment">//    NSPredicate *pre = [NSPredicate predicateWithFormat:@"name ENDSWITH %@",@"1"];</span></div><div class="line">    <span class="comment">//    request.predicate = pre;</span></div><div class="line"></div><div class="line">    <span class="comment">// 名字包含"wu1"</span></div><div class="line">    <span class="comment">//    NSPredicate *pre = [NSPredicate predicateWithFormat:@"name CONTAINS %@",@"wu1"];</span></div><div class="line">    <span class="comment">//    request.predicate = pre;</span></div><div class="line"></div><div class="line">    <span class="comment">// like 匹配</span></div><div class="line">    <span class="built_in">NSPredicate</span> *pre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name like %@"</span>,<span class="string">@"*wu12"</span>];</div><div class="line">    request.predicate = pre;</div><div class="line"></div><div class="line">    <span class="comment">// 4.执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 身高 %@ 生日 %@"</span>,emp.name,emp.height,emp.birthday);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>分页查询</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">void</span>)pageSeacher&#123;</div><div class="line">    <span class="comment">// 1. FectchRequest 抓取请求对象</span></div><div class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 设置排序</span></div><div class="line">    <span class="comment">// 身高的升序排序</span></div><div class="line">    <span class="built_in">NSSortDescriptor</span> *heigtSort = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"height"</span> ascending:<span class="literal">NO</span>];</div><div class="line">    request.sortDescriptors = @[heigtSort];</div><div class="line"></div><div class="line">    <span class="comment">// 3. 分页查询</span></div><div class="line">    <span class="comment">// 总有共有15数据</span></div><div class="line">    <span class="comment">// 每次获取6条数据</span></div><div class="line">    <span class="comment">// 第一页 0,6</span></div><div class="line">    <span class="comment">// 第二页 6,6</span></div><div class="line">    <span class="comment">// 第三页 12,6 3条数据</span></div><div class="line"></div><div class="line">    <span class="comment">// 3.1 分页的起始索引</span></div><div class="line">    request.fetchOffset = <span class="number">12</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 3.2 分页的条数</span></div><div class="line">    request.fetchLimit = <span class="number">6</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 4. 执行请求</span></div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSArray</span> *emps = [_context executeFetchRequest:request error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 5. 遍历员工</span></div><div class="line">    <span class="keyword">for</span> (Employee *emp <span class="keyword">in</span> emps) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"名字 %@ 身高 %@ 生日 %@"</span>,emp.name,emp.height,emp.birthday);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四、多个数据库的使用"><a href="#四、多个数据库的使用" class="headerlink" title="四、多个数据库的使用"></a>四、多个数据库的使用</h2><p>创建多个数据库，即创建多个DataModel,一个数据库对应一个上下文,需要根据bundle名创建上下文。添加或读取信息，需要根据不同的上下文，访问不同的实体。</p>
<ul>
<li>关联数据库和实体</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="comment">// 一个数据库对应一个上下文</span></div><div class="line">    _companyContext = [<span class="keyword">self</span> setupContextWithModelName:<span class="string">@"Company"</span>];</div><div class="line">    _weiboContext = [<span class="keyword">self</span> setupContextWithModelName:<span class="string">@"Weibo"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*  根据模型文件，返回一个上下文</div><div class="line">*/</div><div class="line">-(<span class="built_in">NSManagedObjectContext</span> *)setupContextWithModelName:(<span class="built_in">NSString</span> *)modelName&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 1. 上下文</span></div><div class="line">    <span class="built_in">NSManagedObjectContext</span> *context = [[<span class="built_in">NSManagedObjectContext</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 上下文关连数据库</span></div><div class="line">    <span class="comment">// 2.1 model模型文件</span></div><div class="line"></div><div class="line">    <span class="comment">// 注意：如果使用下面的方法，如果 bundles为nil 会把bundles里面的所有模型文件的表放在一个数据库</span></div><div class="line">    <span class="comment">//NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:nil];</span></div><div class="line"></div><div class="line">    <span class="comment">// 改为以下的方法获取：</span></div><div class="line">    <span class="built_in">NSURL</span> *companyURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:modelName withExtension:<span class="string">@"momd"</span>];</div><div class="line">    <span class="built_in">NSManagedObjectModel</span> *model = [[<span class="built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:companyURL];</div><div class="line"></div><div class="line">    <span class="comment">// 2.2 持久化存储调度器</span></div><div class="line">    <span class="comment">// 持久化，把数据保存到一个文件，而不是内存</span></div><div class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *store = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</div><div class="line"></div><div class="line">    <span class="comment">// 2.3 告诉Coredata数据库的名字和路径</span></div><div class="line">    <span class="built_in">NSString</span> *doc = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</div><div class="line">    <span class="built_in">NSString</span> *sqliteName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.sqlite"</span>,modelName];</div><div class="line">    <span class="built_in">NSString</span> *sqlitePath = [doc stringByAppendingPathComponent:sqliteName];</div><div class="line"></div><div class="line">    [store addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:sqlitePath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    context.persistentStoreCoordinator = store;</div><div class="line"></div><div class="line">    <span class="comment">// 3. 返回上下文</span></div><div class="line">    <span class="keyword">return</span> context;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>添加元素<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="keyword">IBAction</span>)addEmployee&#123;</div><div class="line">    <span class="comment">// 1. 添加员工</span></div><div class="line">    Employee *emp = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:_companyContext];</div><div class="line">    emp.name = <span class="string">@"zhagsan"</span>;</div><div class="line">    emp.height = @<span class="number">2.3</span>;</div><div class="line">    emp.birthday = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    <span class="comment">// 直接保存数据库</span></div><div class="line">    [_companyContext save:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 发微博</span></div><div class="line">    Status *status =[<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Status"</span> inManagedObjectContext:_weiboContext];</div><div class="line"></div><div class="line">    status.text = <span class="string">@"发了一条微博！"</span>;</div><div class="line">    status.createDate = [<span class="built_in">NSDate</span> date];</div><div class="line"></div><div class="line">    [_weiboContext save:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios常用的三种种枚举]]></title>
      <url>http://yoursite.com/2016/12/30/Enum/</url>
      <content type="html"><![CDATA[<p>Ios中常用的枚举的几种写法</p>
<p>###1.普通的枚举<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>&#123;</div><div class="line">    XMtop,</div><div class="line">    XMbottom,</div><div class="line">&#125;XM;</div></pre></td></tr></table></figure></p>
<p>###2.自定义类型枚举<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, KSType) &#123;</div><div class="line">    KSTypeTop,</div><div class="line">    KSTypeBottom,</div><div class="line">    KSTypeRight,</div><div class="line">    KSTypeLeft,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>###3.移位枚举:一个参数可以传递多个值<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSInteger</span>, SType) &#123;</div><div class="line">    STypeTop        = <span class="number">1</span>&lt;&lt;<span class="number">0</span>,</div><div class="line">    STypeBottom     = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,</div><div class="line">    STypeRight      = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,</div><div class="line">    STypeLeft       = <span class="number">1</span>&lt;&lt;<span class="number">3</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios图片缓存的优化]]></title>
      <url>http://yoursite.com/2015/12/30/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="图片缓存的优化"><a href="#图片缓存的优化" class="headerlink" title="图片缓存的优化"></a>图片缓存的优化</h2><h4 id="一：从图片入手"><a href="#一：从图片入手" class="headerlink" title="一：从图片入手"></a>一：从图片入手</h4><p>内存占用大原因是图片太大，所以想到对图片进行压缩。找了好多压缩工具，最后发现一款比较好用的，名字是ppDuck（pp鸭），这里是<a href="http://ppduck.com/" target="_blank" rel="external">下载地址</a>,图片压缩后，内存确实是暂用较少了，但还没有根本结局。</p>
<h4 id="二：从加载图片的方式考虑"><a href="#二：从加载图片的方式考虑" class="headerlink" title="二：从加载图片的方式考虑"></a>二：从加载图片的方式考虑</h4><p>正确选择图片加载方式能够对内存优化起到很大的作用，常见的图片加载方式有下面三种：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法1  </span></div><div class="line"><span class="built_in">UIImage</span> *imag1 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>];  </div><div class="line"><span class="comment">//方法2  </span></div><div class="line"><span class="built_in">UIImage</span> *image2 = [<span class="built_in">UIImage</span> imageWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image@2x"</span> ofType:.png]];  </div><div class="line"><span class="comment">//方法3  </span></div><div class="line"><span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image@2x"</span> ofType:png]];  </div><div class="line"><span class="built_in">UIImage</span> *image3 = [<span class="built_in">UIImage</span> imageWithData:imageData]；</div></pre></td></tr></table></figure>
<ul>
<li>第一种方法:imageNamed:<br>为什么有两种方法完成同样的事情呢？imageNamed的优点在于可以缓存已经加载的图片。苹果的文档中有如下说法：这种方法会首先在系统缓存中根据指定的名字寻找图片，如果找到了就返回。如果没有在缓存中找到图片，该方法会从指定的文件中加载图片数据，并将其缓存起来，然后再把结果返回。对于同一个图像，系统只会把它Cache到内存一次，这对于图像的重复利用是非常有优势的。例如：你需要在 一个TableView里重复加载同样一个图标，那么用imageNamed加载图像，系统会把那个图标Cache到内存，在Table里每次利用那个图 像的时候，只会把图片指针指向同一块内存。这种情况使用imageNamed加载图像就会变得非常有效。</li>
</ul>
<ul>
<li><p>第二种方法和第三种方法本质是一样的:imageWithContentsOfFile:和imageWithData:<br>而imageWithContentsOfFile方法只是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到程序。当你不需要重用该图像，或者你需要将</p>
</li>
<li><p>如何选择</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法1 cach  </span></div><div class="line"><span class="built_in">UIImage</span> *imag1 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>];  </div><div class="line"><span class="comment">//方法2 no cach  </span></div><div class="line"><span class="built_in">UIImage</span> *image2 = [<span class="built_in">UIImage</span> imageWithContentsOfFile:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"image.png"</span> ofType:<span class="literal">nil</span>]];</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果加载一张很大的图片，并且只使用一次，那么就不需要缓存这个图片。这种情况imageWithContentsOfFile比较合适,系统不会浪费内存来缓存图片。然而，如果在程序中经常需要重用的图片，那么最好是选择imageNamed方法。这种方法可以节省出每次都从磁盘加载图片的时间。</p>
<h2 id="Ios圆角图片的优化"><a href="#Ios圆角图片的优化" class="headerlink" title="Ios圆角图片的优化"></a>Ios圆角图片的优化</h2><ul>
<li><p>原理<br>上面拖慢帧率的原因其实都是Off-Screen Rendering（离屏渲染）的原因。离屏渲染是个好东西，但是频繁发生离屏渲染是非常耗时的。</p>
</li>
<li><p>Off-Screen Rendering<br>离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。由上面的一个结论视图和圆角的大小对帧率并没有什么卵影响，数量才是伤害的核心输出啊。可以知道离屏渲染耗时是发生在离屏这个动作上面，而不是渲染。为什么离屏这么耗时？原因主要有创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。</p>
</li>
<li><p>上下文切换<br>上下文切换，不管是在GPU渲染过程中，还是一直所熟悉的进程切换，上下文切换在哪里都是一个相当耗时的操作。首先我要保存当前屏幕渲染环境，然后切换到一个新的绘制环境，申请绘制资源，初始化环境，然后开始一个绘制，绘制完毕后销毁这个绘制环境，如需要切换到On-Screen<br>Rendering或者再开始一个新的离屏渲染重复之前的操作。 下图描述了一次mask的渲染操作。</p>
</li>
</ul>
<p>一次mask发生了两次离屏渲染和一次主屏渲染。即使忽略昂贵的上下文切换，一次mask需要渲染三次才能在屏幕上显示，这已经是普通视图显示3陪耗时，若再加上下文环境切换，一次mask就是普通渲染的30倍以上耗时操作。问我这个30倍以上这个数据怎么的出来的？当我在cell的UIImageView的实例增加到150个，并去掉圆角的时候，帧数才跌至28帧每秒。虽然不是甚准确，但至少反映mask这个耗时是无mask操作的耗时的数十倍的。</p>
<h3 id="第一种-设置CALayer的cornerRadius"><a href="#第一种-设置CALayer的cornerRadius" class="headerlink" title="第一种:设置CALayer的cornerRadius"></a>第一种:设置CALayer的cornerRadius</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"img"</span>];</div><div class="line">imageView.image.layer.cornerRadius = <span class="number">5</span>;</div><div class="line">imageView.image.layer.masksToBounds = <span class="literal">YES</span>;</div></pre></td></tr></table></figure>
<p>这样设置会触发离屏渲染，比较消耗性能。比如当一个页面上有十几头像这样设置了圆角会明显感觉到卡顿。这种就是最常用的，也是最耗性能的。</p>
<p>注意：ios9.0之后对UIImageView的圆角设置做了优化，UIImageView这样设置圆角不会触发离屏渲染，ios9.0之前还是会触发离屏渲染。而UIButton还是都会触发离屏渲染。</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">imageView.clipsToBounds = <span class="literal">YES</span>;</div><div class="line">imageView.layer setCornerRadius:<span class="number">50</span>];</div><div class="line">imageView.layer.shouldRasterize = <span class="literal">YES</span>;</div></pre></td></tr></table></figure>
<p>shouldRasterize=YES设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图， 使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新 创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</p>
<h3 id="第三种-通过Core-Graphics重新绘制带圆角的视图"><a href="#第三种-通过Core-Graphics重新绘制带圆角的视图" class="headerlink" title="第三种 :通过Core Graphics重新绘制带圆角的视图"></a>第三种 :通过Core Graphics重新绘制带圆角的视图</h3><p>这种方式性能最好，但是UIButton上不知道怎么绘制，可以用UIimageView添加个 点击手势当做UIButton使用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">CircleImage</span>)</span></div><div class="line"></div><div class="line">- (<span class="built_in">UIImage</span> *)drawCircleImage &#123;</div><div class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size, <span class="literal">NO</span>, [<span class="built_in">UIScreen</span> mainScreen].scale); </div><div class="line">    [[<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span>.bounds cornerRadius:<span class="number">50</span>] addClip]; </div><div class="line">    [<span class="keyword">self</span> drawInRect:<span class="keyword">self</span>.bounds]; </div><div class="line">    <span class="built_in">UIImage</span> *output = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    <span class="keyword">return</span> output; </div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">//在需要圆角时调用如下</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="built_in">UIImage</span> *img = [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"image.png"</span>] drawCircleImage];</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        imageView.image = img;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="四、通过混合图层"><a href="#四、通过混合图层" class="headerlink" title="四、通过混合图层"></a>四、通过混合图层</h3><p>此方法就是在要添加圆角的视图上再叠加一个部分透明的视图，只对圆角部分进行遮挡。图层混合的透明度处理方式与mask正好相反。此方法虽然是最优解，没有离屏渲染，没有额外的CPU计算，但是应用范围有限。</p>
<ul>
<li>总结</li>
</ul>
<p>在可以使用混合图层遮挡的场景下，优先使用第四种方法。即使是非iOS9以上系统，第一种方法在综合性能上依然强于后两者，iOS9以上由于没有了离屏渲染更是首选。方法三由于需要大量计算和增加部分内存，需要实际情况各自取舍。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios的UITableView优化]]></title>
      <url>http://yoursite.com/2015/12/30/UITabView%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="IOS之UITableView优化-可重用机制"><a href="#IOS之UITableView优化-可重用机制" class="headerlink" title="IOS之UITableView优化-可重用机制"></a>IOS之UITableView优化-可重用机制</h2><p>目的：为了做到显示和数据分离， 通过重用单元格来达到节省内存的目的</p>
<h4 id="1-使用可重用机制创建cell（系统）"><a href="#1-使用可重用机制创建cell（系统）" class="headerlink" title="1.使用可重用机制创建cell（系统）"></a>1.使用可重用机制创建cell（系统）</h4><p>（1）定义可重用标识<br>（2）从可重用队列中取出cell<br>（3）若队列中无可用cell，利用alloc，init新建cell</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *reuseIndentifier = <span class="string">@"MyCell"</span>;  </div><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:reuseIndentifier];  </div><div class="line"><span class="keyword">if</span> (!cell) &#123;  </div><div class="line">    cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:reuseIndentifier];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h4><p>在UITableView的头文件中有visibleCells，存放当前显示的的cells<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>)<span class="built_in">NSArray</span>&lt;__kindofUITableViewCell *&gt; *visibleCells;</div></pre></td></tr></table></figure></p>
<p>当需要更新显示数据时，dequeueReusableCellWithIdentifier会先在可重用cell队列 reusable-cell queue中返回一个cell对象，若不存在，则返回nil；</p>
<h4 id="3-举例"><a href="#3-举例" class="headerlink" title="3.举例"></a>3.举例</h4><p>若一共有50条数据，屏幕最多显示10个cell。</p>
<p>(1）由于初始时 reusable-cell queue为空，所以用 [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] 创建10次cell，并给cell指定同样的重用标识，并且10个cell全部都加入到 visiableCells数组。<br>(2）向下拖动tableView，当cell1完全移出屏 幕，并且cell11(它也是alloc出来的，原因同上)完全显示出来的时候。 cell11加入到visiableCells，cell1移出visiableCells，cell1加入到 reusable-cell queue。<br>(3). 接着向下拖动tableView，因为 reusable-cell queue中已经有可用cell对象，所以，当需要显示新的cell，cellForRowAtIndexPath再次被调用的时候，tableView dequeueReusableCellWithIdentifier:CellIdentifier，返回cell1。 cell1加入到visiableCells，cell1移出 reusable-cell queue；cell2移出 visiableCells，cell2加入到 reusable-cell queue。</p>
<h4 id="4-存在的问题"><a href="#4-存在的问题" class="headerlink" title="4.存在的问题"></a>4.存在的问题</h4><p>重取出来的cell是有可能已经捆绑过数据或者加过子视图的，造成视图叠加混乱的现象<br>解决：<br>(1）删除已有数据或子视图<br>(2）放弃了重用机制，每次根据indexPath获取对应的cell返回。<br>将方法:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:reuseIndentifier];</div></pre></td></tr></table></figure></p>
<p>替换为:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableViewCell</span> *cell = [tableView cellForRowAtIndexPath:indexPath];</div></pre></td></tr></table></figure></p>
<h4 id="5-自定义cell的可重用机制使用"><a href="#5-自定义cell的可重用机制使用" class="headerlink" title="5.自定义cell的可重用机制使用"></a>5.自定义cell的可重用机制使用</h4><p>(1）在nib中加载MyCell这个类<br>(2）注册自定义的cell 的可重用标识<br>[objc] view plain copy 在CODE上查看代码片派生到我的代码片<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UINib</span> *nib = [<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"MyCell"</span> bundle:<span class="literal">nil</span>];   </div><div class="line">[tableView registerNib:nib forCellReuseIdentifier:reuseIdentity];</div></pre></td></tr></table></figure></p>
<p>用标识，并加入缓存池<br>(3)同上系统cell的使用</p>
<h2 id="IOS的tabViewCell的卡顿的解决方案"><a href="#IOS的tabViewCell的卡顿的解决方案" class="headerlink" title="IOS的tabViewCell的卡顿的解决方案"></a>IOS的tabViewCell的卡顿的解决方案</h2><ul>
<li>当你下滑时候是否发现有那么一点点的卡顿现成，特别是网络不好。可以利用UIScrollViewDelegate代理很好的解决这问题<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate</div><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可以识别tableview禁止或者减速滑动结束的时候进行异步加载图片</p>
<ul>
<li>tabViewCell上面的图片透明度和圆角问题也会造成卡顿的情况</li>
<li>​使用不透明视图：没有其他渲染效果，可以提高页面渲染速度;</li>
<li>不要重复创建不必要的cell：​当新cell需要被显示时，就会调用tableView:cellForRowAtIndexPath:方法获取或创建一个cell；而不可视时，它又会被释放。由此可见，同一时间只需要存在一屏幕的cell即可，不需要为每一行创建一个cell;</li>
<li>​使用自定义的cell：默认的UITableViewCell包含了textLabel、detailTextLabel和imageView等view，然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。但是使用自定义的view，而非预定义的会明显快一些;</li>
<li>不要阻塞主线程：显然，主线程就只加载视图，把网络请求等耗时函数放到子线程;</li>
<li>​自动载入更新数据：例如每次载入50条信息，那就可以在滚动到倒数第10条以内时，加载更多信息;</li>
<li>不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的opaque属性设为YES（默认值）;</li>
<li>其中的特例包括背景色，它的alpha值应该为1（例如不要使用clearColor）；图像的alpha值也应该为1，或者在画图时设为不透明;</li>
<li>值得一提的是，cell被重用时，它内部绘制的内容并不会被自动清除，因此你可能需要调用setNeedsDisplayInRect:或setNeedsDisplay方法。<br>此外，在添加table cell的时候，如果不需要动画效果，最好不要使用insertRowsAtIndexPaths:withRowAnimation:方法，而是直接调用reloadData方法。因为前者会对所有indexPaths调用tableView:cellForRowAtIndexPath:方法，即便该 cell并不需要显示（不知道是不是bug），这就可能创建大量多余的cell。勘误：只是在模拟器上测试如此，真机调试时没有这种bug。</li>
<li>UITableViewCell包含了textLabel、detailTextLabel和imageView等view，而你还可以自定义一些视图放在它的contentView里。然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。<br>如果你的table cell包含图片，且数目较多，使用默认的UITableViewCell会非常影响性能。奇怪的是，使用自定义的view，而非预定义的view，明显会快些。当然，最佳的解决办法还是继承UITableViewCell，并在其drawRect:中自行绘制：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect </div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span>(image) &#123; </div><div class="line">        [image drawAtPoint:imagePoint]; </div><div class="line">        <span class="keyword">self</span>.image = <span class="literal">nil</span>; </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [placeHolder drawAtPoint:imagePoint]; </div><div class="line">    &#125; </div><div class="line">    [text drawInRect:textRect withFont:fontlineBreakMode:<span class="built_in">UILineBreakModeTailTruncation</span>]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>不过这样一来，你会发现选中一行后，这个cell就变蓝了，其中的内容就被挡住了。最简单的方法就是将cell的selectionStyle属性设为UITableViewCellSelectionStyleNone，这样就不会被高亮了。<br>此外还可以创建CALayer，将内容绘制到layer上，然后对cell的contentView.layer调用addSublayer:方法。这个例子中，layer并不会显著影响性能，但如果layer透明，或者有圆角、变形等效果，就会影响到绘制速度了。解决办法可参见后面的预渲染图像。</p>
</li>
<li><p>不要做多余的绘制工作<br>在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。<br>例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。</p>
</li>
<li><p>预渲染图像。<br>你会发现即使做到了上述几点，当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕，详细做法可见。<br><a href="http://www.keakon.net/2011/07/26/利用预渲染加速iOS设备的图像显示" target="_blank" rel="external">《利用预渲染加速iOS设备的图像显示》</a></p>
</li>
<li><p>不要阻塞主线程<br>做到前几点后，你的table view滚动时应该足够流畅了，不过你仍可能让用户感到不爽。常见的现象就是在更新数据时，整个界面卡住不动，完全不响应用户请求。<br>出现这种现象的原因就是主线程执行了耗时很长的函数或方法，在其执行完毕前，无法绘制屏幕和响应用户请求。其中最常见的就是网络请求了，它通常都需要花费数秒的时间，而你不应该让用户等待那么久。<br>解决办法就是使用多线程，让子线程去执行这些函数或方法。这里面还有一个学问，当下载线程数超过2时，会显著影响主线程的性能。因此在使用ASIHTTPRequest时，可以用一个NSOperationQueue来维护下载请求，并将其maxConcurrentOperationCount设为2。而NSURLRequest则可以配合GCD来实现，或者使用NSURLConnection的setDelegateQueue:方法。<br>当然，在不需要响应用户请求时，也可以增加下载线程数，以加快下载速度：</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span>*)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate &#123; <span class="keyword">if</span> (!decelerate) &#123;queue.maxConcurrentOperationCount = <span class="number">5</span>; &#125; &#125; -(<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView &#123;queue.maxConcurrentOperationCount = <span class="number">5</span>; &#125; -(<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;queue.maxConcurrentOperationCount = <span class="number">2</span>; &#125;</div></pre></td></tr></table></figure>
<p>此外，自动载入更新数据对用户来说也很友好，这减少了用户等待下载的时间。例如每次载入50条信息，那就可以在滚动到倒数第10条以内时，加载更多信息：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span>*)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cellforRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath </div><div class="line">&#123; </div><div class="line">    <span class="comment">// update方法获取到结果后，设置updating为NO</span></div><div class="line">    <span class="keyword">if</span> (count - indexPath.row &lt; <span class="number">10</span>&amp;&amp; !updating) &#123; </div><div class="line">        updating = <span class="literal">YES</span>; [<span class="keyword">self</span> update]; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一点要注意的就是当图片下载完成后，如果cell是可见的，还需要更新图像：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *indexPaths = [<span class="keyword">self</span>.tableViewindexPathsForVisibleRows];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSIndexPath</span> *visibleIndexPath <span class="keyword">in</span> indexPaths) &#123;</div><div class="line">    <span class="comment">// 也可不遍历，直接与头尾相比较，看是否在中间即可。</span></div><div class="line">    <span class="keyword">if</span> (indexPath == visibleIndexPath) &#123;</div><div class="line">        MyTableViewCell *cell = (MyTableViewCell*)[<span class="keyword">self</span>.tableView cellForRowAtIndexPath:indexPath]; </div><div class="line">        cell.image = image;</div><div class="line">        [cellsetNeedsDisplayInRect:imageRect]; </div><div class="line">        <span class="keyword">break</span>; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后还是前面所说过的insertRowsAtIndexPaths:withRowAnimation:方法，插入新行需要在主线程执行，而一次插入很多行的话（例如50行），会长时间阻塞主线程。而换成reloadData方法的话，瞬间就处理完了。</p>
<ul>
<li>如果只是更新某组的话，使用reloadSection进行局部更新</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios高精度NSDecimalNumber]]></title>
      <url>http://yoursite.com/2015/12/20/Ios%E7%B2%BE%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>NSDecimalNumber Ios精度计算</p>
<p>.m文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Iimport &lt;Foundation/Foundation.h&gt;</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HighPrecision</span> : <span class="title">NSObject</span> </span></div><div class="line">+ (<span class="built_in">NSString</span> *)plusWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 加法</span></div><div class="line">+ (<span class="built_in">NSString</span> *)minuWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 减法</span></div><div class="line">+ (<span class="built_in">NSString</span> *)multiplyWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 乘法</span></div><div class="line">+ (<span class="built_in">NSString</span> *)devideWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B; <span class="comment">// 除法</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>.h文件<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HighPrecision</span></span></div><div class="line">+ (<span class="built_in">NSString</span> *)plusWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *b = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:B];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *h = [a decimalNumberByAdding: b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line">    <span class="built_in">NSString</span> *result = [h stringValue];</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSString</span> *)minuWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line"> 	<span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line"> 	<span class="built_in">NSDecimalNumber</span> *c = [a decimalNumberBySubtracting:b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line"> 	<span class="built_in">NSString</span> *result = [c stringValue];</div><div class="line"> 	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSString</span> *)multiplyWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line">   <span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line">   <span class="built_in">NSDecimalNumber</span> *b = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:B];</div><div class="line">   <span class="built_in">NSDecimalNumber</span> *j = [a decimalNumberByMultiplyingBy:b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line">   <span class="built_in">NSString</span> *result = [j stringValue];</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSString</span> *)devideWithA:(<span class="built_in">NSString</span> *)A andB:(<span class="built_in">NSString</span> *)B</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *a = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:A];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *b = [<span class="built_in">NSDecimalNumber</span> decimalNumberWithString:B];</div><div class="line">    <span class="built_in">NSDecimalNumber</span> *s = [a decimalNumberByDividingBy:b withBehavior:[<span class="keyword">self</span> format]];</div><div class="line">    <span class="built_in">NSString</span> *result = [s stringValue];</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">+ (<span class="built_in">NSDecimalNumberHandler</span> *)format</div><div class="line">&#123;</div><div class="line">   <span class="comment">// NSRoundPlain 貌似取整</span></div><div class="line">   <span class="comment">// NSRoundDown 只舍不入</span></div><div class="line">   <span class="comment">// NSRoundUp 只入不舍</span></div><div class="line">   <span class="comment">// NSRoundBankers 貌似四舍五入</span></div><div class="line">    </div><div class="line">   <span class="built_in">NSDecimalNumberHandler</span> *roundUp = [<span class="built_in">NSDecimalNumberHandler</span></div><div class="line">        decimalNumberHandlerWithRoundingMode:<span class="built_in">NSRoundBankers</span></div><div class="line">                                       scale:<span class="number">2</span></div><div class="line">                                       raiseOnExactness:<span class="literal">NO</span></div><div class="line">                                       raiseOnOverflow:<span class="literal">NO</span></div><div class="line">                                       raiseOnUnderflow:<span class="literal">NO</span></div><div class="line">                                       raiseOnDivideByZero:<span class="literal">YES</span>];</div><div class="line">    <span class="keyword">return</span> roundUp;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IosQuestions]]></title>
      <url>http://yoursite.com/2015/12/20/IosQuestions/</url>
      <content type="html"><![CDATA[<h3 id="面试题积累"><a href="#面试题积累" class="headerlink" title="面试题积累"></a>面试题积累</h3><p>(<a href="http://www.cocoachina.com/ios/20160323/15770.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20160323/15770.html</a>)<br>(<a href="http://blog.csdn.net/chenyufeng1991/article/details/53472284" target="_blank" rel="external">http://blog.csdn.net/chenyufeng1991/article/details/53472284</a>)<br>(<a href="http://blog.csdn.net/q469587851/article/details/50591904?locationNum=13" target="_blank" rel="external">http://blog.csdn.net/q469587851/article/details/50591904?locationNum=13</a>)<br>(<a href="http://www.cocoachina.com/ios/20150825/13195.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20150825/13195.html</a>)<br>(<a href="http://www.cocoachina.com/programmer/20151019/13746.html" target="_blank" rel="external">http://www.cocoachina.com/programmer/20151019/13746.html</a>)<br>(<a href="http://www.mamicode.com/info-detail-988919.html" target="_blank" rel="external">http://www.mamicode.com/info-detail-988919.html</a>)<br>(<a href="https://sanwen8.cn/p/1d4ih4t.html" target="_blank" rel="external">https://sanwen8.cn/p/1d4ih4t.html</a>)<br>(<a href="https://github.com/ChenYilong/iOSInterviewQuestions/" target="_blank" rel="external">https://github.com/ChenYilong/iOSInterviewQuestions/</a>)<br>(<a href="http://www.jianshu.com/p/b61cd0bc2abe" target="_blank" rel="external">http://www.jianshu.com/p/b61cd0bc2abe</a>)<br>(<a href="https://chenhu1001.github.io/page/2/" target="_blank" rel="external">https://chenhu1001.github.io/page/2/</a>)</p>
<h2 id="搜狐快站"><a href="#搜狐快站" class="headerlink" title="搜狐快站"></a>搜狐快站</h2><h3 id="倒计时如何实现-（NSTimer，还有其他的实现方式吗"><a href="#倒计时如何实现-（NSTimer，还有其他的实现方式吗" class="headerlink" title="倒计时如何实现?（NSTimer，还有其他的实现方式吗)?"></a>倒计时如何实现?（NSTimer，还有其他的实现方式吗)?</h3><h4 id="创建方式1"><a href="#创建方式1" class="headerlink" title="创建方式1"></a>创建方式1</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInteral:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(action:) userInfo:ni] repeat:<span class="literal">NO</span>];</div></pre></td></tr></table></figure>
<ul>
<li><p>参数<br>TimerIntval:执行之前等待的时间.比如设置成1.0 就代表1秒后执行;<br>target:需要执行方法的对象;<br>selector:需要执行的方法;<br>repeats:是否需要循环;</p>
</li>
<li><p>释放</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[timer invalidate];</div></pre></td></tr></table></figure>
</li>
<li><p>注意<br>调用创建方法后,target对象的引用计数会+1,直到执行完毕,自动-1.如果循环执行的话必须手动关闭.否则可以不执行释放方法;</p>
</li>
<li><p>特性<br>1.存在延迟:不管是一次性还是周期性的timer的实际触发事件的时间,都会与所加入的RunLoop和RunLoopMode有关.如果RunLoop正在执行一个连续的运算,timer就会被延迟触发.重复性的timer遇到这种情况,如果延迟超过一个周期,则会和后面的触发进行合并，即在一个周期内只会触发一次。但是不管该timer的触发时间延迟的有多离谱，他后面的timer的触发时间总是倍数于第一次添加timer的间隙。<br>2.必须加入RunLoop::使用上面的创建方式,会自动把timer加入MainRunloop的NSDefaultRunLoopMode中.如果使用以下方式创建定时器,就必须手动加入Runloop:</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">5</span> target:<span class="keyword">self</span> seletor:<span class="keyword">@selector</span>(timerAction) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</div><div class="line">[[<span class="built_in">NSRunloop</span> mainRunloop] addTimer:timer forMode:<span class="built_in">NSDefaultRunloopMode</span>];</div></pre></td></tr></table></figure>
<h4 id="创建方式2-CADisplayLink"><a href="#创建方式2-CADisplayLink" class="headerlink" title="创建方式2(CADisplayLink)"></a>创建方式2(CADisplayLink)</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> sel:ector:<span class="keyword">@selector</span>(handleDisplaylink:)];</div><div class="line">[<span class="keyword">self</span>.displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> curentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div></pre></td></tr></table></figure>
<ul>
<li><p>释放</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.displayLink invailidate];</div><div class="line"><span class="keyword">self</span>.displayLink = <span class="literal">nil</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>注意<br>当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时,CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法。</p>
</li>
<li><p>特性<br>1.屏幕刷新时调用:CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。所以通常情况下，按照iOS设备屏幕的刷新率60次/秒。<br>2.延迟:OS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会。如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。</p>
</li>
<li><p>使用场景<br>从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。</p>
</li>
<li><p>重要的属性<br>1.NSInteger类型的值，用来设置间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。<br>2.readOnly的CFTimeInterval值，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：调用间隔时间 = duration × frameInterval。</p>
</li>
</ul>
<h4 id="创建方式3-GCD"><a href="#创建方式3-GCD" class="headerlink" title="创建方式3(GCD)"></a>创建方式3(GCD)</h4><ul>
<li>GCD定时器不受RunLoop约束，比NSTimer更加准时.</li>
</ul>
<h5 id="执行一次的操作"><a href="#执行一次的操作" class="headerlink" title="执行一次的操作"></a>执行一次的操作</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">2.0</span>;</div><div class="line">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</div><div class="line">    <span class="comment">//执行事件</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="重复执行的操作"><a href="#重复执行的操作" class="headerlink" title="重复执行的操作"></a>重复执行的操作</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//证明，实现GCD定时器</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="comment">/** 定时器(这里不用带*，因为dispatch_source_t就是个类，内部已经包含了*) */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// 获得队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div><div class="line"></div><div class="line"><span class="comment">// 创建一个定时器(dispatch_source_t本质还是个OC对象)</span></div><div class="line"><span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</div><div class="line"></div><div class="line"><span class="comment">// 设置定时器的各种属性（几时开始任务，每隔多长时间执行一次）</span></div><div class="line"><span class="comment">// GCD的时间参数，一般是纳秒（1秒 == 10的9次方纳秒）</span></div><div class="line"><span class="comment">// 何时开始执行第一个任务</span></div><div class="line"><span class="comment">// dispatch_time(DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC) 比当前时间晚3秒</span></div><div class="line">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">uint64_t interval = (uint64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">dispatch_source_set_timer(<span class="keyword">self</span>.timer, start, interval, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">// 设置回调</span></div><div class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"------------%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    count++;</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</div><div class="line">        <span class="comment">// 取消定时器</span></div><div class="line">        dispatch_cancel(<span class="keyword">self</span>.timer);</div><div class="line">        <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 启动定时器</span></div><div class="line">dispatch_resume(<span class="keyword">self</span>.timer);</div></pre></td></tr></table></figure>
<p><a href="https://my.oschina.net/u/2340880/blog/398598" target="_blank" rel="external">其他创建定时器需要需要注意的地方</a></p>
<h3 id="UIButton的继承关系？"><a href="#UIButton的继承关系？" class="headerlink" title="UIButton的继承关系？"></a>UIButton的继承关系？</h3><p>UIButton继承与UIControl继承与UIView继承与UIResponder继承与NSObject。</p>
<h4 id="Ios中可以进行输入的控件-UITextView-UITextField）？"><a href="#Ios中可以进行输入的控件-UITextView-UITextField）？" class="headerlink" title="Ios中可以进行输入的控件(UITextView,UITextField）？"></a>Ios中可以进行输入的控件(UITextView,UITextField）？</h4><ul>
<li>继承关系<br>UITextField继承自UIView，UITextView继承自UIScrollView。</li>
<li>文本行数<br>UITextView支持多行输入，可以滑屏垂直滚动，UITextField仅支持单行输入。</li>
<li>Placeholder<br>UITextField支持设置Placeholder属性，即在用户输入文本前显示提示性的内容，而UITextView则没有这个功能。</li>
</ul>
<h4 id="4-快排的实现原理"><a href="#4-快排的实现原理" class="headerlink" title="4.快排的实现原理?"></a>4.快排的实现原理?</h4><h4 id="5-短信验证码会有倒计时功能吗-第一次验证失败后还可以再进行验证吗？"><a href="#5-短信验证码会有倒计时功能吗-第一次验证失败后还可以再进行验证吗？" class="headerlink" title="5.短信验证码会有倒计时功能吗?第一次验证失败后还可以再进行验证吗？"></a>5.短信验证码会有倒计时功能吗?第一次验证失败后还可以再进行验证吗？</h4><h4 id="6-Android开发和iOS开发的区别"><a href="#6-Android开发和iOS开发的区别" class="headerlink" title="6.Android开发和iOS开发的区别?"></a>6.Android开发和iOS开发的区别?</h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ios网络库AFNetworking详解]]></title>
      <url>http://yoursite.com/2015/12/20/%E7%BD%91%E7%BB%9C%E5%BA%93%E7%9A%84%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="为什么要用AFNetworking"><a href="#为什么要用AFNetworking" class="headerlink" title="为什么要用AFNetworking"></a>为什么要用AFNetworking</h2><p>为什么要用AFNetworking  在ios开发中，一般情况下，简单的向某个web站点简单的页面提交请求并获取服务器的响应，用xcode自带的NSURLConnection是能胜任的。但是，在绝大部分下我们所需要访问的web页面则是属于那种受到权限保护的页面，并不是有一个简单的URL可以访问的。这就涉及到了Session和Cookie的处理了，在此时使用NSURLConnection也是能够达到要求的，只是其中处理起来的复杂度和难度就提升了。  为了更好的处理向Web站点的请求，包括处理Session，Cookie等细节问题，使用AFNetworking则是更好的选择，他可以用于发送HTTP请求，接收HTTP的响应，但是不会缓存服务器的响应，不能执行HTML页面中的JAvascript代码,同时，AFNetworking还内置支持JSON，plist文件和XML文件的解析，使用比较方便。 </p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>1、Session：中文有译作时域的，就是只某个客户端在访问服务器起到停止访问这一段的时间间隔被称为时域。<br>2、Cookie：由服务器发送给客服端，把Cookie的key：value值储存在本地文件夹下，当下次请求的时候能够直接发送Cookie获得权限验证</p>
<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>AFNetworking 3.0 实现完全基于NSURLSessionTask进行封装，NSURLSessionTask 是苹果在iOS7 推出的网络请求api。AF支持https，网络数据请求，文件上传，文件下载，监听手机网络状态。AFHttpSessionManager 继承 AFURLSessionManager 对网络请求进行管理，使用AFURLRequestSerialization 对网络请求进行封装，使用AFURLReponseSerialization 响应体进行处理，使用AFSecurityPolicy 对服务器证书进行校验。支持https协议，支持本地证书和服务器证书进行对比验证，AF要求ios7或以上系统。AF数据传递主要使用block 和 notifacation的方式。</p>
<h2 id="AFURLSessionManager-使用方法"><a href="#AFURLSessionManager-使用方法" class="headerlink" title="AFURLSessionManager 使用方法"></a>AFURLSessionManager 使用方法</h2><ul>
<li><p>请求服务器数据</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>
</li>
<li><p>上传数据</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"></div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>
</li>
<li><p>多线程下载数据</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:<span class="string">@"POST"</span> URLString:<span class="string">@"http://example.com/upload"</span> parameters:<span class="literal">nil</span> constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;</div><div class="line">    [formData appendPartWithFileURL:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.jpg"</span>] name:<span class="string">@"file"</span> fileName:<span class="string">@"filename.jpg"</span> mimeType:<span class="string">@"image/jpeg"</span> error:<span class="literal">nil</span>];</div><div class="line">&#125; error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</div><div class="line"></div><div class="line">    <span class="built_in">NSURLSessionUploadTask</span> *uploadTask;</div><div class="line">    uploadTask = [manager</div><div class="line">    uploadTaskWithStreamedRequest:request</div><div class="line"></div><div class="line">    progress:^(<span class="built_in">NSProgress</span> * _Nonnull uploadProgress) &#123;</div><div class="line">        <span class="comment">// This is not called back on the main queue.</span></div><div class="line">        <span class="comment">// You are responsible for dispatching to the main queue for UI updates</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//Update the progress view</span></div><div class="line">        [progressView setProgress:uploadProgress.fractionCompleted];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">    completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AFHttpSessionManager-使用方法"><a href="#AFHttpSessionManager-使用方法" class="headerlink" title="AFHttpSessionManager 使用方法"></a>AFHttpSessionManager 使用方法</h2><h3 id="1-post请求"><a href="#1-post请求" class="headerlink" title="1.post请求"></a>1.post请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure DEPRECATED_ATTRIBUTE;</div></pre></td></tr></table></figure>
<h3 id="2-get请求"><a href="#2-get请求" class="headerlink" title="2.get请求"></a>2.get请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</div><div class="line">parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure</div></pre></td></tr></table></figure>
<h3 id="3-上传"><a href="#3-上传" class="headerlink" title="3.上传"></a>3.上传</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</div><div class="line">parameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</div><div class="line">constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</div><div class="line">success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> _Nullable responseObject))success</div><div class="line">failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure DEPRECATED_ATTRIBUTE;</div></pre></td></tr></table></figure>
<h2 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *googleCertificateURL = [[<span class="built_in">NSBundle</span> bundleForClass:[<span class="keyword">self</span> <span class="keyword">class</span>]] URLForResource:<span class="string">@"google.com"</span> withExtension:<span class="string">@"cer"</span>];</div><div class="line"><span class="built_in">NSData</span> *googleCertificateData = [<span class="built_in">NSData</span> dataWithContentsOfURL:googleCertificateURL];</div><div class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://apple.com/"</span>]];</div><div class="line"></div><div class="line">[manager setResponseSerializer:[AFHTTPResponseSerializer serializer]];</div><div class="line">manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:[<span class="built_in">NSSet</span> setWithObject:googleCertificateData]];</div></pre></td></tr></table></figure>
<p>证书文件放在应用bundle 中 ，会把服务器证书和本地证书对比认证，加强网络通信的安全性，判断是否信任服务器证书过程</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</div><div class="line">    <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></div><div class="line">    <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></div><div class="line">    <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></div><div class="line">    <span class="comment">//  there is nothing to evaluate against.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//  From Apple Docs:</span></div><div class="line">    <span class="comment">//          "Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></div><div class="line">    <span class="comment">//           Instead, add your own (self-signed) CA certificate to the list of trusted anchors."</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"In order to validate a domain name for self signed certificates, you MUST use pinning."</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</div><div class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</div><div class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</div><div class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</div><div class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</div><div class="line">            &#125;</div><div class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</div><div class="line">                <span class="comment">//服务器证书和存储在应用中的证书进行对比验证</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</div><div class="line">        <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</div><div class="line">            <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</div><div class="line">                trustedPublicKeyCount += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div></pre></td></tr></table></figure>
<h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><p>AFURLSessionManager管理所有的请求，session 设置了NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate 实现证书合法性校验，数据传输进度检测，数据请求成功或失败的回调。<br>使用runtime 用af_supend 替换 suspend,用af_resume 替换了resume 当调用这两个方法的时候往上层发送通知AFNetworkingTaskDidSuspendNotification AFNetworkingTaskDidResumeNotification</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Method afResumeMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_resume));</div><div class="line">Method afSuspendMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_suspend));</div><div class="line"></div><div class="line"><span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_resume), afResumeMethod)) &#123;</div><div class="line">    af_swizzleSelector(theClass, <span class="keyword">@selector</span>(resume), <span class="keyword">@selector</span>(af_resume));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_suspend), afSuspendMethod)) &#123;</div><div class="line">    af_swizzleSelector(theClass, <span class="keyword">@selector</span>(suspend), <span class="keyword">@selector</span>(af_suspend));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AFNetworking-3-0迁移指南"><a href="#AFNetworking-3-0迁移指南" class="headerlink" title="AFNetworking 3.0迁移指南"></a>AFNetworking 3.0迁移指南</h2><p><code>新设备要求:</code> iOS 7, Mac OS X 10.9, watchOS 2, tvOS 9, &amp; Xcode 7</p>
<h3 id="NSURLConnection的API已废弃"><a href="#NSURLConnection的API已废弃" class="headerlink" title="NSURLConnection的API已废弃"></a>NSURLConnection的API已废弃</h3><p>AFNetworking 1.0建立在NSURLConnection的基础API之上 ，AFNetworking 2.0开始使用NSURLConnection的基础API ，以及较新基于NSURLSession的API的选项。 AFNetworking 3.0现已完全基于NSURLSession的API，这降低了维护的负担，同时支持苹果增强关于NSURLSession提供的任何额外功能。由于Xcode 7中，NSURLConnection的API已经正式被苹果弃用。虽然该API将继续运行，但将没有新功能将被添加，并且苹果已经通知所有基于网络的功能，以充分使NSURLSession向前发展。AFNetworking 2.X将继续获得关键的隐患和安全补丁，但没有新的功能将被添加。Alamofire(Swift下的网络请求)软件基金会建议，所有的项目迁移到基于NSURLSession的API。</p>
<h4 id="弃用的类"><a href="#弃用的类" class="headerlink" title="弃用的类"></a>弃用的类</h4><p>下面的类已从AFNetworking 3.0中废弃</p>
<ul>
<li>AFURLConnectionOperation</li>
<li>AFHTTPRequestOperation</li>
<li>AFHTTPRequestOperationManager</li>
</ul>
<h4 id="修改的类"><a href="#修改的类" class="headerlink" title="修改的类"></a>修改的类</h4><p>下面的类包含基于NSURLConnection的API的内部实现。他们已经被使用NSURLSession重构</p>
<ul>
<li>UIImageView+AFNetworking</li>
<li>UIWebView+AFNetworking</li>
<li>UIButton+AFNetworking</li>
</ul>
<h3 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h3><h4 id="AFHTTPRequestOperationManager-核心代码"><a href="#AFHTTPRequestOperationManager-核心代码" class="headerlink" title="AFHTTPRequestOperationManager 核心代码"></a>AFHTTPRequestOperationManager 核心代码</h4><p>如果你以前使用 AFHTTPRequestOperationManager ， 你将需要迁移去使用 AFHTTPSessionManager。 以下的类在两者过渡间并没有变化</p>
<ul>
<li>securityPolicy</li>
<li>requestSerializer</li>
<li>responseSerializer<br>接下来举一个关于AFHTTPSessionManager的简单例子。注意HTTP网络请求返回的不再是AFHTTPRequestOperation, 修改成为了NSURLSessionTask，并且成功和失败的Block块中的参数也变更为了NSURLSessionTask，而不再是AFHTTPRequestOperation。</li>
</ul>
<p>AFNetworking 2.x</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</div><div class="line">[manager GET:<span class="string">@"请求的url"</span> parameters:<span class="literal">nil</span> success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"成功"</span>);</div><div class="line">&#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span>*error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"失败"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">AFNetworking <span class="number">3.0</span></div><div class="line">AFHTTPSessionManager *session = [AFHTTPSessionManager manager];</div><div class="line">[session GET:<span class="string">@"请求的url"</span> parameters:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"成功"</span>);</div><div class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"失败"</span>);        </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="AFHTTPRequestOperation-核心代码"><a href="#AFHTTPRequestOperation-核心代码" class="headerlink" title="AFHTTPRequestOperation 核心代码"></a>AFHTTPRequestOperation 核心代码</h3><p>与NSURLConnection对象不同，每个共享应用范围的设置如会话管理、缓存策略、Cookie存储以及URL协议等，这些NSURLSession对象都可以单独进行配置。使用特定的配置来初始化会话，它可以发送任务来获取数据，并上传或下载文件。在AFNetworking 2.0中，使用AFHTTPRequestOperation，有可能创建一个没有额外开销的独立的网络请求来获取数据。NSURLSession则需要更多的开销，为了获得所要请求的数据。接下来，将要通过AFHTTPSessionManager创建一个对象，并创建一个任务和启动它。</p>
<ul>
<li>AFNetworking 2.x</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line">AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];</div><div class="line">op.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line"></div><div class="line">[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JSON: %@"</span>, responseObject);</div><div class="line">&#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">&#125;];</div><div class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue] addOperation:op];</div></pre></td></tr></table></figure>
<ul>
<li>AFNetworking 3.0</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@""</span>];</div><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line">[manager GET:URL.absoluteString parameters:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionTask</span> *task, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JSON: %@"</span>, responseObject);</div><div class="line">&#125; failure:^(<span class="built_in">NSURLSessionTask</span> *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="UIKit的迁移"><a href="#UIKit的迁移" class="headerlink" title="UIKit的迁移"></a>UIKit的迁移</h3><p>图片下载已经被重构，以遵循AlamofireImage架构与新的AFImageDownloader类。这个类的图片下载职责的代理人是UIButton与UIImageView的类目，并且提供了一些方法，在必要时可以自定义。类别中，下载远程图片的实际方法没有改变。UIWebView的类目被重构为使用AFHTTPSessionManager作为其网络请求。</p>
<h3 id="UIAlertView的类目被废弃"><a href="#UIAlertView的类目被废弃" class="headerlink" title="UIAlertView的类目被废弃"></a>UIAlertView的类目被废弃</h3><p>从AFNetworking 3.0后UIAlertView的类目因过时而被废弃。并没有提供UIAlertController类目的计划，因为这是应用程序应处理的逻辑，而不是这个库。</p>
]]></content>
    </entry>
    
  
  
</search>
